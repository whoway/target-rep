<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试题-操作系统 | whoway</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/images/photo.jpg">
    <link rel="manifest" href="/images/photo.jpg">
    <link rel="apple-touch-icon" href="/images/photo.jpg">
    <meta name="description" content="Personal Blog Website">
    <meta http-quiv="pragma" cotent="no-cache">
    <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
    <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.e8e4f3a3.css" as="style"><link rel="preload" href="/assets/js/app.1377ab92.js" as="script"><link rel="preload" href="/assets/js/2.e041faba.js" as="script"><link rel="preload" href="/assets/js/7.7fb14080.js" as="script"><link rel="prefetch" href="/assets/js/10.0031e17f.js"><link rel="prefetch" href="/assets/js/100.59633123.js"><link rel="prefetch" href="/assets/js/101.20f36433.js"><link rel="prefetch" href="/assets/js/102.a89937ec.js"><link rel="prefetch" href="/assets/js/103.5c49296a.js"><link rel="prefetch" href="/assets/js/104.f04cdb87.js"><link rel="prefetch" href="/assets/js/105.d6d373ac.js"><link rel="prefetch" href="/assets/js/106.087cd440.js"><link rel="prefetch" href="/assets/js/107.c269d959.js"><link rel="prefetch" href="/assets/js/108.3645c912.js"><link rel="prefetch" href="/assets/js/109.80b417ac.js"><link rel="prefetch" href="/assets/js/11.e8c25f05.js"><link rel="prefetch" href="/assets/js/110.96b6e760.js"><link rel="prefetch" href="/assets/js/111.8a93bd20.js"><link rel="prefetch" href="/assets/js/112.94403977.js"><link rel="prefetch" href="/assets/js/113.53bf9e9b.js"><link rel="prefetch" href="/assets/js/114.bcfb5d98.js"><link rel="prefetch" href="/assets/js/115.82380015.js"><link rel="prefetch" href="/assets/js/116.958b8690.js"><link rel="prefetch" href="/assets/js/117.51631ba0.js"><link rel="prefetch" href="/assets/js/118.75dcdfa9.js"><link rel="prefetch" href="/assets/js/119.5ce7c18b.js"><link rel="prefetch" href="/assets/js/12.0efb2ca9.js"><link rel="prefetch" href="/assets/js/120.d7edbed7.js"><link rel="prefetch" href="/assets/js/121.2709146e.js"><link rel="prefetch" href="/assets/js/122.12c7b2ed.js"><link rel="prefetch" href="/assets/js/123.d9b826c6.js"><link rel="prefetch" href="/assets/js/124.d760628d.js"><link rel="prefetch" href="/assets/js/125.30f43e35.js"><link rel="prefetch" href="/assets/js/126.1659dd46.js"><link rel="prefetch" href="/assets/js/127.12cd196e.js"><link rel="prefetch" href="/assets/js/128.16b54d71.js"><link rel="prefetch" href="/assets/js/129.d4362450.js"><link rel="prefetch" href="/assets/js/13.14945f5d.js"><link rel="prefetch" href="/assets/js/130.2b80d482.js"><link rel="prefetch" href="/assets/js/131.e4826b09.js"><link rel="prefetch" href="/assets/js/132.55bd12c8.js"><link rel="prefetch" href="/assets/js/133.b98aab46.js"><link rel="prefetch" href="/assets/js/134.67fbd05b.js"><link rel="prefetch" href="/assets/js/135.0879c18d.js"><link rel="prefetch" href="/assets/js/136.dbba091c.js"><link rel="prefetch" href="/assets/js/137.3aa1a82e.js"><link rel="prefetch" href="/assets/js/138.97e273b3.js"><link rel="prefetch" href="/assets/js/139.29998e3c.js"><link rel="prefetch" href="/assets/js/14.aa5a5677.js"><link rel="prefetch" href="/assets/js/140.0299455c.js"><link rel="prefetch" href="/assets/js/141.3efb116b.js"><link rel="prefetch" href="/assets/js/142.485471f3.js"><link rel="prefetch" href="/assets/js/143.b261be59.js"><link rel="prefetch" href="/assets/js/144.5cedce3a.js"><link rel="prefetch" href="/assets/js/145.d5e86239.js"><link rel="prefetch" href="/assets/js/146.6ee45c03.js"><link rel="prefetch" href="/assets/js/147.3114c054.js"><link rel="prefetch" href="/assets/js/148.e27b4585.js"><link rel="prefetch" href="/assets/js/149.e9869345.js"><link rel="prefetch" href="/assets/js/15.527e8250.js"><link rel="prefetch" href="/assets/js/150.230180a4.js"><link rel="prefetch" href="/assets/js/151.f86ec123.js"><link rel="prefetch" href="/assets/js/152.fe6b245b.js"><link rel="prefetch" href="/assets/js/153.33b1d68e.js"><link rel="prefetch" href="/assets/js/154.bb6b2192.js"><link rel="prefetch" href="/assets/js/155.24020d9f.js"><link rel="prefetch" href="/assets/js/156.d50c3407.js"><link rel="prefetch" href="/assets/js/157.c5dedcfe.js"><link rel="prefetch" href="/assets/js/158.7bd28b95.js"><link rel="prefetch" href="/assets/js/159.61a0b79f.js"><link rel="prefetch" href="/assets/js/16.eef91b6b.js"><link rel="prefetch" href="/assets/js/160.a6b122f2.js"><link rel="prefetch" href="/assets/js/161.ee89422d.js"><link rel="prefetch" href="/assets/js/162.55415ece.js"><link rel="prefetch" href="/assets/js/163.e8a23916.js"><link rel="prefetch" href="/assets/js/164.152bc73b.js"><link rel="prefetch" href="/assets/js/165.d2bcb0e2.js"><link rel="prefetch" href="/assets/js/166.82477818.js"><link rel="prefetch" href="/assets/js/167.640e13cb.js"><link rel="prefetch" href="/assets/js/168.c141cc38.js"><link rel="prefetch" href="/assets/js/169.a872bfd1.js"><link rel="prefetch" href="/assets/js/17.428da7ba.js"><link rel="prefetch" href="/assets/js/170.67240dc9.js"><link rel="prefetch" href="/assets/js/171.da4d5edb.js"><link rel="prefetch" href="/assets/js/172.2e3714e3.js"><link rel="prefetch" href="/assets/js/173.af693847.js"><link rel="prefetch" href="/assets/js/174.ec684d1d.js"><link rel="prefetch" href="/assets/js/175.23d3b0af.js"><link rel="prefetch" href="/assets/js/176.8d48a53b.js"><link rel="prefetch" href="/assets/js/177.c519080b.js"><link rel="prefetch" href="/assets/js/178.8db8d5ab.js"><link rel="prefetch" href="/assets/js/179.265fc515.js"><link rel="prefetch" href="/assets/js/18.43a447d0.js"><link rel="prefetch" href="/assets/js/180.894dbf3d.js"><link rel="prefetch" href="/assets/js/181.f057b51e.js"><link rel="prefetch" href="/assets/js/182.28f52539.js"><link rel="prefetch" href="/assets/js/183.95db44ff.js"><link rel="prefetch" href="/assets/js/184.c440dfe4.js"><link rel="prefetch" href="/assets/js/185.3f613bf6.js"><link rel="prefetch" href="/assets/js/186.45879c03.js"><link rel="prefetch" href="/assets/js/187.5559b209.js"><link rel="prefetch" href="/assets/js/188.1fd9b685.js"><link rel="prefetch" href="/assets/js/189.ff8fcbac.js"><link rel="prefetch" href="/assets/js/19.41bf08a2.js"><link rel="prefetch" href="/assets/js/190.3a9f4b8e.js"><link rel="prefetch" href="/assets/js/191.1e1617e2.js"><link rel="prefetch" href="/assets/js/192.c3360a2c.js"><link rel="prefetch" href="/assets/js/193.5c9408e5.js"><link rel="prefetch" href="/assets/js/194.3419ecfb.js"><link rel="prefetch" href="/assets/js/195.4ef92e8e.js"><link rel="prefetch" href="/assets/js/196.e09d4547.js"><link rel="prefetch" href="/assets/js/197.ac1d6ad4.js"><link rel="prefetch" href="/assets/js/198.3163ce5a.js"><link rel="prefetch" href="/assets/js/199.2eee9782.js"><link rel="prefetch" href="/assets/js/20.4f4f015a.js"><link rel="prefetch" href="/assets/js/200.5904874c.js"><link rel="prefetch" href="/assets/js/201.9824d6e2.js"><link rel="prefetch" href="/assets/js/202.13b05f57.js"><link rel="prefetch" href="/assets/js/203.b34b7b5f.js"><link rel="prefetch" href="/assets/js/204.89b6ae86.js"><link rel="prefetch" href="/assets/js/205.0190dc9a.js"><link rel="prefetch" href="/assets/js/206.81ee7c9a.js"><link rel="prefetch" href="/assets/js/207.5157fde2.js"><link rel="prefetch" href="/assets/js/208.c1b96e41.js"><link rel="prefetch" href="/assets/js/209.cd06b946.js"><link rel="prefetch" href="/assets/js/21.f591c1c9.js"><link rel="prefetch" href="/assets/js/210.c0f79ba0.js"><link rel="prefetch" href="/assets/js/211.3121726e.js"><link rel="prefetch" href="/assets/js/212.e232e4c1.js"><link rel="prefetch" href="/assets/js/213.355f899c.js"><link rel="prefetch" href="/assets/js/214.279649ab.js"><link rel="prefetch" href="/assets/js/215.35bf7d54.js"><link rel="prefetch" href="/assets/js/216.1f4f9d35.js"><link rel="prefetch" href="/assets/js/217.b10682dc.js"><link rel="prefetch" href="/assets/js/218.284ed97b.js"><link rel="prefetch" href="/assets/js/219.38167caa.js"><link rel="prefetch" href="/assets/js/22.acadb830.js"><link rel="prefetch" href="/assets/js/220.c463e9ea.js"><link rel="prefetch" href="/assets/js/221.a078f3ea.js"><link rel="prefetch" href="/assets/js/222.06285980.js"><link rel="prefetch" href="/assets/js/223.f38be854.js"><link rel="prefetch" href="/assets/js/224.92ba1852.js"><link rel="prefetch" href="/assets/js/225.a6ceb57c.js"><link rel="prefetch" href="/assets/js/23.898645b7.js"><link rel="prefetch" href="/assets/js/24.382e0be0.js"><link rel="prefetch" href="/assets/js/25.6ca0b51e.js"><link rel="prefetch" href="/assets/js/26.55743824.js"><link rel="prefetch" href="/assets/js/27.30e4b4a9.js"><link rel="prefetch" href="/assets/js/28.66cf39b5.js"><link rel="prefetch" href="/assets/js/29.0a43f953.js"><link rel="prefetch" href="/assets/js/3.be737fa7.js"><link rel="prefetch" href="/assets/js/30.c4b59586.js"><link rel="prefetch" href="/assets/js/31.e7822743.js"><link rel="prefetch" href="/assets/js/32.582db8f4.js"><link rel="prefetch" href="/assets/js/33.22fc96b9.js"><link rel="prefetch" href="/assets/js/34.95521ad1.js"><link rel="prefetch" href="/assets/js/35.08a5cbc1.js"><link rel="prefetch" href="/assets/js/36.8585fbef.js"><link rel="prefetch" href="/assets/js/37.c06f20fc.js"><link rel="prefetch" href="/assets/js/38.64a6d1af.js"><link rel="prefetch" href="/assets/js/39.f785742e.js"><link rel="prefetch" href="/assets/js/4.d6fe3273.js"><link rel="prefetch" href="/assets/js/40.07351fdf.js"><link rel="prefetch" href="/assets/js/41.de482863.js"><link rel="prefetch" href="/assets/js/42.f8ffc326.js"><link rel="prefetch" href="/assets/js/43.3551508f.js"><link rel="prefetch" href="/assets/js/44.9492eaa8.js"><link rel="prefetch" href="/assets/js/45.4aa3153c.js"><link rel="prefetch" href="/assets/js/46.90e8e5eb.js"><link rel="prefetch" href="/assets/js/47.01b87a9f.js"><link rel="prefetch" href="/assets/js/48.5a9afdbc.js"><link rel="prefetch" href="/assets/js/49.0a619e4d.js"><link rel="prefetch" href="/assets/js/5.db3a2e6c.js"><link rel="prefetch" href="/assets/js/50.08b551a7.js"><link rel="prefetch" href="/assets/js/51.483fa4f4.js"><link rel="prefetch" href="/assets/js/52.7fdf63ff.js"><link rel="prefetch" href="/assets/js/53.af42a7dc.js"><link rel="prefetch" href="/assets/js/54.417191ab.js"><link rel="prefetch" href="/assets/js/55.33a138b1.js"><link rel="prefetch" href="/assets/js/56.13ac1467.js"><link rel="prefetch" href="/assets/js/57.07e7ec9c.js"><link rel="prefetch" href="/assets/js/58.146638ba.js"><link rel="prefetch" href="/assets/js/59.066fa0f3.js"><link rel="prefetch" href="/assets/js/6.f1fa20ee.js"><link rel="prefetch" href="/assets/js/60.bf1afeec.js"><link rel="prefetch" href="/assets/js/61.b34da8bf.js"><link rel="prefetch" href="/assets/js/62.91f10786.js"><link rel="prefetch" href="/assets/js/63.78ec75e3.js"><link rel="prefetch" href="/assets/js/64.a1e8690b.js"><link rel="prefetch" href="/assets/js/65.341ee75d.js"><link rel="prefetch" href="/assets/js/66.4972821b.js"><link rel="prefetch" href="/assets/js/67.f29a1248.js"><link rel="prefetch" href="/assets/js/68.e030115f.js"><link rel="prefetch" href="/assets/js/69.a1650e7d.js"><link rel="prefetch" href="/assets/js/70.dbd4c775.js"><link rel="prefetch" href="/assets/js/71.0bb4a8fb.js"><link rel="prefetch" href="/assets/js/72.f2a1c3ff.js"><link rel="prefetch" href="/assets/js/73.bd52389e.js"><link rel="prefetch" href="/assets/js/74.1a4cb14f.js"><link rel="prefetch" href="/assets/js/75.2ca9f032.js"><link rel="prefetch" href="/assets/js/76.7efa6ccb.js"><link rel="prefetch" href="/assets/js/77.691ae53c.js"><link rel="prefetch" href="/assets/js/78.fdf3afed.js"><link rel="prefetch" href="/assets/js/79.a50199b6.js"><link rel="prefetch" href="/assets/js/8.40750d57.js"><link rel="prefetch" href="/assets/js/80.9bcbb285.js"><link rel="prefetch" href="/assets/js/81.178e79a1.js"><link rel="prefetch" href="/assets/js/82.2c1292ec.js"><link rel="prefetch" href="/assets/js/83.d7b63f9d.js"><link rel="prefetch" href="/assets/js/84.ea1af9bf.js"><link rel="prefetch" href="/assets/js/85.e0219bef.js"><link rel="prefetch" href="/assets/js/86.24b21f29.js"><link rel="prefetch" href="/assets/js/87.1f40fbe4.js"><link rel="prefetch" href="/assets/js/88.c6f1ca4d.js"><link rel="prefetch" href="/assets/js/89.0da95155.js"><link rel="prefetch" href="/assets/js/9.bacfe0c0.js"><link rel="prefetch" href="/assets/js/90.0aaad723.js"><link rel="prefetch" href="/assets/js/91.8b7c1778.js"><link rel="prefetch" href="/assets/js/92.7959acdd.js"><link rel="prefetch" href="/assets/js/93.3f84e827.js"><link rel="prefetch" href="/assets/js/94.6dc21869.js"><link rel="prefetch" href="/assets/js/95.75fcd579.js"><link rel="prefetch" href="/assets/js/96.e972200e.js"><link rel="prefetch" href="/assets/js/97.0db45112.js"><link rel="prefetch" href="/assets/js/98.25d649a0.js"><link rel="prefetch" href="/assets/js/99.4fd02d79.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e8e4f3a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">whoway</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎓Coding" class="dropdown-title"><span class="title">🎓Coding</span> <span class="arrow down"></span></button> <button type="button" aria-label="🎓Coding" class="mobile-dropdown-title"><span class="title">🎓Coding</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/00.Coding/TheBeautyOfProgramming/" class="nav-link">
  🔖编程之美题解
</a></li><li class="dropdown-item"><!----> <a href="/00.Coding/CodeWarehouse/" class="nav-link">
  🔖代码意识流
</a></li><li class="dropdown-item"><!----> <a href="/00.Coding/" class="nav-link">
  🔖面试题题解
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🚀语言" class="dropdown-title"><span class="title">🚀语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="🚀语言" class="mobile-dropdown-title"><span class="title">🚀语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/01.Language/Overview/" class="nav-link">
  🔖概述
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/C/" class="nav-link">
  ⭐️C
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Cpp/" class="nav-link">
  🚀C++
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Java/" class="nav-link">
  ☕️Java
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Python/" class="nav-link">
  🧩Python3
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Fortran/" class="nav-link">
  🎲Fortran
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/JavaScript/" class="nav-link">
  🎨JavaScript
</a></li></ul></div></div><div class="nav-item"><a href="/02.Hardware/" class="nav-link">
  ✔️硬件基础
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="⭐️软件基础" class="dropdown-title"><span class="title">⭐️软件基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="⭐️软件基础" class="mobile-dropdown-title"><span class="title">⭐️软件基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/03.Software/01.DataStructureAndAlgorithm/" class="nav-link">
  🐾数据结构和算法
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/02.server/" class="nav-link router-link-active">
  🎨server
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/03.Database/" class="nav-link">
  🔖数据库
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/04.SE/" class="nav-link">
  ✅软件工程
</a></li></ul></div></div><div class="nav-item"><a href="/04.PerformanceOpt/" class="nav-link">
  🔥性能调优
</a></div><div class="nav-item"><a href="/05.Engineer/" class="nav-link">
  🔖学术/工程
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="⚙️工具" class="dropdown-title"><span class="title">⚙️工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="⚙️工具" class="mobile-dropdown-title"><span class="title">⚙️工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/06.Tools/01.employment/" class="nav-link">
  🔖求职
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/02.efficiency/" class="nav-link">
  🚀效能
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/03.windows/" class="nav-link">
  ⚙️Windows
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/04.design/" class="nav-link">
  🧩设计
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/whoway" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎓Coding" class="dropdown-title"><span class="title">🎓Coding</span> <span class="arrow down"></span></button> <button type="button" aria-label="🎓Coding" class="mobile-dropdown-title"><span class="title">🎓Coding</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/00.Coding/TheBeautyOfProgramming/" class="nav-link">
  🔖编程之美题解
</a></li><li class="dropdown-item"><!----> <a href="/00.Coding/CodeWarehouse/" class="nav-link">
  🔖代码意识流
</a></li><li class="dropdown-item"><!----> <a href="/00.Coding/" class="nav-link">
  🔖面试题题解
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🚀语言" class="dropdown-title"><span class="title">🚀语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="🚀语言" class="mobile-dropdown-title"><span class="title">🚀语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/01.Language/Overview/" class="nav-link">
  🔖概述
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/C/" class="nav-link">
  ⭐️C
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Cpp/" class="nav-link">
  🚀C++
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Java/" class="nav-link">
  ☕️Java
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Python/" class="nav-link">
  🧩Python3
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Fortran/" class="nav-link">
  🎲Fortran
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/JavaScript/" class="nav-link">
  🎨JavaScript
</a></li></ul></div></div><div class="nav-item"><a href="/02.Hardware/" class="nav-link">
  ✔️硬件基础
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="⭐️软件基础" class="dropdown-title"><span class="title">⭐️软件基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="⭐️软件基础" class="mobile-dropdown-title"><span class="title">⭐️软件基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/03.Software/01.DataStructureAndAlgorithm/" class="nav-link">
  🐾数据结构和算法
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/02.server/" class="nav-link router-link-active">
  🎨server
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/03.Database/" class="nav-link">
  🔖数据库
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/04.SE/" class="nav-link">
  ✅软件工程
</a></li></ul></div></div><div class="nav-item"><a href="/04.PerformanceOpt/" class="nav-link">
  🔥性能调优
</a></div><div class="nav-item"><a href="/05.Engineer/" class="nav-link">
  🔖学术/工程
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="⚙️工具" class="dropdown-title"><span class="title">⚙️工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="⚙️工具" class="mobile-dropdown-title"><span class="title">⚙️工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/06.Tools/01.employment/" class="nav-link">
  🔖求职
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/02.efficiency/" class="nav-link">
  🚀效能
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/03.windows/" class="nav-link">
  ⚙️Windows
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/04.design/" class="nav-link">
  🧩设计
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/whoway" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面试题-操作系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#目录" class="sidebar-link">目录</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#为什么需要虚拟内存-目的是什么" class="sidebar-link">为什么需要虚拟内存？目的是什么？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程和线程区别" class="sidebar-link">进程和线程区别</a></li></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#如何实现线程池的" class="sidebar-link">如何实现线程池的？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#请你说说线程和协程的区别" class="sidebar-link">请你说说线程和协程的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#什么叫cpu密集型和i-o密集型任务" class="sidebar-link">什么叫CPU密集型和I/O密集型任务？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#什么叫-零拷贝" class="sidebar-link">什么叫“零拷贝”？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#区分mmap和sendfile" class="sidebar-link">区分mmap和sendfile？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#什么叫同步和异步、阻塞和非阻塞和轮询" class="sidebar-link">什么叫同步和异步、阻塞和非阻塞和轮询</a></li></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#比较一下多cpu和多核cpu" class="sidebar-link">比较一下多CPU和多核cpu</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#了解什么是线程池吗-池化的概念" class="sidebar-link">了解什么是线程池吗？池化的概念？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#线程和进程对比" class="sidebar-link">线程和进程对比</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-1-概念-多任务" class="sidebar-link">1.1.概念：多任务</a></li><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-2-q-多进程和多线程的对比-主要优势对比" class="sidebar-link">1.2.Q：多进程和多线程的对比，主要优势对比</a></li><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-3-q-为什么需要多线程" class="sidebar-link">1.3.Q：为什么需要多线程？</a></li><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-4-q-为什么任何一个线程挂掉都可能直接造成整个进程崩溃" class="sidebar-link">1.4.Q：为什么任何一个线程挂掉都可能直接造成整个进程崩溃？</a></li></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#图表记忆" class="sidebar-link">图表记忆</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#图1-进程控制块-pcb" class="sidebar-link">图1.进程控制块（PCB）</a></li><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#解释图1-进程控制块-pcb" class="sidebar-link">解释图1.进程控制块（PCB）</a></li></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程同步『7侠传』进程间通信" class="sidebar-link">进程同步『7侠传』进程间通信</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#线程同步技术『4大天王』" class="sidebar-link">线程同步技术『4大天王』</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#程序员的自我修养-编码链接和库分类" class="sidebar-link">程序员的自我修养，编码链接和库分类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程-线程-协程区别" class="sidebar-link">进程-线程-协程区别</a></li></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#什么是上下文切换" class="sidebar-link">什么是上下文切换？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#什么是tlb" class="sidebar-link">什么是TLB？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#大小端之争" class="sidebar-link">大小端之争</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#大端和小端存储-引子" class="sidebar-link">大端和小端存储-引子</a></li><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-1-概念" class="sidebar-link">2.1.概念</a></li><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-2-具体的-大端法和小端法的应用" class="sidebar-link">2.2.具体的，大端法和小端法的应用</a></li><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-3-大端法和小端法导致的问题" class="sidebar-link">2.3.大端法和小端法导致的问题：</a></li><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-4-如何判别大端和小端" class="sidebar-link">2.4.如何判别大端和小端</a></li></ul></li><li><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-概念辨析" class="sidebar-link">3.概念辨析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-1-终端" class="sidebar-link">3.1.终端</a></li><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-2-僵尸进程-zombie" class="sidebar-link">3.2.僵尸进程（Zombie）</a></li><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-3-孤儿进程" class="sidebar-link">3.3.孤儿进程</a></li><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-4-init-进程" class="sidebar-link">3.4.init 进程</a></li><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-5-内核" class="sidebar-link">2.5.内核</a></li><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-6-进程组-作业" class="sidebar-link">2.6.进程组（作业）</a></li><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-7-会话-session" class="sidebar-link">2.7.会话（session）</a></li><li class="sidebar-sub-header"><a href="/03.Software/02.server/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-8-守护进程-daemon-『后台开发核心』" class="sidebar-link">2.8.守护进程（daemon）『后台开发核心』</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="面试题-操作系统"><a href="#面试题-操作系统" class="header-anchor">#</a> 面试题-操作系统</h1> <table><thead><tr><th>硬件</th> <th>OS管理</th> <th>说明</th></tr></thead> <tbody><tr><td>CPU（控制器和运算器）</td> <td><strong>进程</strong>管理</td> <td></td></tr> <tr><td>I/O（输入和输出）</td> <td>I/O管理</td> <td>网络数据传输、中断、缓冲区</td></tr> <tr><td>存储器</td> <td>内存管理、外存管理</td> <td>寄存器、内存、固态/机械硬盘</td></tr></tbody></table> <h2 id="目录"><a href="#目录" class="header-anchor">#</a> 目录</h2> <p></p><div class="table-of-contents"><ul><li><a href="#目录">目录</a></li><li><a href="#为什么需要虚拟内存-目的是什么">为什么需要虚拟内存？目的是什么？</a><ul><li><a href="#进程和线程区别">进程和线程区别</a></li></ul></li><li><a href="#如何实现线程池的">如何实现线程池的？</a></li><li><a href="#请你说说线程和协程的区别">请你说说线程和协程的区别</a></li><li><a href="#什么叫cpu密集型和i-o密集型任务">什么叫CPU密集型和I/O密集型任务？</a></li><li><a href="#什么叫-零拷贝">什么叫“零拷贝”？</a></li><li><a href="#区分mmap和sendfile">区分mmap和sendfile？</a><ul><li><a href="#什么叫同步和异步、阻塞和非阻塞和轮询">什么叫同步和异步、阻塞和非阻塞和轮询</a></li></ul></li><li><a href="#比较一下多cpu和多核cpu">比较一下多CPU和多核cpu</a></li><li><a href="#了解什么是线程池吗-池化的概念">了解什么是线程池吗？池化的概念？</a></li><li><a href="#线程和进程对比">线程和进程对比</a><ul><li><a href="#_1-1-概念-多任务">1.1.概念：多任务</a></li><li><a href="#_1-2-q-多进程和多线程的对比-主要优势对比">1.2.Q：多进程和多线程的对比，主要优势对比</a></li><li><a href="#_1-3-q-为什么需要多线程">1.3.Q：为什么需要多线程？</a></li><li><a href="#_1-4-q-为什么任何一个线程挂掉都可能直接造成整个进程崩溃">1.4.Q：为什么任何一个线程挂掉都可能直接造成整个进程崩溃？</a></li></ul></li><li><a href="#图表记忆">图表记忆</a><ul><li><a href="#图1-进程控制块-pcb">图1.进程控制块（PCB）</a></li><li><a href="#解释图1-进程控制块-pcb">解释图1.进程控制块（PCB）</a></li></ul></li><li><a href="#进程同步『7侠传』进程间通信">进程同步『7侠传』进程间通信</a></li><li><a href="#线程同步技术『4大天王』">线程同步技术『4大天王』</a></li><li><a href="#程序员的自我修养-编码链接和库分类">程序员的自我修养，编码链接和库分类</a><ul><li><a href="#进程-线程-协程区别">进程-线程-协程区别</a></li></ul></li><li><a href="#什么是上下文切换">什么是上下文切换？</a></li><li><a href="#什么是tlb">什么是TLB？</a></li><li><a href="#大小端之争">大小端之争</a><ul><li><a href="#大端和小端存储-引子">大端和小端存储-引子</a></li><li><a href="#_2-1-概念">2.1.概念</a></li><li><a href="#_2-2-具体的-大端法和小端法的应用">2.2.具体的，大端法和小端法的应用</a></li><li><a href="#_2-3-大端法和小端法导致的问题">2.3.大端法和小端法导致的问题：</a></li><li><a href="#_2-4-如何判别大端和小端">2.4.如何判别大端和小端</a></li></ul></li><li><a href="#_3-概念辨析">3.概念辨析</a><ul><li><a href="#_3-1-终端">3.1.终端</a></li><li><a href="#_3-2-僵尸进程-zombie">3.2.僵尸进程（Zombie）</a></li><li><a href="#_3-3-孤儿进程">3.3.孤儿进程</a></li><li><a href="#_3-4-init-进程">3.4.init 进程</a></li><li><a href="#_2-5-内核">2.5.内核</a></li><li><a href="#_2-6-进程组-作业">2.6.进程组（作业）</a></li><li><a href="#_2-7-会话-session">2.7.会话（session）</a></li><li><a href="#_2-8-守护进程-daemon-『后台开发核心』">2.8.守护进程（daemon）『后台开发核心』</a></li></ul></li></ul></div><p></p> <p>[TOC]</p> <h2 id="为什么需要虚拟内存-目的是什么"><a href="#为什么需要虚拟内存-目的是什么" class="header-anchor">#</a> 为什么需要虚拟内存？目的是什么？</h2> <ul><li>第一，虚拟内存可以使得进程运行内存<strong>超过</strong>物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li> <li>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。</li> <li>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写<strong>权限</strong>，标记该页是否存在等。在内存访问方面，操作系统提供了更好的<strong>安全性</strong>。</li> <li>参考资料：小林coding</li></ul> <h3 id="进程和线程区别"><a href="#进程和线程区别" class="header-anchor">#</a> 进程和线程区别</h3> <table><thead><tr><th></th> <th>进程</th> <th>线程</th></tr></thead> <tbody><tr><td><strong>共享</strong>资源</td> <td>代码段，公共数据，进程目录，进程 ID</td> <td>1. ⽂件描述符表<br>2. 每种信号的处理⽅式<br>3. 当前⼯作⽬录<br>4. ⽤户ID和组ID<br>3. 线程⾮共享资源</td></tr> <tr><td>私有资源</td> <td>地址空间、堆、全局变量、栈、寄存器</td> <td>1. 线程id<br>2. 处理器现场和栈指针(内核栈)<br>3. 独⽴的栈空间(⽤户空间栈)<br>4. errno变ᰁ<br>5. 信号屏蔽字 <br>6. 调度优先级</td></tr> <tr><td>优点</td> <td></td> <td>1. 提⾼程序并发性<br>2. 开销⼩<br>3. 数据通信、共享数据⽅便</td></tr> <tr><td>缺点</td> <td></td> <td>1. 库函数，不稳定<br>2. 调试、编写困难、gdb不⽀持<br>3. 对信号⽀持不好</td></tr> <tr><td></td> <td></td> <td></td></tr></tbody></table> <p>线程如何减少开销</p> <ol><li>线程创建快，进程创建需要资源管理信息，⽐如内存管理信息和⽂件管理信息，⽽线程创建后是共享其所属进
程的资源管理信息;</li> <li>线程终⽌时间快，需要回收的仅有少量寄存器和私有的栈区;</li> <li>线程切换快，因为线程<strong>切换</strong>仅涉及到少量寄存器和栈区，⽽进程上下⽂切换有CPU寄存器和程序计数器(CPU
上下⽂)、虚拟内存空间、⻚表切换、<strong>TLB失效</strong>等;</li> <li>线程因为创建时<strong>共享了</strong>其所述进程绝⼤多数资源，因此天⽣具有很好的线程间通信交互效率。</li></ol> <h2 id="如何实现线程池的"><a href="#如何实现线程池的" class="header-anchor">#</a> 如何实现线程池的？</h2> <p>线程池的组成</p> <ol><li>线程池管理器：初始化和创建线程，启动和停止线程，调配任务；管理线程池</li> <li>工作线程：线程池中等待并<strong>执行</strong>分配的<strong>任务</strong></li> <li>任务<strong>接口</strong>：添加<strong>任务</strong>的<strong>接口</strong>，以提供工作线程调度任务的执行。</li> <li><strong>任务队列</strong>：用于存放<strong>没有处理</strong>的任务，提供一种缓冲机制，同时具有调度功能，高优先级的任务放在队列前面</li></ol> <table><thead><tr><th></th> <th>进程</th> <th>线程</th> <th>协程</th></tr></thead> <tbody><tr><td>概念</td> <td>- 一段<strong>程序</strong>的执行过程 - 是<strong>资源分配</strong>的最小单位</td> <td>操作系统（内核）<strong>运算调度</strong>的最小单位</td> <td>用户态实现的<strong>运算调度</strong>单位 可暂停和恢复执行的过程(函数)</td></tr> <tr><td>独立资源</td> <td>- 虚拟内存空间（代码段、数据段、堆栈等） - 内核栈、thread_info、task_struct(pid,tgid等） - 寄存器组的值</td> <td>- 线程id(pid) - 堆栈 - 寄存器组的值</td> <td>- 栈 - 部分栈切换的寄存器</td></tr> <tr><td>切换代价</td> <td>高</td> <td>中</td> <td>低</td></tr> <tr><td>通信（同步）方式</td> <td>1. 管道/匿名管道 2. 有名管道 3. 信号 4. 消息队列 5. 共享内存 6. 信号量 7. 套接字</td> <td>1. 锁机制 2. 信号量机制 3.信号机制</td> <td>Future，channel, pub/sub等</td></tr> <tr><td>优点</td> <td>1. 进程间相互独立，一个进程出了问题不会影响其它进程 2. 可以利用多CPU的资源</td> <td>1. 线程之间共享内存和变量，通信比较方便 2. 程序逻辑和控制方式简单 3. 上下文切换资源消耗中等</td> <td>1. 无须原子操作锁定及同步的开销 2. 上下文切换资源小 3. 高并发性、高扩展性、低成本</td></tr> <tr><td>缺点</td> <td>1. 需要跨进程边界，当数据交流大是开销比较高 2. 创建、上下文切换开销大</td> <td>1.线程之间的同步和加锁控制比较麻烦 2. 一个线程的崩溃可能影响到整个程序的稳定性</td> <td>1. 不能使用多核资源</td></tr> <tr><td>适用场景</td> <td>CPU密集型操作（如科学计算）</td> <td>1. 多核CPU 2. I/O密集操作(网络I/O,磁盘I/O)</td> <td>单核CPU I/O密集型操作（网络I/O，如秒杀系统，RPC服务器，即时通讯等）</td></tr></tbody></table> <ul><li>参考资料：https://htmonster.xyz/blog/post/dui-bi-fen-xi-jin-cheng-xian-cheng-yu-xie-cheng/</li></ul> <h2 id="请你说说线程和协程的区别"><a href="#请你说说线程和协程的区别" class="header-anchor">#</a> 请你说说线程和协程的区别</h2> <p>解题思路</p> <p>标准回答 线程和协程的区别如下：</p> <p>\1. 线程是操作系统的资源，线程的创建、切换、停止等都非常消耗资源，而创建<strong>协程</strong>不需要调用操作系统的功能，编程语言自身就能完成，所以协程也被称为用户态线程，协程比线程轻量很多；</p> <p>\2. 线程在多核环境下是能做到真正意义上的并行，而协程是为<strong>并发</strong>而产生的；</p> <p>\3. 一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要<strong>彼此协作</strong>的运行；</p> <p>\4. 线程进程都是同步机制，而协程则是异步；</p> <p>\5. 线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此<strong>同一时间其实只有一个协程</strong>拥有运行权，相当于单线程的能力；</p> <p>\6. 操作系统对于线程开辟数量限制在千的级别，而协程可以达到<strong>上万</strong>的级别。</p> <h2 id="什么叫cpu密集型和i-o密集型任务"><a href="#什么叫cpu密集型和i-o密集型任务" class="header-anchor">#</a> 什么叫CPU密集型和I/O密集型任务？</h2> <h4 id="cpu密集型-cpu-bound"><a href="#cpu密集型-cpu-bound" class="header-anchor">#</a> CPU密集型（CPU-bound）</h4> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>CPU密集型也叫计算密集型，英文为CPU-bound，直译为CPU『受限』型
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>特点：</p></blockquote> <ul><li>1.是要进行大量的计算，<font style="background:yellow;">消耗CPU资源</font></li> <li>2.这种计算密集型任务虽然也可以用多任务完成，但是<font style="background:yellow;">任务越多，花在『任务切换』的时间就越多，CPU执行任务的『效率』就越低</font></li> <li>3.要最高效地利用CPU，计算密集型任务同时进行的数量应当<strong>等于</strong>CPU的核心数。</li></ul> <h4 id="i-o密集型-i-o-bound"><a href="#i-o密集型-i-o-bound" class="header-anchor">#</a> I/O密集型（I/O-bound）</h4> <ul><li>IO密集型，涉及到<font style="background:yellow;">网络、磁盘IO</font>的任务都是IO密集型任务</li> <li>这类任务的特点是<strong>CPU消耗很少</strong>，任务的<strong>大部分时间都在等待IO操作完成</strong>（因为IO的速度远远低于CPU和内存的速度）</li> <li>对于IO密集型任务，<font style="background:yellow;">任务越多，CPU效率越高，但也有一个限度</font>。常见的大部分任务都是IO密集型任务，比如Web应用。</li></ul> <blockquote><p>参考资料：</p></blockquote> <ul><li>维基百科：<a href="https://zh.wikipedia.org/wiki/CPU%E5%AF%86%E9%9B%86%E5%9E%8B" target="_blank" rel="noopener noreferrer">CPU密集型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>廖雪峰描述<a href="https://www.liaoxuefeng.com/wiki/897692888725344/945570591695328" target="_blank" rel="noopener noreferrer">CPU密集型和I/O密集型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="什么叫-零拷贝"><a href="#什么叫-零拷贝" class="header-anchor">#</a> 什么叫“零拷贝”？</h2> <p>​	“零拷贝”描述了计算机操作，其中 <strong>CPU 不执行</strong>将数据从<strong>一个存储区</strong>复制到<strong>另一个存储区</strong>的任务。通过网络传输文件时，通常用于<strong>节省CPU周期</strong>和<strong>内存带宽</strong>。</p> <p><strong>广义狭义之分</strong></p> <p>​	从上面的概念不难发现零拷贝的核心是 CPU 不执行将数据从一个存储区复制到另一个存储区的任务。可能你会说，那零拷贝是不是 0 次调用 CPU 消耗资源啊？<strong>既对也不对</strong>，为什么这样说呢？实际上，零拷贝有广义和狭义之分。</p> <p><strong>1.广义零拷贝</strong></p> <p>​	能减少拷贝次数，<strong>减少不必要</strong>的数据拷贝，就算作“零拷贝”。这是目前，对零拷贝<strong>最为广泛</strong>的定义，我们需要知道的是，这是广义上的零拷贝，并不是操作系统意义上的零拷贝。</p> <p><strong>1.2.2 狭义零拷贝</strong></p> <p>​	<strong>Linux 2.4 内核</strong>新增 <strong>sendfile</strong> 系统调用，提供了零拷贝。磁盘数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NIC Buffer(socket buffer)，无需 CPU 拷贝。这是<strong>真正操作系统意义上</strong>的零拷贝(也就是狭义零拷贝)。</p> <p>​	比如我们常见的磁盘控制器、<strong>显卡</strong>、<strong>网卡</strong>、声卡都是支持 DMA 的，可以说 DMA 已经彻底融入我们的计算机世界了。</p> <ul><li>参考资料：<a href="https://mp.weixin.qq.com/s/GSzbiVge-aoDHxYCzCTALw" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/GSzbiVge-aoDHxYCzCTALw<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="区分mmap和sendfile"><a href="#区分mmap和sendfile" class="header-anchor">#</a> 区分mmap和sendfile？</h2> <p>​	可以认为，sendfile是为了更加优化mmap来解决“零拷贝”的</p> <ul><li>sendfile，数据根本不经过用户态，直接从内核缓冲区进入到 Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换。</li></ul> <h3 id="什么叫同步和异步、阻塞和非阻塞和轮询"><a href="#什么叫同步和异步、阻塞和非阻塞和轮询" class="header-anchor">#</a> 什么叫同步和异步、阻塞和非阻塞和轮询</h3> <ul><li><p>同步（Synchronization）</p></li> <li><p>异步（asynchronous）</p></li> <li><p>阻塞（blocking）</p></li> <li><p>非阻塞（ non-blocking）</p></li> <li><p>轮询（polling）</p></li></ul> <h2 id="比较一下多cpu和多核cpu"><a href="#比较一下多cpu和多核cpu" class="header-anchor">#</a> 比较一下多CPU和多核cpu</h2> <blockquote><p><a href="https://sunweiguo.github.io/2019/11/17/miscellany/20%E5%85%B3%E4%BA%8E%E5%A4%9ACPU%E5%92%8C%E5%A4%9A%E6%A0%B8CPU%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener noreferrer">关于多CPU和多核CPU的区别<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>多进程、进程同步、进程池
多线程、线程同步、线程池
协程
同步、异步、阻塞、非阻塞、轮询
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="custom-block tip"><p class="custom-block-title">多线程-新时代的宠儿</p> <p>『单核CPU』时代和『多核CPU/多CPU』时代</p></div> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>1、单CPU中进程只能是并发，多CPU计算机中进程可以并行
2、『单CPU』『单核』中线程只能并发，『单CPU』『多核』中线程可以并行
3、无论是并发还是并行，使用者来看，看到的是多进程，多线程
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="了解什么是线程池吗-池化的概念"><a href="#了解什么是线程池吗-池化的概念" class="header-anchor">#</a> 了解什么是线程池吗？池化的概念？</h2> <ul><li>进程池</li> <li>线程池</li> <li>数据库连接池</li></ul> <p>线程池</p> <ul><li>线程池：是由服务器预先创建的一组子线程</li></ul> <p>下文参考自：<a href="https://mp.weixin.qq.com/s?__biz=MzI1NTE3OTk4Nw==&amp;mid=2653734974&amp;idx=1&amp;sn=987f9a4cfea1c830036ae20fc04866d5&amp;chksm=f1e18582c6960c941a5e147c198d9cbc3f27e88dbb82fb62f0d23261821070bd43bdfd2fc2b2&amp;mpshare=1&amp;scene=23&amp;srcid=0728Ab0PK8WsIZWsv1UoVm8L&amp;sharer_sharetime=1595948760667&amp;sharer_shareid=7d02bdfe8ee477ab2b773f2df63f3163#rd" target="_blank" rel="noopener noreferrer">链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="什么是线程池"><a href="#什么是线程池" class="header-anchor">#</a> 什么是线程池？</h4> <p>实际开发中我们需要让程序执行某个特定任务时，就会开启一个线程，如果并发的线程数量太多，频繁地创建线程就会严重影响系统的运行效率。</p> <ul><li>如何解决上述为呢？有没有一种方式可以让线程得到复用？</li> <li>也就是要求执行一次任务之后不被销毁，可以继续执行其他任务，这就跟“数据库连接池”的思路一样了，数据库连接池的实现逻辑是在缓冲池中预先放置一定数量的连接对象，然后进行复用，那么很显然，在缓冲池中<b>预先放置一定数量的线程对象</b>以实现复用的机制就叫做线程池。</li></ul> <h4 id="线程池的优点"><a href="#线程池的优点" class="header-anchor">#</a> 线程池的优点</h4> <ul><li>1.使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。</li> <li>2.可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。</li></ul> <h2 id="线程和进程对比"><a href="#线程和进程对比" class="header-anchor">#</a> 线程和进程对比</h2> <ul><li><strong>进程</strong>是<strong>资源管理</strong>的最小单位</li> <li><strong>线程</strong>是<strong>程序执行</strong>的最小单位『前提是支持线程』</li> <li>记忆方法：<br> <font style="background:yellow;">大Boss（进程），只管拿着资源统筹兼顾。
小兵（线程），要卖力执行命令</font></li></ul> <h4 id="⭐️进程和线程在两大os的特点"><a href="#⭐️进程和线程在两大os的特点" class="header-anchor">#</a> ⭐️进程和线程在两大OS的特点</h4> <ul><li>Windows对进程和线程的实现如同『教科书』一般标准。</li></ul> <blockquote><ul><li><font style="background:yellow;">Windows内核中有明确的<b>进程</b>和<b>线程</b>的概念</font></li></ul></blockquote> <ul><li>Linux内核中<b>并不存在真正意义上</b>的<b>线程</b>的概念</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token operator">-</span> Linux将所有的执行实体（无论是进程还是线程）都称为『『任务（Task）』』

<span class="token operator">-</span> 每个Task概念上都类似于一个单线程的进程，具有内存空间、执行实体、文件资源等。
    
<span class="token operator">-</span> 不过<span class="token punctuation">,</span>Linux下『不同的Task（任务）之间可以选择共享内存空间』，因而在实际意义上，共享了同一个内存空间的多个任务构成了一个进程， 这些任务也就成了这个进程里的线程。
    
<span class="token operator">-</span> Linux下的线程『本质』上用进程实现『牛客题目』
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_1-1-概念-多任务"><a href="#_1-1-概念-多任务" class="header-anchor">#</a> 1.1.概念：多任务</h3> <ul><li><strong>多任务</strong>可以由<strong>多进程</strong>完成，也可以由一个进程内的<strong>多线程</strong>完成。</li></ul> <h3 id="_1-2-q-多进程和多线程的对比-主要优势对比"><a href="#_1-2-q-多进程和多线程的对比-主要优势对比" class="header-anchor">#</a> 1.2.Q：多进程和多线程的对比，主要优势对比</h3> <ul><li>多进程模型，适用于：CPU密集型</li> <li>多线程模型，<strong>主要优势</strong>为：线程间切换代价较少，因此适用于I/O密集型的工作场景。
<ul><li>『因此，I/O密集型的工作场景经常会由于<strong>I/O阻塞</strong>导致<strong>频繁的切换线程</strong>。</li></ul></li></ul> <h3 id="_1-3-q-为什么需要多线程"><a href="#_1-3-q-为什么需要多线程" class="header-anchor">#</a> 1.3.Q：为什么需要多线程？</h3> <ul><li>多线程可以提高程序的执行性能</li></ul> <blockquote><p>继续补充。</p></blockquote> <h3 id="_1-4-q-为什么任何一个线程挂掉都可能直接造成整个进程崩溃"><a href="#_1-4-q-为什么任何一个线程挂掉都可能直接造成整个进程崩溃" class="header-anchor">#</a> 1.4.Q：为什么任何一个线程挂掉都可能直接造成整个进程崩溃？</h3> <ul><li>多线程模式致命的缺点就是：因为所有线程『共享进程的内存』</li></ul> <h2 id="图表记忆"><a href="#图表记忆" class="header-anchor">#</a> 图表记忆</h2> <h3 id="图1-进程控制块-pcb"><a href="#图1-进程控制块-pcb" class="header-anchor">#</a> 图1.进程控制块（PCB）</h3> <img src="/assets/img/进程控制块PCB.03966435.png"> <h3 id="解释图1-进程控制块-pcb"><a href="#解释图1-进程控制块-pcb" class="header-anchor">#</a> 解释图1.进程控制块（PCB）</h3> <p>为了管理进程，内核必须对每个进程所做的事情进行『清楚的描述』。
内核为每个进程分配一个<code>PCB(Processing Control Block)</code>进程控制块，维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p> <p>其内部成员有很多，我们只需要掌握『<strong>以下部分</strong>』即可:</p> <ul><li>进程id:系统中每个进程有唯一的id，用<code>pid_t</code>类型表示，其实就是一个非负整数</li> <li>进程的状态:有就绪、运行、挂起、停止等状态</li> <li><strong>进程切换</strong>时需要保存和恢复的一些<strong>CPU寄存器</strong></li> <li>描述虚拟地址空间的信息</li> <li>描述控制终端的信息</li> <li>当前工作目录(Current Working Directory)</li> <li>umask掩码</li> <li>文件描述符表，包含很多指向<code>file结构体</code>的指针</li> <li>和信号相关的信息</li> <li>用户id和组id</li> <li>会话(Session和进程组</li> <li>进程可以使用的资源上限(Resource Limit)</li></ul> <h2 id="进程同步『7侠传』进程间通信"><a href="#进程同步『7侠传』进程间通信" class="header-anchor">#</a> 进程同步『7侠传』进程间通信</h2> <ul><li>图片参考自：小林coding</li></ul> <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/3-%E6%8F%90%E7%BA%B2.jpg"> <ul><li>保证2点：进程同步、数据交换</li></ul> <h4 id="⭐️2-1-管道-pipe"><a href="#⭐️2-1-管道-pipe" class="header-anchor">#</a> ⭐️2.1.管道（PIPE）</h4> <blockquote><p>(使用最简单)</p></blockquote> <ul><li>有名管道</li> <li>无名管道
<ul><li>语法最方便，代码编写量最少。与管道对应的，另一种通信方式是<strong>fifo</strong>：我们把它称之为“有名管道”，所以有书，称<strong>pipe</strong>管道为：“未名管道”或者“匿名管道”,用于（<strong>非血缘关系</strong>进程间通信）</li></ul></li></ul> <h4 id="⭐️2-2-信号量-semaphore"><a href="#⭐️2-2-信号量-semaphore" class="header-anchor">#</a> ⭐️2.2.信号量（Semaphore）</h4> <ul><li>无名线程信号量</li> <li>命名线程信号量🔐</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span><span class="token comment">//需要include这个</span></span>

<span class="token keyword">int</span> <span class="token function">sem_init</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sem_destroy</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">sem_wait</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sem_post</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sem_getvalue</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>valp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="⭐️2-3-信号-signal"><a href="#⭐️2-3-信号-signal" class="header-anchor">#</a> ⭐️2.3.信号（Signal）</h4> <blockquote><p>(开销最小)</p></blockquote> <ul><li>《Unix环境高级编程》中第10章</li></ul> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;signal.h&gt;</span>	<span class="token comment">//需要include这个</span></span>
 <span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">sighandler_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">sighandler_t</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token class-name">sighandler_t</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="⭐️2-4-消息队列-message-queue-mq"><a href="#⭐️2-4-消息队列-message-queue-mq" class="header-anchor">#</a> ⭐️2.4.消息队列（Message Queue，MQ）</h4> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span> <span class="token expression"># 消息队列相关函数及数据结构头文件</span></span>


<span class="token keyword">int</span> <span class="token function">msgctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msqid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span># 控制消息队列函数
<span class="token keyword">int</span> <span class="token function">msgget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> msgflg<span class="token punctuation">)</span><span class="token punctuation">;</span> # 创建消息队列，key值唯一标识该消息队列
<span class="token keyword">int</span> <span class="token function">msgrcv</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>msg_ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> msg_sz<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">int</span> msgtype<span class="token punctuation">,</span> <span class="token keyword">int</span> msgflg<span class="token punctuation">)</span><span class="token punctuation">;</span># 接收消息
<span class="token keyword">int</span> <span class="token function">msgsnd</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>msg_ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> msg_sz<span class="token punctuation">,</span> <span class="token keyword">int</span> msgflg<span class="token punctuation">)</span><span class="token punctuation">;</span># 发送消息
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="⭐️2-5-共享内存-shared-memory"><a href="#⭐️2-5-共享内存-shared-memory" class="header-anchor">#</a> ⭐️2.5.共享内存（Shared Memory）</h4> <ul><li><p>相对管道，可以在<strong>没有血缘关系</strong>的进程之间，完成数据传递。</p></li> <li><p>共享内存有两种实现方式：1、内存映射 2、共享内存机制</p></li></ul> <blockquote><p>1、内存映射</p></blockquote> <ul><li>内存映射<code>memory map</code>机制使进程之间通过映射同一个普通文件实现共享内存，通过<code>mmap()</code>系统调用实现。</li> <li>普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read/write等文件操作函数。</li></ul> <blockquote><p>2、UNIX System V共享内存机制</p></blockquote> <ul><li>IPC的共享内存指的是把所有的共享数据放在共享内存区域（IPC shared memory region），任何想要访问该数据的进程都必须在本进程的地址空间新增一块内存区域，用来映射存放共享数据的物理内存页面。</li> <li>和前面的mmap系统调用通过映射一个普通文件实现共享内存不同，<code>UNIX system V</code>共享内存是通过映射特殊文件系统shm中的文件实现进程间的共享内存通信。</li></ul> <blockquote><p>参考资料：<a href="https://www.cnblogs.com/LUO77/p/5816326.html" target="_blank" rel="noopener noreferrer">进程间通信的方式——信号、管道、消息队列、共享内存<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h4 id="⭐️2-6-套接字-socket"><a href="#⭐️2-6-套接字-socket" class="header-anchor">#</a> ⭐️2.6.套接字（Socket）</h4> <ul><li>本地套接字，相较于前3种，难度最大，但是稳定性最好</li></ul> <h4 id="⭐️2-7-比如c语言中-新建文件『已经被弃用』"><a href="#⭐️2-7-比如c语言中-新建文件『已经被弃用』" class="header-anchor">#</a> ⭐️2.7.比如C语言中，新建文件『已经被弃用』</h4> <h2 id="线程同步技术『4大天王』"><a href="#线程同步技术『4大天王』" class="header-anchor">#</a> 线程同步技术『4大天王』</h2> <img src="/assets/img/线程同步.3130570c.png"> <p>inux下的线程创建、等待、获取线程 id</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span>pthread_t <span class="token operator">*</span>thread<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_attr_t <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
pthread_t <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>保证1点：线程同步</li> <li>Tips：线程由于，已经共享内存空间了，所以，没有必要『数据交换』，也就不需要。</li></ul> <h4 id="_1-锁机制-包括下面4种-lock"><a href="#_1-锁机制-包括下面4种-lock" class="header-anchor">#</a> 🔐1.锁机制（包括下面4种）Lock</h4> <ul><li>🔐互斥量/锁（mutex）/互斥体</li> <li>互斥锁是为实现保护共享资源而提出一种锁机制。采用互斥锁保护临界区，防止竞争条件出现。当某个线程无法获取互斥锁时，该线程会被挂起，当其他线程释放互斥锁后，操作系统会唤醒被挂起在这个锁上的线程，让其运行。</li> <li>场景：
<ul><li>1、解决『线程安全』问题，一次只能一个线程访问被保护的资源。</li> <li>2、被保护资源需要『睡眠』，那么可以使用互斥锁</li></ul></li> <li>互斥锁的优化</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>- 在Linux下互斥锁的实现是通过『futex』这个基础组件。
- 互斥锁加锁解锁开销很大，需要从用户态切换到内核态，上下文切换以及涉及缓存的更新等等。
通常很多同步操作发生的时候并没有竞争的产生，此时上述开销就没有必要。
考虑到这个因素，futex通过用户空间的共享内存以及原子操作，在共享的资源不存在竞争的时候，不会进行系统调用而是只有当竞争出现的情况下再进行系统调用陷入内核。
进程或者线程在没有竞争的情况下可以立刻获取锁。
具体来说，futex的优化方式如下：
futex将同步过程分为两个部分，一部分由内核完成，一部分由用户态完成；如果同步时没有竞争发生，那么完全在用户态处理；否则，进入内核态进行处理。
『减少系统调用的次数，来提高系统的性能是一种合理的优化方式。』
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span><span class="token comment">//需要include的</span></span>
    <span class="token keyword">int</span> <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_mutexattr_t <span class="token operator">*</span>mutexattr<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>  

    <span class="token keyword">int</span> <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> <span class="token function">pthread_mutex_trylock</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>🔐读写锁（reader-writer lock）</li></ul> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span><span class="token comment">//需要include的</span></span>

<span class="token keyword">int</span> <span class="token function">pthread_rwlock_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>restrict rwlock<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">pthread_rwlockattr_t</span> <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_destroy</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">pthread_rwlock_rdlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_tryrdlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">pthread_rwlock_wrlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_trywrlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">pthread_rwlock_unlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>


——————————————————下面是过时的——————————————————
<span class="token comment">//这两个函数在Linux和Mac的man文档里都没有，新版的pthread.h里面也没有，旧版的能找到</span>
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_timedrdlock_np</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>deltatime<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> <span class="token function">pthread_rwlock_timedwrlock_np</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>rwlock<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>deltatime<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ul><li>🔐自旋锁（spin lock）</li> <li>自旋锁也是为实现保护共享资源而提出一种锁机制。</li> <li>自旋锁不会引起调用线程阻塞，如果自旋锁已经被别的线程持有，调用线程就一直循环检测是否该自旋锁已经被释放。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">pthread_spin_init</span> <span class="token punctuation">(</span>__pthread_spinlock_t <span class="token operator">*</span>__lock<span class="token punctuation">,</span> <span class="token keyword">int</span> __pshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_spin_destroy</span> <span class="token punctuation">(</span>__pthread_spinlock_t <span class="token operator">*</span>__lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_spin_lock</span> <span class="token punctuation">(</span>__pthread_spinlock_t <span class="token operator">*</span>__lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_spin_trylock</span> <span class="token punctuation">(</span>__pthread_spinlock_t <span class="token operator">*</span>__lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_spin_unlock</span> <span class="token punctuation">(</span>__pthread_spinlock_t <span class="token operator">*</span>__lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>⭐️<strong>条件变量</strong>（condition）</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span><span class="token comment">//需要include的</span></span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_condattr_t <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span> pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_timedwait</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span> pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>restrict abstime<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_broadcast</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="⭐️2-信号量机制-semaphore"><a href="#⭐️2-信号量机制-semaphore" class="header-anchor">#</a> ⭐️2.信号量机制（Semaphore）</h4> <ul><li>无名线程信号量</li> <li>命名线程信号量</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span><span class="token comment">//需要include这个</span></span>

<span class="token keyword">int</span> <span class="token function">sem_init</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sem_destroy</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sem_wait</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//（相当于加锁，表示--）</span>
<span class="token keyword">int</span> <span class="token function">sem_post</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//（相当于解锁，表示++）</span>
<span class="token keyword">int</span> <span class="token function">sem_getvalue</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>valp<span class="token punctuation">)</span><span class="token punctuation">;</span>

sem_trywait函数
sem_timedwait函数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="⭐️3-信号机制-signal"><a href="#⭐️3-信号机制-signal" class="header-anchor">#</a> ⭐️3.信号机制（Signal）</h4> <ul><li>《Unix环境高级编程》中第10章</li></ul> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;signal.h&gt;</span>	<span class="token comment">//需要include这个</span></span>

<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">sighandler_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">sighandler_t</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token class-name">sighandler_t</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="⭐️4-屏障-barrier"><a href="#⭐️4-屏障-barrier" class="header-anchor">#</a> ⭐️4.屏障（barrier）</h4> <blockquote><p>参考：<a href="https://blog.nowcoder.net/n/e26967a0bfa44ffb9836c0713412d4a7" target="_blank" rel="noopener noreferrer">Linux C/C++ 后台开发实习生技能要求<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="程序员的自我修养-编码链接和库分类"><a href="#程序员的自我修养-编码链接和库分类" class="header-anchor">#</a> 程序员的自我修养，编码链接和库分类</h2> <ul><li><p>下面的说法来自《程序员的自我修养，编码链接和库》，感觉分类不正确</p></li> <li><p>同步的各种锁：</p></li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>（1）信号量
（严格程度：低）二元信号量（Binary Semaphore）是最简单的一种锁，它只有两种状态:占用与非占用。
它适合只能被唯一个线程独占访问的资源。当二元信号量处于非占用状态时，第一个试图获取该二元信号量的线程会获得该锁，并将二元信号量置为占用状态，此后其他的所有试图获取该二元信号量的线程将会等待，直到该锁被释放。
- 对于允许多个线程并发访问的资源，&lt;b&gt;多元信号量简称信号量(Semaphore)&lt;/b&gt;,它是一个很好的选择。一个初始值为N的信号量允许N个线程并发访问。线程访问资源的时候首先获取信号量，进行如下操作:
- 将信号量的值减1。
- 如果信号量的值小于0，则进入等待状态，否则继续执行。
- 访问完资源之后，线程释放信号量，进行如下操作:
- 将信号量的值加1。
- 如果信号量的值小于1,唤醒-一个等待中的线程。


（严格程度：中）互斥量（Mutex）和二元信号量很类似，资源仅同时允许一个线程访问，但和信号量不同的是:
1）信号量在整个系统可以被任意线程获取并释放，也就是说，同一个信号量可以被系统中的一个线程获取之后的&lt;font style=&quot;background: yellow&quot;&gt;另一个线程&lt;/font&gt;释放。
2）互斥量则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁，其他线程越俎代庖去释放互斥量是无效的。



（严格程度：高）临界区（Critical Section）是比互斥量更加严格的同步手段。
在术语中，把临界区的锁的获取称为进入临界区,而把锁的程放称为离开临界区。
临界区和互斥量与信号量的区别在于:
1）&lt;b&gt;互斥量和信号量&lt;/b&gt;在系统的&lt;font style=&quot;background: yellow&quot;&gt;&lt;b&gt;任何进程&lt;/b&gt;&lt;/font&gt;里都是可见的，也就是说，一个进程创建了一个互斥量或信号量,另一个进程试图去获取该锁是合法的。
2）&lt;b&gt;临界区&lt;/b&gt;的作用范围&lt;font style=&quot;background: yellow&quot;&gt;&lt;b&gt;仅限于本进程&lt;/b&gt;&lt;/font&gt;，其他的进程无法获取该锁。除此之外，临界区具有和互斥量相同的性质。




（2）读写锁（Read-Write Lock）
- 由来：对于一段数据，多个线程同时读取总是没有问题的，但假设操作都不是原子型，只要有任何一个线程试图对这个数据进行修改，就必须使用同步手段来避免出错。如果我们使用上述信号量、互斥量或临界区中的任何一种来进行同步，尽管可以保证程序正确，但&lt;b&gt;对于读取频繁，而仅仅偶尔写入的情况&lt;/b&gt;，会显得非常低效。
- 读写锁(Read-Write Lock)致力于一种更加特定的场合的同步:&lt;b&gt;读取频繁，偶尔写入的情况&lt;/b&gt;
- 读写锁可以避免这个问题。对于同一个锁，读写锁有两种获取方式，&lt;b&gt;共享的(Shared)&lt;/b&gt;或&lt;b&gt;独占(Exclusive)&lt;/b&gt;。
- 当锁处于自由的状态时，试图以任何一种方式获取锁都能成功，并将锁置于对应的状态。
- 如果锁处于共享状态，其他线程以共享的方式获取锁仍然会成功，此时这个锁分配给了多个线程。然而，如果其他线程试图以独身的方式获取已经处于共享状态的锁，那么它将必须等待锁被所有的线程释放。
- 相应地，处于独占状态的锁将阻止任何其他线程获取该锁，不论它们试图以哪种方式获取。


（3）条件变量（Condition Variable） 作为一种同步手段，作用类似于一个栅栏。
- 对于条件变量，线程可以有两种操作，首先线程可以等待条件变量，一个条件变量可以被多个线程等待。
- 其次，线程可以唤醒条件变量,此时某个或所有等待此条件变量的线程都会被唤醒并继续支持。也就是说，使用条件变量可以让许多线程-起等待某个事件的发生，当事件发生时(条件变量被唤醒)，所有的线程可以一起恢复执行。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><h3 id="进程-线程-协程区别"><a href="#进程-线程-协程区别" class="header-anchor">#</a> 进程-线程-协程区别</h3> <h4 id="协程"><a href="#协程" class="header-anchor">#</a> 协程</h4> <ul><li>又称微线程，纤程。英文名<strong>Coroutine</strong>。</li></ul> <p>协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。</p> <ul><li><p>参考资料：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017968846697824" target="_blank" rel="noopener noreferrer">https://www.liaoxuefeng.com/wiki/1016959663602400/1017968846697824<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>维基百科：<a href="https://zh.m.wikipedia.org/zh-hans/%E5%8D%8F%E7%A8%8B" target="_blank" rel="noopener noreferrer">https://zh.m.wikipedia.org/zh-hans/%E5%8D%8F%E7%A8%8B<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul> <h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="header-anchor">#</a> 什么是上下文切换？</h2> <ul><li>定义：<strong>上下文切换</strong>(英语：context switch)，又称<strong>环境切换</strong>，电脑术语，是一个<strong>存储</strong>和<strong>重建</strong>CPU的<strong>状态</strong> (<strong>内文</strong>)，因此令多个进程(process)可以分享单一CPU资源的计算过程。要切换CPU上的进程时，必需先行存储目前进程的状态，再将欲运行的进程之状态读回CPU中。</li> <li>开销：上下文切换通常是『<strong>计算密集型</strong>』的，『<strong>操作系统中的许多设计都是针对上下文切换的优化</strong>』。在进程间切换需要消耗一定的时间进行相关的管理工作——包括寄存器和内存映射的保存与读取、更新各种内部的表等等。处理器或者操作系统不同，上下文切换时所涉及的内容也不尽相同。比如在Linux内核中，上下文切换需要涉及寄存器、栈指针、程序计数器的切换，但和地址空间的切换无关（虽然进程在进行上下文切换时也需要做地址空间的切换）[2][3]。用户态线程之间也会发生类似的上下文切换，但这样的切换非常轻量。</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>『CPU 寄存器』和『程序计数器』就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，必须的依赖环境。

CPU 寄存器是 CPU 内置的容量小、但速度极快的内存。『这是个比方，不是真实的』
程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>根据 Tsuna 的测试报告，每次上下文切换都需要『<strong>几十ns到数us</strong>』的 CPU 时间。这个时间还是相当可观的，特别是在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。这也正是导致平均负载升高的一个重要因素。</li> <li>另外，我们知道， Linux 通过 <strong>TLB（Translation Lookaside Buffer）<strong>来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，T</strong>LB 也需要刷新，内存的访问也会随之变慢『因为命中的原因』</strong>。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</li></ul> <blockquote><p>维基百科：<a href="https://zh.wikipedia.org/wiki/%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BA%A4%E6%8F%9B" target="_blank" rel="noopener noreferrer">上下文切换<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>知乎：<a href="https://zhuanlan.zhihu.com/p/52845869" target="_blank" rel="noopener noreferrer">上下文切换<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="什么是tlb"><a href="#什么是tlb" class="header-anchor">#</a> 什么是TLB？</h2> <ul><li><p>TLB（Translation Lookaside Buffer，<strong>转译后备缓冲器</strong>/页表缓存）</p></li> <li><p>在中国大陆被翻译为<strong>页表缓存</strong>、<strong>转址旁路缓存</strong>，为<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%A4%AE%E8%99%95%E7%90%86%E5%99%A8" target="_blank" rel="noopener noreferrer">CPU<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的一种缓存，由<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83" target="_blank" rel="noopener noreferrer">存储器管理单元<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>用于改进<a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E4%BD%8D%E5%9D%80" target="_blank" rel="noopener noreferrer">虚拟地址<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>到物理地址的转译速度</p></li> <li><p>『进程』切换期间，TLB会被刷新，从而使内存访问在一段时间内变得更加昂贵。</p></li></ul> <blockquote><p>知乎：<a href="https://zhuanlan.zhihu.com/p/108425561" target="_blank" rel="noopener noreferrer">TLB原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>维基百科：<a href="https://zh.wikipedia.org/wiki/%E8%BD%89%E8%AD%AF%E5%BE%8C%E5%82%99%E7%B7%A9%E8%A1%9D%E5%8D%80" target="_blank" rel="noopener noreferrer">TLB原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="大小端之争"><a href="#大小端之争" class="header-anchor">#</a> 大小端之争</h2> <p>大小端（BigEndianLittleEndian）</p> <h3 id="大端和小端存储-引子"><a href="#大端和小端存储-引子" class="header-anchor">#</a> 大端和小端存储-引子</h3> <ul><li>《格列夫游记》一书中讲到，格列佛在小人国中，遇到了“<a href="https://blog.csdn.net/linghaidong/article/details/50242233" target="_blank" rel="noopener noreferrer">大小端<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的事情”。在计算机界，也有一个类似的大端小端之争，随着计算机的发展，历史告诉我们，这些都是合理的，但是要在计算机间合理通信或者理解计算机底层的时候，你自己记得转换就好了。</li></ul> <h3 id="_2-1-概念"><a href="#_2-1-概念" class="header-anchor">#</a> 2.1.概念</h3> <p>大端：指低字节存储在高地址。
小端：指低字节存储在低地址。</p> <p><strong>记忆方法：</strong></p> <p><font style="background:yellow;">小端说：我就是个低低（弟弟）</font></p> <p>下图描述了——大端存储（低字节存储在内存高地址了）：
<img src="https://cdn.jsdelivr.net/gh/HACV/picture/img/1.png" alt="1"></p> <p>下图描述了——小端存储（低字节存储在内存低地址了）：：<img src="https://cdn.jsdelivr.net/gh/HACV/picture/img/2.png" alt="2"></p> <h3 id="_2-2-具体的-大端法和小端法的应用"><a href="#_2-2-具体的-大端法和小端法的应用" class="header-anchor">#</a> 2.2.具体的，大端法和小端法的应用</h3> <p>有的产品用的大端法，有的产品则是小端法。
PS:<strong>这个大端和小端并没有严格按照企业界限来区分</strong>，因为有的企业，它在之前采用的处理器，可能是大端，但是后面的产品中改变了采用的处理器，可能就采用小端法了。
前沿：许多比较新的微处理器使用双端法，也就是说可以把它们配置成作为大端或者小端的机器运行。</p> <h3 id="_2-3-大端法和小端法导致的问题"><a href="#_2-3-大端法和小端法导致的问题" class="header-anchor">#</a> 2.3.大端法和小端法导致的问题：</h3> <ul><li>1）网络应用程序数据传输</li></ul> <p>在采用不同大小端存储的机器之间通过网络传送二进制数据时候，会导致采用不同大小端存储方式的数据的字节变成反序。
网络字节序
网络上传输的数据都是字节流,对于一个多字节数值，在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题;
UDP/TCP/IP协议规定:
把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;</p> <p>而在发送端发送数据时，发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);
由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的;所以说,网络字节序是大端字节序;</p> <p>比如,我们经过网络发送整型数值0x12345678时,在80x86平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数将其转换成大端法存放的数值;</p> <p>常见CPU的宇节序
大端（big Endian）: PowerPC、IBM、 Sun
小端（little Endian）:x86、DEC
<strong>ARM既可以工作在大端模式,也可以工作在小端模式</strong></p> <ul><li>2）反汇编的时候</li></ul> <p>（—未完待续）</p> <h3 id="_2-4-如何判别大端和小端"><a href="#_2-4-如何判别大端和小端" class="header-anchor">#</a> 2.4.如何判别大端和小端</h3> <p>1）我们可以根据C语言中的，联合体来判断，该系统是大端还是小端。
因为，联合体变量总是从低地址存储。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">union</span> test
	<span class="token punctuation">{</span>
		<span class="token keyword">int</span> a<span class="token punctuation">;</span>
		<span class="token keyword">char</span> c<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>demo<span class="token punctuation">;</span>
	
	demo<span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">0x01ffff03</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>demo<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0x03</span><span class="token operator">==</span>demo<span class="token punctuation">.</span>c<span class="token punctuation">)</span> 
	<span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;这个机器是小端存储！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0x00</span><span class="token operator">==</span>demo<span class="token punctuation">.</span>c<span class="token punctuation">)</span> 
	<span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;这个机器是大端存储！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;无法判断机器类型！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>显然，
要是小端存储，那么（低字节）0x03在低地址，
要是大端存储，那么（高字节）0x00在低地址。
所以，打印出3就是小端存储。打印出0那就是大端存储。
笔者的电脑是采用的intel的X86CPU，是小端存储。</p> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>输出是3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_3-概念辨析"><a href="#_3-概念辨析" class="header-anchor">#</a> 3.概念辨析</h2> <h3 id="_3-1-终端"><a href="#_3-1-终端" class="header-anchor">#</a> 3.1.终端</h3> <p>计算机中的终端：是所有<strong>输入输出</strong>设备的『总称』。</p> <ul><li>键盘，鼠标，摄像头</li> <li>屏幕，打印机</li></ul> <p>虚拟机那个黑框框。是终端，是『<strong>虚拟终端</strong>』，不是真实存在的<br>
输入可以在这，输出也在这出，又输入有输出</p> <ul><li>终端在我们系统的级别分，大致如下：</li> <li>1、Alt + Ctrl + F1、F2、F3、F4、F5、F6	<strong>字符终端</strong>   pts (pseudo terminal slave) 指伪终端。</li> <li>2、Alt + F7		<strong>图形终端</strong></li> <li>3、ssh、telnet...		<strong>网络终端</strong>（比如用Xshell啥的，通过网络传输到主机上）</li></ul> <h3 id="_3-2-僵尸进程-zombie"><a href="#_3-2-僵尸进程-zombie" class="header-anchor">#</a> 3.2.僵尸进程（Zombie）</h3> <ul><li>参考<a href="https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener noreferrer">wiki<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>僵尸进程（僵死进程）: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。

注意:僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止。

思考！用什么办法可清除掉僵尸进程呢？
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><p><strong>僵尸进程</strong>: （死亡的子进程，但不回收）进程终止，父进程尚未回收，子进程残留资源（PCB）存放于<strong>内核</strong>中，变成僵尸（Zombie）进程
（父进程有义务将子进程回收。如果子进程死完之后，要是父进程不给子进程收尸，子进程就成僵尸了）</p></li> <li><p>变成僵尸进程的危害?</p></li> <li><div class="language-txt line-numbers-mode"><pre class="language-txt"><code>1、正常进程结束之后，0-3G的进程（用户空间）地址空间，都会被释放。子进程整个0-3G的地址空间都被释放。
2、但是，唯独PCB残留到内核当中，残留的目的是，为了让父进程给他报仇。因为，子进程死了，不留下点什么痕迹，父进程怎么知道你子进程是怎么死的？？他杀，还是自杀『自行结束』
3、父进程可以通过PCB来获取它的死亡状态，如果你是自杀，还算了
4、如果你是他杀，父进程需要采取措施，给你报仇？？？PCB存在的意义是为了，方便父进程收尸，如果父进程比较粗心大意，不管，那么那个PCB就一直存在内核当中。 这样会造成溢出，所以编程的时候，记得要回收僵尸进程
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ul> <h3 id="_3-3-孤儿进程"><a href="#_3-3-孤儿进程" class="header-anchor">#</a> 3.3.孤儿进程</h3> <ul><li><strong>孤儿进程</strong>: <strong>父进程先于子进程结束</strong>，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。（操作系统让孤儿进程进入“进程孤儿院”（不对吧）。也就是被init进程收养）（有人叫init进程叫进程孤儿院）</li></ul> <h3 id="_3-4-init-进程"><a href="#_3-4-init-进程" class="header-anchor">#</a> 3.4.init 进程</h3> <ul><li>init进程：<strong>系统初始化进程</strong>，是所有用户进程和非调度进程的祖先</li> <li>init进程是『1号进程』，所有进程原先的祖先</li> <li>0号进程是『不会』在操作系统中实际存在的</li></ul> <h3 id="_2-5-内核"><a href="#_2-5-内核" class="header-anchor">#</a> 2.5.内核</h3> <h3 id="_2-6-进程组-作业"><a href="#_2-6-进程组-作业" class="header-anchor">#</a> 2.6.进程组（作业）</h3> <p>一个作业通常包括程序、数据和『操作说明书』3部分。
每一个进程由PCB、程序和数据集合组成。这说明程序是进程的一部分，是进程的实体。
因此，一个作业可划分为若干个进程来完成，而每一个进程有其实体————程序和数据集合。</p> <p>1、『<strong>有的书上叫“作业”</strong>，重要！』只不过<font style="background:yellow;">在不同操作系统下，叫法不同而已。</font><br>
2、作业这个概念，早先的时候，来源于BSD操作系统</p> <ul><li>BSD于1980年前后向Unix中增加的一个新特性。</li> <li>代表一个或多个进程的集合。<strong>每个进程都属于一个进程组</strong>。</li></ul> <p>可以用kill，进行进程组ID取负号的方式，来杀死整个组内的进程。</p> <ul><li><strong>组长进程</strong>可以创建一个进程组</li></ul> <h3 id="_2-7-会话-session"><a href="#_2-7-会话-session" class="header-anchor">#</a> 2.7.会话（session）</h3> <ul><li>会话（session）：把<font style="background:yellow;">一组『<strong>进程组</strong>』再重新编号</font>，就变成了会话。（圈圈圆圆圈圈，禁止套娃2333）</li></ul> <p>创建一个会话需要注意以下6点<strong>注意事项</strong>：</p> <ol><li>调用进程<strong>不能</strong>是进程组组长，该进程变成新会话<strong>首进程</strong>(session Leader)（简称，“会长”，滑稽）</li> <li>该进程成为一个新进程组的组长进程。</li> <li>需有root权限(ubuntu不需要)</li> <li>新会话丢弃原有的控制终端，该会话没有控制终端（只在后台执行）</li> <li>该调用进程是组长进程，则出错返回</li> <li>建立新会话时，先调用fork, 父进程终止，子进程调用setsid</li></ol> <p>Q：要<strong>会话ID</strong>干啥？</p> <p>A：主要是为了，守护进程用</p> <h3 id="_2-8-守护进程-daemon-『后台开发核心』"><a href="#_2-8-守护进程-daemon-『后台开发核心』" class="header-anchor">#</a> 2.8.守护进程（daemon）『后台开发核心』</h3> <ul><li><strong>守护进程（daemon进程/精灵进程）</strong>：“系统进程”与终端无关，不由用户启动，通常也叫做守护进程，是Linux/Unix『<strong>内核</strong>』专用的特殊进程，是Linux中的<strong>后台服务进程</strong>，通常独立于『控制终端』并且周<strong>期性地</strong>执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。</li> <li>守护进程，说白了，就是一个后台系统服务器。</li></ul> <blockquote><ul><li>比如，Linux中的vsftpd，搭建ftp服务器的，安装+启动，httpd，sshd,xinetd</li></ul></blockquote> <ul><li>FAQ：只要是后台的，有没有终端？？没有！</li> <li><b>注意：</b>守护进程不受用户登录、注销的影响，当然，机器重启就另说了,但是厉害的守护进程，比如vsftpd和mysql等，你关机再开机，它也跟着启动</li></ul> <h4 id="创建守护进程"><a href="#创建守护进程" class="header-anchor">#</a> 创建守护进程</h4> <ul><li><p>创建守护进程，最关键的一步是调用setsid函数<strong>创建一个新的会话（Session）</strong>，并成为Session Leader。</p></li> <li><p>当然，你也可以写这样的守护进程，比</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">vim</span> .bashrc
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>这是bash解析器的配置文件，每次加载bash的时候都是按照这个去走。
显然设置这个，就可以让完成那样的守护进程。启动放这个里面。</li> <li>为什么，要用会话呢？</li> <li><font style="background:yellow;">因为守护进程都不需要控制终端</font></li></ul></li></ul> <h4 id="_2-创建守护进程模型"><a href="#_2-创建守护进程模型" class="header-anchor">#</a> 2.创建守护进程模型</h4> <ol><li>创建子进程，父进程退出
所有工作在子进程中进行形式上脱离了控制终端</li> <li>在子进程中创建新会话（主要，为了丢弃终端）
　　	setsid()函数
　　	使子进程完全独立出来，脱离控制</li> <li>改变当前目录为根目录
　　	chdir()函数
　　	防止占用可卸载的文件系统（比如，U盘）
　　	也可以换成其它路径</li> <li>重设文件权限掩码
　　	umask()函数
　　	防止继承的文件创建屏蔽字拒绝某些权限
　　	增加守护进程灵活性</li> <li>关闭文件描述符
　　	继承的打开文件不会用到，浪费系统资源，无法卸载</li> <li>开始执行守护进程核心工作（守护进程主逻辑）</li> <li>守护进程退出处理程序模型（几乎不会用，毕竟守护进程一般不退出）</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.1377ab92.js" defer></script><script src="/assets/js/2.e041faba.js" defer></script><script src="/assets/js/7.7fb14080.js" defer></script>
  </body>
</html>
