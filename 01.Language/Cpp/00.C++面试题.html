<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++面试题 | whoway</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/images/photo.jpg">
    <link rel="manifest" href="/images/photo.jpg">
    <link rel="apple-touch-icon" href="/images/photo.jpg">
    <meta name="description" content="Personal Blog Website">
    <meta http-quiv="pragma" cotent="no-cache">
    <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
    <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.e8e4f3a3.css" as="style"><link rel="preload" href="/assets/js/app.f308a922.js" as="script"><link rel="preload" href="/assets/js/2.443c6f9e.js" as="script"><link rel="preload" href="/assets/js/46.08940884.js" as="script"><link rel="prefetch" href="/assets/js/10.564ba24d.js"><link rel="prefetch" href="/assets/js/100.2ebdba45.js"><link rel="prefetch" href="/assets/js/101.6a7d2a75.js"><link rel="prefetch" href="/assets/js/102.75571ccf.js"><link rel="prefetch" href="/assets/js/103.27f85c5f.js"><link rel="prefetch" href="/assets/js/104.b49f3562.js"><link rel="prefetch" href="/assets/js/105.55722df3.js"><link rel="prefetch" href="/assets/js/106.4febf552.js"><link rel="prefetch" href="/assets/js/107.466f75db.js"><link rel="prefetch" href="/assets/js/108.7dce91c1.js"><link rel="prefetch" href="/assets/js/109.7653e57f.js"><link rel="prefetch" href="/assets/js/11.d3f4ebcf.js"><link rel="prefetch" href="/assets/js/110.8d237041.js"><link rel="prefetch" href="/assets/js/111.aedc587c.js"><link rel="prefetch" href="/assets/js/112.77a8d2e8.js"><link rel="prefetch" href="/assets/js/113.be14b056.js"><link rel="prefetch" href="/assets/js/114.cdc44fe7.js"><link rel="prefetch" href="/assets/js/115.72fb48af.js"><link rel="prefetch" href="/assets/js/116.e2543774.js"><link rel="prefetch" href="/assets/js/117.f7246ebf.js"><link rel="prefetch" href="/assets/js/118.c76f8bf6.js"><link rel="prefetch" href="/assets/js/119.4d3877c5.js"><link rel="prefetch" href="/assets/js/12.4349f2c1.js"><link rel="prefetch" href="/assets/js/120.412903b7.js"><link rel="prefetch" href="/assets/js/121.b59bb932.js"><link rel="prefetch" href="/assets/js/122.0cadc3f3.js"><link rel="prefetch" href="/assets/js/123.f59b17fb.js"><link rel="prefetch" href="/assets/js/124.7c33e28e.js"><link rel="prefetch" href="/assets/js/125.7b635cc0.js"><link rel="prefetch" href="/assets/js/126.9124f7c9.js"><link rel="prefetch" href="/assets/js/127.7273bd86.js"><link rel="prefetch" href="/assets/js/128.40b9f563.js"><link rel="prefetch" href="/assets/js/129.d74f2f9d.js"><link rel="prefetch" href="/assets/js/13.25838ded.js"><link rel="prefetch" href="/assets/js/130.a7b095a0.js"><link rel="prefetch" href="/assets/js/131.196dae92.js"><link rel="prefetch" href="/assets/js/132.93637c1e.js"><link rel="prefetch" href="/assets/js/133.b74cb333.js"><link rel="prefetch" href="/assets/js/134.5f84a5c3.js"><link rel="prefetch" href="/assets/js/135.a2b89c02.js"><link rel="prefetch" href="/assets/js/136.490d1dc8.js"><link rel="prefetch" href="/assets/js/137.caaeba3b.js"><link rel="prefetch" href="/assets/js/138.495fb7bf.js"><link rel="prefetch" href="/assets/js/139.4c23c928.js"><link rel="prefetch" href="/assets/js/14.492747a7.js"><link rel="prefetch" href="/assets/js/140.fec31f87.js"><link rel="prefetch" href="/assets/js/141.9d2bf7ad.js"><link rel="prefetch" href="/assets/js/142.5fb011b8.js"><link rel="prefetch" href="/assets/js/143.506685f5.js"><link rel="prefetch" href="/assets/js/144.386b0e30.js"><link rel="prefetch" href="/assets/js/145.13af47f8.js"><link rel="prefetch" href="/assets/js/146.3bdd6c2c.js"><link rel="prefetch" href="/assets/js/147.ae7fe496.js"><link rel="prefetch" href="/assets/js/148.f656fdd4.js"><link rel="prefetch" href="/assets/js/149.b619e38b.js"><link rel="prefetch" href="/assets/js/15.eba253f1.js"><link rel="prefetch" href="/assets/js/150.210ce998.js"><link rel="prefetch" href="/assets/js/151.b1096207.js"><link rel="prefetch" href="/assets/js/152.79f51c91.js"><link rel="prefetch" href="/assets/js/153.7cfe728e.js"><link rel="prefetch" href="/assets/js/154.efd3f543.js"><link rel="prefetch" href="/assets/js/155.d43efb82.js"><link rel="prefetch" href="/assets/js/156.213a5169.js"><link rel="prefetch" href="/assets/js/157.182c69cf.js"><link rel="prefetch" href="/assets/js/158.bc727a18.js"><link rel="prefetch" href="/assets/js/159.572b980c.js"><link rel="prefetch" href="/assets/js/16.e111626a.js"><link rel="prefetch" href="/assets/js/160.993819c2.js"><link rel="prefetch" href="/assets/js/161.07d4d625.js"><link rel="prefetch" href="/assets/js/162.5ce5fa85.js"><link rel="prefetch" href="/assets/js/163.1378e5b9.js"><link rel="prefetch" href="/assets/js/164.9a5b3f9a.js"><link rel="prefetch" href="/assets/js/165.8a9e1da5.js"><link rel="prefetch" href="/assets/js/166.e05db19f.js"><link rel="prefetch" href="/assets/js/167.3af66d8f.js"><link rel="prefetch" href="/assets/js/168.a1259112.js"><link rel="prefetch" href="/assets/js/169.4771d70b.js"><link rel="prefetch" href="/assets/js/17.6c788e13.js"><link rel="prefetch" href="/assets/js/170.0aeac2d1.js"><link rel="prefetch" href="/assets/js/171.44238cf3.js"><link rel="prefetch" href="/assets/js/172.3f4288e4.js"><link rel="prefetch" href="/assets/js/173.ea94c74a.js"><link rel="prefetch" href="/assets/js/174.1569fc98.js"><link rel="prefetch" href="/assets/js/175.a07f45c5.js"><link rel="prefetch" href="/assets/js/176.2fe6724f.js"><link rel="prefetch" href="/assets/js/177.41914e26.js"><link rel="prefetch" href="/assets/js/178.95240fd9.js"><link rel="prefetch" href="/assets/js/179.d0bc7a0d.js"><link rel="prefetch" href="/assets/js/18.873a8359.js"><link rel="prefetch" href="/assets/js/180.10075c4d.js"><link rel="prefetch" href="/assets/js/181.9eaede62.js"><link rel="prefetch" href="/assets/js/182.7676f139.js"><link rel="prefetch" href="/assets/js/183.3595e596.js"><link rel="prefetch" href="/assets/js/184.45816a20.js"><link rel="prefetch" href="/assets/js/185.85638ebe.js"><link rel="prefetch" href="/assets/js/186.8048c47c.js"><link rel="prefetch" href="/assets/js/187.f4ded7b8.js"><link rel="prefetch" href="/assets/js/188.aa74b133.js"><link rel="prefetch" href="/assets/js/189.df4cf6a8.js"><link rel="prefetch" href="/assets/js/19.ee2c88d0.js"><link rel="prefetch" href="/assets/js/190.fc33c2f2.js"><link rel="prefetch" href="/assets/js/191.ab7b01dc.js"><link rel="prefetch" href="/assets/js/192.6c716179.js"><link rel="prefetch" href="/assets/js/193.bc707571.js"><link rel="prefetch" href="/assets/js/194.70940a4f.js"><link rel="prefetch" href="/assets/js/195.efe9f4d4.js"><link rel="prefetch" href="/assets/js/196.be38ff2d.js"><link rel="prefetch" href="/assets/js/197.02c8e42d.js"><link rel="prefetch" href="/assets/js/198.d669f3cf.js"><link rel="prefetch" href="/assets/js/199.801e2df2.js"><link rel="prefetch" href="/assets/js/20.39da0aac.js"><link rel="prefetch" href="/assets/js/200.02c06a8e.js"><link rel="prefetch" href="/assets/js/201.418b08cf.js"><link rel="prefetch" href="/assets/js/202.23a85a81.js"><link rel="prefetch" href="/assets/js/203.6368e792.js"><link rel="prefetch" href="/assets/js/204.6f8f9a46.js"><link rel="prefetch" href="/assets/js/205.e1265483.js"><link rel="prefetch" href="/assets/js/206.929048d5.js"><link rel="prefetch" href="/assets/js/207.23f1d674.js"><link rel="prefetch" href="/assets/js/208.a57538d2.js"><link rel="prefetch" href="/assets/js/209.b42efd39.js"><link rel="prefetch" href="/assets/js/21.edd943cc.js"><link rel="prefetch" href="/assets/js/210.5aa43e4d.js"><link rel="prefetch" href="/assets/js/211.65a30619.js"><link rel="prefetch" href="/assets/js/212.b75adefb.js"><link rel="prefetch" href="/assets/js/213.6676de29.js"><link rel="prefetch" href="/assets/js/214.f627a213.js"><link rel="prefetch" href="/assets/js/215.3a0da2dc.js"><link rel="prefetch" href="/assets/js/216.2dbed286.js"><link rel="prefetch" href="/assets/js/217.d1fed9c1.js"><link rel="prefetch" href="/assets/js/218.9678edcd.js"><link rel="prefetch" href="/assets/js/219.511884ad.js"><link rel="prefetch" href="/assets/js/22.1101d3a0.js"><link rel="prefetch" href="/assets/js/220.c54bba66.js"><link rel="prefetch" href="/assets/js/221.f194ad98.js"><link rel="prefetch" href="/assets/js/222.9741ec37.js"><link rel="prefetch" href="/assets/js/223.20de3fdc.js"><link rel="prefetch" href="/assets/js/224.ec9a1fc5.js"><link rel="prefetch" href="/assets/js/225.7e441d77.js"><link rel="prefetch" href="/assets/js/226.0847b9a9.js"><link rel="prefetch" href="/assets/js/227.943948a3.js"><link rel="prefetch" href="/assets/js/228.e6fe3a0f.js"><link rel="prefetch" href="/assets/js/229.055cadd9.js"><link rel="prefetch" href="/assets/js/23.1c64ff44.js"><link rel="prefetch" href="/assets/js/230.4c3db158.js"><link rel="prefetch" href="/assets/js/231.7618f505.js"><link rel="prefetch" href="/assets/js/232.27afa1b1.js"><link rel="prefetch" href="/assets/js/233.41a67067.js"><link rel="prefetch" href="/assets/js/234.e17c6ac3.js"><link rel="prefetch" href="/assets/js/24.f57a24cc.js"><link rel="prefetch" href="/assets/js/25.6c1f3e52.js"><link rel="prefetch" href="/assets/js/26.fff5042b.js"><link rel="prefetch" href="/assets/js/27.fb2ac419.js"><link rel="prefetch" href="/assets/js/28.2e15dac9.js"><link rel="prefetch" href="/assets/js/29.9f14ff8d.js"><link rel="prefetch" href="/assets/js/3.aa43f56f.js"><link rel="prefetch" href="/assets/js/30.2ff65a58.js"><link rel="prefetch" href="/assets/js/31.388bee23.js"><link rel="prefetch" href="/assets/js/32.2bdd0898.js"><link rel="prefetch" href="/assets/js/33.92037cd2.js"><link rel="prefetch" href="/assets/js/34.2b9377f8.js"><link rel="prefetch" href="/assets/js/35.e6469324.js"><link rel="prefetch" href="/assets/js/36.20267bfe.js"><link rel="prefetch" href="/assets/js/37.738ddf6b.js"><link rel="prefetch" href="/assets/js/38.6e536ad3.js"><link rel="prefetch" href="/assets/js/39.356955ac.js"><link rel="prefetch" href="/assets/js/4.9e9de9f6.js"><link rel="prefetch" href="/assets/js/40.b210e6fc.js"><link rel="prefetch" href="/assets/js/41.dc08fc34.js"><link rel="prefetch" href="/assets/js/42.71d97baf.js"><link rel="prefetch" href="/assets/js/43.25c6b21a.js"><link rel="prefetch" href="/assets/js/44.18c4ae8f.js"><link rel="prefetch" href="/assets/js/45.4c20a706.js"><link rel="prefetch" href="/assets/js/47.0059baec.js"><link rel="prefetch" href="/assets/js/48.3fb2f49e.js"><link rel="prefetch" href="/assets/js/49.bf896a48.js"><link rel="prefetch" href="/assets/js/5.ec3b3bef.js"><link rel="prefetch" href="/assets/js/50.6c254d4b.js"><link rel="prefetch" href="/assets/js/51.f15ecdc3.js"><link rel="prefetch" href="/assets/js/52.02b61012.js"><link rel="prefetch" href="/assets/js/53.2c15cd80.js"><link rel="prefetch" href="/assets/js/54.7f112769.js"><link rel="prefetch" href="/assets/js/55.34e2f37a.js"><link rel="prefetch" href="/assets/js/56.fe1bb9e6.js"><link rel="prefetch" href="/assets/js/57.205e9911.js"><link rel="prefetch" href="/assets/js/58.9ce60b3f.js"><link rel="prefetch" href="/assets/js/59.8f15a6cc.js"><link rel="prefetch" href="/assets/js/6.a31d63d5.js"><link rel="prefetch" href="/assets/js/60.d7957113.js"><link rel="prefetch" href="/assets/js/61.ef61c216.js"><link rel="prefetch" href="/assets/js/62.87a781f9.js"><link rel="prefetch" href="/assets/js/63.54dd9a1b.js"><link rel="prefetch" href="/assets/js/64.8e57e0b3.js"><link rel="prefetch" href="/assets/js/65.f26ae1aa.js"><link rel="prefetch" href="/assets/js/66.314e62f6.js"><link rel="prefetch" href="/assets/js/67.84bd37fd.js"><link rel="prefetch" href="/assets/js/68.31894d6a.js"><link rel="prefetch" href="/assets/js/69.d05b524b.js"><link rel="prefetch" href="/assets/js/7.5722c9b9.js"><link rel="prefetch" href="/assets/js/70.48eb7200.js"><link rel="prefetch" href="/assets/js/71.4f4b0093.js"><link rel="prefetch" href="/assets/js/72.54d5f4b1.js"><link rel="prefetch" href="/assets/js/73.4a5743f6.js"><link rel="prefetch" href="/assets/js/74.febacc20.js"><link rel="prefetch" href="/assets/js/75.e4ea311c.js"><link rel="prefetch" href="/assets/js/76.bd56aeb5.js"><link rel="prefetch" href="/assets/js/77.afa5d5d0.js"><link rel="prefetch" href="/assets/js/78.556d3a72.js"><link rel="prefetch" href="/assets/js/79.440bb5d8.js"><link rel="prefetch" href="/assets/js/8.43a034a5.js"><link rel="prefetch" href="/assets/js/80.1cb75bfe.js"><link rel="prefetch" href="/assets/js/81.d58331f2.js"><link rel="prefetch" href="/assets/js/82.f595c5af.js"><link rel="prefetch" href="/assets/js/83.df6e8e34.js"><link rel="prefetch" href="/assets/js/84.d8b04a52.js"><link rel="prefetch" href="/assets/js/85.42cca0b9.js"><link rel="prefetch" href="/assets/js/86.929cb693.js"><link rel="prefetch" href="/assets/js/87.187f4b29.js"><link rel="prefetch" href="/assets/js/88.277f0f52.js"><link rel="prefetch" href="/assets/js/89.69f556b0.js"><link rel="prefetch" href="/assets/js/9.9b2f61c2.js"><link rel="prefetch" href="/assets/js/90.6b7ceb51.js"><link rel="prefetch" href="/assets/js/91.35ee6d03.js"><link rel="prefetch" href="/assets/js/92.ffd42f17.js"><link rel="prefetch" href="/assets/js/93.6f13703b.js"><link rel="prefetch" href="/assets/js/94.a13aa616.js"><link rel="prefetch" href="/assets/js/95.d84a1da6.js"><link rel="prefetch" href="/assets/js/96.b9ca323f.js"><link rel="prefetch" href="/assets/js/97.5e7b5df5.js"><link rel="prefetch" href="/assets/js/98.4d93a866.js"><link rel="prefetch" href="/assets/js/99.e6aa9e67.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e8e4f3a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">whoway</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎓Coding" class="dropdown-title"><span class="title">🎓Coding</span> <span class="arrow down"></span></button> <button type="button" aria-label="🎓Coding" class="mobile-dropdown-title"><span class="title">🎓Coding</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/00.Coding/TheBeautyOfProgramming/" class="nav-link">
  🔖编程之美题解
</a></li><li class="dropdown-item"><!----> <a href="/00.Coding/CodeWarehouse/" class="nav-link">
  🔖代码意识流
</a></li><li class="dropdown-item"><!----> <a href="/00.Coding/" class="nav-link">
  🔖面试题题解
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🚀语言" class="dropdown-title"><span class="title">🚀语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="🚀语言" class="mobile-dropdown-title"><span class="title">🚀语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/01.Language/Overview/" class="nav-link">
  🔖概述
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/C/" class="nav-link">
  ⭐️C
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Cpp/" class="nav-link router-link-active">
  🚀C++
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Java/" class="nav-link">
  ☕️Java
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Python/" class="nav-link">
  🧩Python3
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Fortran/" class="nav-link">
  🎲Fortran
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/JavaScript/" class="nav-link">
  🎨JavaScript
</a></li></ul></div></div><div class="nav-item"><a href="/02.Hardware/" class="nav-link">
  ✔️硬件基础
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="⭐️软件基础" class="dropdown-title"><span class="title">⭐️软件基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="⭐️软件基础" class="mobile-dropdown-title"><span class="title">⭐️软件基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/03.Software/01.DataStructureAndAlgorithm/" class="nav-link">
  🐾数据结构和算法
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/02.server/" class="nav-link">
  🎨server
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/03.Database/" class="nav-link">
  🔖数据库
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/04.SE/" class="nav-link">
  ✅软件工程
</a></li></ul></div></div><div class="nav-item"><a href="/04.PerformanceOpt/" class="nav-link">
  🔥性能调优
</a></div><div class="nav-item"><a href="/05.Engineer/" class="nav-link">
  🔖学术/工程
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="⚙️工具" class="dropdown-title"><span class="title">⚙️工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="⚙️工具" class="mobile-dropdown-title"><span class="title">⚙️工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/06.Tools/01.employment/" class="nav-link">
  🔖求职
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/02.efficiency/" class="nav-link">
  🚀效能
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/03.windows/" class="nav-link">
  ⚙️Windows
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/04.design/" class="nav-link">
  🧩设计
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/whoway" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎓Coding" class="dropdown-title"><span class="title">🎓Coding</span> <span class="arrow down"></span></button> <button type="button" aria-label="🎓Coding" class="mobile-dropdown-title"><span class="title">🎓Coding</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/00.Coding/TheBeautyOfProgramming/" class="nav-link">
  🔖编程之美题解
</a></li><li class="dropdown-item"><!----> <a href="/00.Coding/CodeWarehouse/" class="nav-link">
  🔖代码意识流
</a></li><li class="dropdown-item"><!----> <a href="/00.Coding/" class="nav-link">
  🔖面试题题解
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🚀语言" class="dropdown-title"><span class="title">🚀语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="🚀语言" class="mobile-dropdown-title"><span class="title">🚀语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/01.Language/Overview/" class="nav-link">
  🔖概述
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/C/" class="nav-link">
  ⭐️C
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Cpp/" class="nav-link router-link-active">
  🚀C++
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Java/" class="nav-link">
  ☕️Java
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Python/" class="nav-link">
  🧩Python3
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Fortran/" class="nav-link">
  🎲Fortran
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/JavaScript/" class="nav-link">
  🎨JavaScript
</a></li></ul></div></div><div class="nav-item"><a href="/02.Hardware/" class="nav-link">
  ✔️硬件基础
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="⭐️软件基础" class="dropdown-title"><span class="title">⭐️软件基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="⭐️软件基础" class="mobile-dropdown-title"><span class="title">⭐️软件基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/03.Software/01.DataStructureAndAlgorithm/" class="nav-link">
  🐾数据结构和算法
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/02.server/" class="nav-link">
  🎨server
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/03.Database/" class="nav-link">
  🔖数据库
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/04.SE/" class="nav-link">
  ✅软件工程
</a></li></ul></div></div><div class="nav-item"><a href="/04.PerformanceOpt/" class="nav-link">
  🔥性能调优
</a></div><div class="nav-item"><a href="/05.Engineer/" class="nav-link">
  🔖学术/工程
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="⚙️工具" class="dropdown-title"><span class="title">⚙️工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="⚙️工具" class="mobile-dropdown-title"><span class="title">⚙️工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/06.Tools/01.employment/" class="nav-link">
  🔖求职
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/02.efficiency/" class="nav-link">
  🚀效能
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/03.windows/" class="nav-link">
  ⚙️Windows
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/04.design/" class="nav-link">
  🧩设计
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/whoway" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++面试题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#📑-目录" class="sidebar-link">📑 目录</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#✅虚函数" class="sidebar-link">✅虚函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-虚函数表vtbl" class="sidebar-link">1.虚函数表vtbl</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-构造一个「派生类」对象的过程" class="sidebar-link">2.构造一个「派生类」对象的过程</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-1-是先构造父类的「虚表指针」还是先构造父类的「成员」" class="sidebar-link">2.1.是先构造父类的「虚表指针」还是先构造父类的「成员」？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-2-「虚表指针」和「构造函数体」那个先被构造" class="sidebar-link">2.2.「虚表指针」和「构造函数体」那个先被构造？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-c-「运行构造函数」的时候「虚函数表」被构造出来了么" class="sidebar-link">3.c++「运行构造函数」的时候「虚函数表」被构造出来了么？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_4-析构一个「派生类」object的过程" class="sidebar-link">4.析构一个「派生类」object的过程</a></li></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#✅基础" class="sidebar-link">✅基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-vector是线程安全的吗" class="sidebar-link">1.vector是线程安全的吗？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-c-是不是类型安全的呢" class="sidebar-link">2.C++是不是类型安全的呢？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-sizeof只有1个虚析构函数的空类呢" class="sidebar-link">3.sizeof只有1个虚析构函数的空类呢？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_4-构造函数为什么不能是虚函数" class="sidebar-link">4.构造函数为什么不能是虚函数？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_5-为何空类的大小不是零" class="sidebar-link">5.为何空类的大小不是零？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_6-我能从构造函数调用虚函数吗" class="sidebar-link">6.我能从构造函数调用虚函数吗？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_7-内存泄露及解决办法" class="sidebar-link">7.内存泄露及解决办法：</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_8-怎么检测内存泄漏" class="sidebar-link">8.怎么检测内存泄漏？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_9-初始化顺序" class="sidebar-link">9.初始化顺序</a></li></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#✅平常做题错题" class="sidebar-link">✅平常做题错题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-测试" class="sidebar-link">1.测试</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-在-c-语言中-对函数参数默认值描述正确的是" class="sidebar-link">2.在 c++ 语言中，对函数参数默认值描述正确的是？</a></li></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#✅c-输入输出io" class="sidebar-link">✅C++输入输出IO</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-iostream的设计初衷" class="sidebar-link">1.iostream的设计初衷</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-iostream的特点" class="sidebar-link">2.iostream的特点</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#✅c-高阶论题" class="sidebar-link">✅C++高阶论题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-c-惯用法" class="sidebar-link">1.C++惯用法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-1-raii-资源获取即初始化" class="sidebar-link">1.1.RAII(资源获取即初始化)</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-2-pimpl" class="sidebar-link">1.2.pImpl</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-3-copy-and-swap" class="sidebar-link">1.3.copy and swap</a></li></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-value-semantics和object-semantics" class="sidebar-link">2.value semantics和object semantics</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-1-值语义-value-semantics" class="sidebar-link">2.1.值语义（value semantics）</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-2-对象语义-object-semantics" class="sidebar-link">2.2.对象语义（object semantics）</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-3-优点缺点对比" class="sidebar-link">2.3.优点缺点对比</a></li></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-c-惯用法和value-semantics组合拳" class="sidebar-link">3.C++惯用法和value semantics组合拳</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-1-c-的值语义是『双刃剑』" class="sidebar-link">3.1.C++的值语义是『双刃剑』</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-3-问题-智能指针" class="sidebar-link">3.3.问题：智能指针？</a></li></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_4-c-语言层面高度探讨" class="sidebar-link">4.C++语言层面高度探讨</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_5-c-的编程范式" class="sidebar-link">5.C++的编程范式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_6-c-11、c-14、c-17以及c-20有什么区别呢" class="sidebar-link">6.c++11、c++14、C++17以及C++20有什么区别呢?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_7-c和c-在编译时-函数名会怎么变化-那如果是匿名空间呢" class="sidebar-link">7.C和C++在编译时,函数名会怎么变化,那如果是匿名空间呢?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_8-萃取-traits-技巧「模版的应用」" class="sidebar-link">8.萃取 traits 技巧「模版的应用」</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_9-菱形继承「虚基础」" class="sidebar-link">9.菱形继承「虚基础」</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_10-volatile「adj-不稳定的」" class="sidebar-link">10.volatile「adj，不稳定的」</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#mutable和volatile是啥" class="sidebar-link">mutable和volatile是啥？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#c-中inline和define的区别" class="sidebar-link">C++中inline和define的区别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#define-和-typedef-的区别" class="sidebar-link">define 和 typedef 的区别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#new-和-malloc" class="sidebar-link">new 和 malloc？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#lambda-表达式、std-function、函数指针这三者有什么区别「旷视」" class="sidebar-link">lambda 表达式、std::function、函数指针这三者有什么区别「旷视」</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#如果一个-lambda-表达式作为参数传递给一个函数-那这个函数可以使用这个-lambda-表达式捕获的变量吗「旷视」" class="sidebar-link">如果一个 lambda 表达式作为参数传递给一个函数，那这个函数可以使用这个 lambda 表达式捕获的变量吗「旷视」</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#那么反过来呢" class="sidebar-link">那么反过来呢？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#🔋-参考资料" class="sidebar-link">🔋 参考资料</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="c-面试题"><a href="#c-面试题" class="header-anchor">#</a> C++面试题</h1> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>&lt;font style=&quot;background:yellow&quot;&gt;
&lt;font style=&quot;background:pink&quot;&gt;
&lt;font style=&quot;background: MediumSpringGreen&quot;&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li><font style="background:yellow;">当一个程序员足够老，他就从工程师变成了历史学家</font></li></ul> <h2 id="📑-目录"><a href="#📑-目录" class="header-anchor">#</a> 📑 目录</h2> <p></p><div class="table-of-contents"><ul><li><a href="#📑-目录">📑 目录</a></li><li><a href="#✅虚函数">✅虚函数</a><ul><li><a href="#_1-虚函数表-vtbl">1.虚函数表vtbl</a></li><li><a href="#_2-构造一个「派生类」对象的过程">2.构造一个「派生类」对象的过程</a></li><li><a href="#_2-1-是先构造父类的「虚表指针」还是先构造父类的「成员」">2.1.是先构造父类的「虚表指针」还是先构造父类的「成员」？</a></li><li><a href="#_2-2-「虚表指针」和「构造函数体」那个先被构造">2.2.「虚表指针」和「构造函数体」那个先被构造？</a></li><li><a href="#_3-c-「运行构造函数」的时候「虚函数表」被构造出来了么">3.c++「运行构造函数」的时候「虚函数表」被构造出来了么？</a></li><li><a href="#_4-析构一个「派生类」object的过程">4.析构一个「派生类」object的过程</a></li></ul></li><li><a href="#✅基础">✅基础</a><ul><li><a href="#_1-vector是线程安全的吗">1.vector是线程安全的吗？</a></li><li><a href="#_2-c-是不是类型安全的呢">2.C++是不是类型安全的呢？</a></li><li><a href="#_3-sizeof-只有1个虚析构函数的空类呢">3.sizeof只有1个虚析构函数的空类呢？</a></li><li><a href="#_4-构造函数为什么不能是虚函数">4.构造函数为什么不能是虚函数？</a></li><li><a href="#_5-为何空类的大小不是零">5.为何空类的大小不是零？</a></li><li><a href="#_6-我能从构造函数调用虚函数吗">6.我能从构造函数调用虚函数吗？</a></li><li><a href="#_7-内存泄露及解决办法">7.内存泄露及解决办法：</a></li><li><a href="#_8-怎么检测内存泄漏">8.怎么检测内存泄漏？</a></li><li><a href="#_9-初始化顺序">9.初始化顺序</a></li></ul></li><li><a href="#✅平常做题错题">✅平常做题错题</a><ul><li><a href="#_1-测试">1.测试</a></li><li><a href="#_2-在-c-语言中-对函数参数默认值描述正确的是">2.在 c++ 语言中，对函数参数默认值描述正确的是？</a></li></ul></li><li><a href="#✅c-输入输出io">✅C++输入输出IO</a></li><li><a href="#_1-iostream-的设计初衷">1.iostream的设计初衷</a></li><li><a href="#_2-iostream-的特点">2.iostream的特点</a></li><li><a href="#✅c-高阶论题">✅C++高阶论题</a></li><li><a href="#_1-c-惯用法">1.C++惯用法</a><ul><li><a href="#_1-1-raii-资源获取即初始化">1.1.RAII(资源获取即初始化)</a></li><li><a href="#_1-2-pimpl">1.2.pImpl</a></li><li><a href="#_1-3-copy-and-swap">1.3.copy and swap</a></li></ul></li><li><a href="#_2-value-semantics-和-object-semantics">2.value semantics和object semantics</a><ul><li><a href="#_2-1-值语义-value-semantics">2.1.值语义（value semantics）</a></li><li><a href="#_2-2-对象语义-object-semantics">2.2.对象语义（object semantics）</a></li><li><a href="#_2-3-优点缺点对比">2.3.优点缺点对比</a></li></ul></li><li><a href="#_3-c-惯用法和-value-semantics-组合拳">3.C++惯用法和value semantics组合拳</a><ul><li><a href="#_3-1-c-的值语义是『双刃剑』">3.1.C++的值语义是『双刃剑』</a></li><li><a href="#_3-3-问题-智能指针">3.3.问题：智能指针？</a></li></ul></li><li><a href="#_4-c-语言层面高度探讨">4.C++语言层面高度探讨</a></li><li><a href="#_5-c-的编程范式">5.C++的编程范式</a></li><li><a href="#_6-c-11、c-14、c-17以及c-20有什么区别呢">6.c++11、c++14、C++17以及C++20有什么区别呢?</a></li><li><a href="#_7-c和c-在编译时-函数名会怎么变化-那如果是匿名空间呢">7.C和C++在编译时,函数名会怎么变化,那如果是匿名空间呢?</a></li><li><a href="#_8-萃取-traits-技巧「模版的应用」">8.萃取 traits 技巧「模版的应用」</a></li><li><a href="#_9-菱形继承「虚基础」">9.菱形继承「虚基础」</a></li><li><a href="#_10-volatile「adj-不稳定的」">10.volatile「adj，不稳定的」</a></li><li><a href="#mutable和volatile是啥">mutable和volatile是啥？</a></li><li><a href="#c-中inline和define的区别">C++中inline和define的区别？</a></li><li><a href="#define-和-typedef-的区别">define 和 typedef 的区别？</a></li><li><a href="#new-和-malloc">new 和 malloc？</a></li><li><a href="#lambda-表达式、std-function、函数指针这三者有什么区别「旷视」">lambda 表达式、std::function、函数指针这三者有什么区别「旷视」</a></li><li><a href="#如果一个-lambda-表达式作为参数传递给一个函数-那这个函数可以使用这个-lambda-表达式捕获的变量吗「旷视」">如果一个 lambda 表达式作为参数传递给一个函数，那这个函数可以使用这个 lambda 表达式捕获的变量吗「旷视」</a></li><li><a href="#那么反过来呢">那么反过来呢？</a></li><li><a href="#🔋-参考资料">🔋 参考资料</a></li></ul></div><p></p> <p>[TOC]</p> <h2 id="✅虚函数"><a href="#✅虚函数" class="header-anchor">#</a> ✅虚函数</h2> <p>本部分，特别是下面5个概念的顺序，不仅仅影响基础概念，而且还会影响，我们对线程安全的理解！！</p> <ul><li>虚函数表</li> <li>虚函数指针</li> <li>成员变量</li> <li>构造函数</li> <li>虚构函数</li></ul> <h3 id="_1-虚函数表vtbl"><a href="#_1-虚函数表vtbl" class="header-anchor">#</a> 1.虚函数表<code>vtbl</code></h3> <ol><li><p><font style="background:yellow;">编译器在<strong>编译时期</strong>为每个带虚函数的「类」创建一份<strong>虚函数表</strong></font></p></li> <li><p><strong>实例化</strong>对象时, 编译器自动将<strong>类对象（object）<strong>的</strong>虚表指针</strong>指向这个虚函数表</p></li></ol> <ul><li>参考自：《收割BAT：<a href="https://www.nowcoder.com/tutorial/10018/index" target="_blank" rel="noopener noreferrer">C++校招学习路线总结<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>》，特立独行MVP</li></ul> <p>意思：</p> <p>虚函数表，是属于class的。</p> <p>每个object有属于各自的虚表指针。</p> <h3 id="_2-构造一个「派生类」对象的过程"><a href="#_2-构造一个「派生类」对象的过程" class="header-anchor">#</a> 2.构造一个「派生类」对象的过程</h3> <ul><li>1.构造<strong>基类</strong>部分：
<ul><li>1.将object实例的<strong>虚表指针</strong>指向<strong>基类的vtbl</strong></li> <li>2.构造基类的**「成员变量」**</li> <li>3.<font style="background:yellow;">执行基类的「<strong>构造函数函数体」</strong></font></li></ul></li> <li>2.<strong>递归</strong>构造派生类部分：
<ul><li>1.将实例的虚表指针指向<strong>派生类vtbl</strong></li> <li>2.构造派生类的成员变量</li> <li>3.执行派生类的构造函数体</li></ul></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> ss<span class="token punctuation">)</span> <span class="token punctuation">{</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B constructor\n&quot;</span><span class="token punctuation">;</span> 
                       <span class="token function">f</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span> 
                       <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B::f\n&quot;</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;a=&quot;</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
  <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">D</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span> ss<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;D constructor\n&quot;</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> ss<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;D::f\n&quot;</span><span class="token punctuation">;</span> s <span class="token operator">=</span> ss<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">private</span><span class="token operator">:</span>
  string s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  D <span class="token function">d</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//output</span>
h@dell<span class="token operator">:</span><span class="token operator">~</span>$ <span class="token punctuation">.</span><span class="token operator">/</span>a<span class="token punctuation">.</span>out
B constructor
B<span class="token double-colon punctuation">::</span>f
a<span class="token operator">=</span><span class="token number">496370680</span>
D constructor
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><h3 id="_2-1-是先构造父类的「虚表指针」还是先构造父类的「成员」"><a href="#_2-1-是先构造父类的「虚表指针」还是先构造父类的「成员」" class="header-anchor">#</a> 2.1.是先构造父类的「虚表指针」还是先构造父类的「成员」？</h3> <ul><li>虚表指针</li></ul> <h3 id="_2-2-「虚表指针」和「构造函数体」那个先被构造"><a href="#_2-2-「虚表指针」和「构造函数体」那个先被构造" class="header-anchor">#</a> 2.2.「虚表指针」和「构造函数体」那个先被构造？</h3> <ul><li>虚表指针先构造</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
	<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

	<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> ss<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B constructor\n&quot;</span><span class="token punctuation">;</span> <span class="token function">f</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
		<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B::f\n&quot;</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span></span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">D</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span> ss<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;D constructor\n&quot;</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
		<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> ss<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;D::f\n&quot;</span><span class="token punctuation">;</span> s <span class="token operator">=</span> ss<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		string s<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		D <span class="token function">d</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token comment">//输出</span>
B constructor
B<span class="token double-colon punctuation">::</span>f
D constructor
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h3 id="_3-c-「运行构造函数」的时候「虚函数表」被构造出来了么"><a href="#_3-c-「运行构造函数」的时候「虚函数表」被构造出来了么" class="header-anchor">#</a> 3.c++「运行构造函数」的时候「虚函数表」被构造出来了么？</h3> <p>​	构造出来了。</p> <p>​	因为「虚函数表」是在<strong>编译时</strong>由编译器创建，在<strong>运行</strong>时肯定已经创建完成。</p> <h3 id="_4-析构一个「派生类」object的过程"><a href="#_4-析构一个「派生类」object的过程" class="header-anchor">#</a> 4.析构一个「派生类」object的过程</h3> <ul><li><p>1.<strong>递归</strong>析构派生类部分：</p> <ul><li>1.将实例的<strong>虚表指针</strong>指向<strong>派生类vtbl</strong></li> <li>2.执行派生类的<strong>析构函数体</strong></li> <li>3.析构派生类的<strong>成员变量</strong></li></ul></li> <li><p>2.析构基类部分：</p> <ul><li>1.将实例的<strong>虚表指针</strong>指向基类的vtbl</li> <li>2.执行基类的析构函数函数体</li> <li>3.析构基类的成员变量</li></ul></li></ul> <h2 id="✅基础"><a href="#✅基础" class="header-anchor">#</a> ✅基础</h2> <h3 id="_1-vector是线程安全的吗"><a href="#_1-vector是线程安全的吗" class="header-anchor">#</a> 1.vector是线程安全的吗？</h3> <ul><li>不是线程安全的！</li></ul> <p>比如，一个线程是生产者，不断push_back，然后多个线程并发读</p> <p>​	由于push_back潜在的内存重新申请和对象复制问题，会导致读方（消费者）的迭代器失效。不一定会产生正确的行为。</p> <p>解决方式，进行额外的同步。</p> <ul><li>参考：《Linux多线程服务器端编程》P4</li> <li>巨人网络</li></ul> <p>STL里面还有哪些class不是线程安全的呢？</p> <p>string、map、vector</p> <p>map不是线程安全的原因：</p> <p>比如这样的场景</p> <p><strong>当有多个写线程对情况下</strong>，并发地插入 map/unordered_map都会引发core dump。</p> <h3 id="_2-c-是不是类型安全的呢"><a href="#_2-c-是不是类型安全的呢" class="header-anchor">#</a> 2.C++是不是类型安全的呢？</h3> <p>1、C++<strong>不是</strong>类型安全的</p> <p>2、因为在C++中允许不同类型指针之间进行<strong>强制转换</strong>（<code>C#</code>是类型安全的）</p> <h3 id="_3-sizeof只有1个虚析构函数的空类呢"><a href="#_3-sizeof只有1个虚析构函数的空类呢" class="header-anchor">#</a> 3.<code>sizeof</code>只有1个虚析构函数的空类呢？</h3> <p>1、64位的机器的话，那么就是8Byte，虚函数指针</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">sss</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">sss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">sss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>

    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span> sss <span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h3 id="_4-构造函数为什么不能是虚函数"><a href="#_4-构造函数为什么不能是虚函数" class="header-anchor">#</a> 4.构造函数为什么不能是虚函数？</h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">sss</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token function">sss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token operator">~</span><span class="token function">sss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    sss a<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span> sss <span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><ul><li>64位机器，64位<code>g++</code> <ul><li>运行报错：<code>error: constructors cannot be declared virtual [-fpermissive]</code></li></ul></li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>constructors cannot be declared virtual [-fpermissive]
构造函数不能声明为virtual [-fpermissive]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>参考：『Bjarne Stroustrup's C++ Style and Technique FAQ』</li> <li>参考：<a href="https://www.stroustrup.com/index.html" target="_blank" rel="noopener noreferrer">https://www.stroustrup.com/index.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Why don<span class="token number">'</span>t we have <span class="token keyword">virtual</span> constructors<span class="token operator">?</span>
A <span class="token keyword">virtual</span> call is a mechanism to get work done given partial information<span class="token punctuation">.</span> In particular<span class="token punctuation">,</span> <span class="token string">&quot;virtual&quot;</span> allows us to call a function knowing only an interfaces <span class="token operator">and</span> <span class="token operator">not</span> the exact type of the object<span class="token punctuation">.</span> To create an object you need complete information<span class="token punctuation">.</span> In particular<span class="token punctuation">,</span> you need to know the exact type of what you want to create<span class="token punctuation">.</span> Consequently<span class="token punctuation">,</span> a <span class="token string">&quot;call to a constructor&quot;</span> cannot be <span class="token keyword">virtual</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>为什么我们没有虚拟构造函数？
1、虚拟调用是在<strong>给定部分信息</strong>的情况下完成工作的机制。特别是，“虚拟”允许我们调用一个只知道接口而不知道对象确切类型的函数。
2、要<strong>创建对象</strong>，您需要<strong>完整的信息</strong>。特别是，您需要知道您想要创建的内容的确切类型。因此，“对构造函数的调用”不能是虚拟的。</p> <h3 id="_5-为何空类的大小不是零"><a href="#_5-为何空类的大小不是零" class="header-anchor">#</a> 5.为何空类的大小不是零？</h3> <ul><li>为了<strong>确保两个不同对象的地址不同</strong>，必须如此。也正因为如此，new返回的指针总是指向不同的单个对象。我们还是来看代码吧：</li> <li>参考文献<a href="https://www.stroustrup.com/bstechfaq.htm" target="_blank" rel="noopener noreferrer">传送门<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Empty</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Empty a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;impossible: report error to compiler supplier\n&quot;</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;不可能:向编译器供应商报告错误\n&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    Empty<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> Empty<span class="token punctuation">;</span>
    Empty<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> Empty<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;impossible: report error to compiler supplier\n&quot;</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;不可能:向编译器供应商报告错误\n&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>    
<span class="token comment">//我在64位机器，64位g++上，运行了，发现什么都没输出</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><ul><li>另外，C++中有一条有趣的规则——空基类并不需要另外一个字节来表示：</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Empty</span></span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> a<span class="token punctuation">;</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>X<span class="token operator">*</span> p<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">void</span><span class="token operator">*</span> p1 <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token keyword">void</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>a<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;nice: good optimizer&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
            cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;nice：很好的优化器&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token comment">//我在64位机器，64位g++上，运行了，输出了上面的</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li>如果上述代码中p1和p2相等，那么<strong>说明编译器作了优化</strong>。</li> <li>这样的优化是安全的，而且非常有用。它允许程序员用空类来表示非常简单的概念，而不需为此付出额外的（空间）代价。一些现代编译器提供了这种“虚基类优化”功能。</li></ul> <h3 id="_6-我能从构造函数调用虚函数吗"><a href="#_6-我能从构造函数调用虚函数吗" class="header-anchor">#</a> 6.我能从构造函数调用虚函数吗？</h3> <ul><li><p><strong>可以。不过你得悠着点</strong>。</p></li> <li><p>当你这样做时，也许你自己都不知道自己在干什么！在构造函数中，虚拟机制尚未发生作用，因为此时overriding尚未发生。万丈高楼平地起，总得先打地基吧？对象的建立也是这样——先把基类构造完毕，然后在此基础上构造派生类。</p></li> <li><p>参考自<a href="https://www.stroustrup.com/bstechfaq.htm" target="_blank" rel="noopener noreferrer">文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul> <h3 id="_7-内存泄露及解决办法"><a href="#_7-内存泄露及解决办法" class="header-anchor">#</a> 7.内存泄露及解决办法：</h3> <p>什么是内存泄露？   简单地说就是申请了一块内存空间，<strong>使用完毕后没有释放掉</strong></p> <p>1、new和malloc申请资源使用 后，没有用delete和free释放；</p> <p>2、子类继承父类时，父类析构函数不是虚函数。</p> <h3 id="_8-怎么检测内存泄漏"><a href="#_8-怎么检测内存泄漏" class="header-anchor">#</a> 8.怎么检测内存泄漏？</h3> <ul><li>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉</li> <li>第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改这个链表</li> <li>第三：使用智能指针</li> <li>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、<font style="background:yellow;">Valgrind</font>等等</li></ul> <h3 id="_9-初始化顺序"><a href="#_9-初始化顺序" class="header-anchor">#</a> 9.初始化顺序</h3> <p>​	在C++中，初始化顺序是按照<strong>定义</strong>的顺序来进行的。比如，如果一个类有三个成员变量，那么它们将<strong>按照定义的顺序</strong>进行初始化。构造函数只是用来<strong>指定初始化值</strong>的，而<strong>不是</strong>指定初始化<strong>顺序</strong>的。</p> <h2 id="✅平常做题错题"><a href="#✅平常做题错题" class="header-anchor">#</a> ✅平常做题错题</h2> <h3 id="_1-测试"><a href="#_1-测试" class="header-anchor">#</a> 1.测试</h3> <ul><li>题目参考<a href="https://www.nowcoder.com/test/question/done?tid=44295104&amp;qid=112041" target="_blank" rel="noopener noreferrer">传送门<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span> 
    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">;</span>
    p<span class="token operator">=</span>s<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%c%c%c\n&quot;</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token operator">++</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token operator">++</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//以下程序的输出结果是（）。</span>
<span class="token comment">//321</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>牛油的回答</p> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>2. 运算对象求值顺序不明：
C++中只有'&amp;&amp;', '||', ',', '?:' 这四个运算符明确了其所属运算对象的求值顺序。

函数调用也是一种运算符
而实参压栈顺序完全依赖于编译器实现，三个*p++求值顺序不明。
那么结合第一个问题，假如从左向右压栈结果就是123
如果换个编译器可能顺序又不同了
所有选项可能都能有幸成为正确答案

所以，这种表达式是错误的，会产生未定义的行为。
这种题目真的不该再出。


大家看的所谓语言书籍的作者当年基本都是i386的使用者
这就是大家看到“压栈顺序从右至左”这一说法的原因
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ul><li>我的测试环境64位机器的<code>g++</code>下</li> <li>实参压栈顺序是『从右到左』</li></ul> <h3 id="_2-在-c-语言中-对函数参数默认值描述正确的是"><a href="#_2-在-c-语言中-对函数参数默认值描述正确的是" class="header-anchor">#</a> 2.在 c++ 语言中，对函数参数默认值描述正确的是？</h3> <ul><li>题目<a href="https://www.nowcoder.com/test/question/done?tid=44202421&amp;qid=143523#summary" target="_blank" rel="noopener noreferrer">来源<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>A 函数参数的默认值只能设定一个
B 一个函数的参数若有多个，则参数默认值的设定可以不连续
C 函数参数必须设定默认值
D 在设定了参数的默认值后，该参数后面定义的所有参数都必须设定默认值
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>我选择的是D</li> <li>2020-10.2
<ul><li>我当时的解释：C++语言中，允许在函数的说明或定义时给一个或多个参数指定默认值。<strong>参数默认值必须从右向左定义</strong>（入栈的顺序，汇编），即在一个指定了默认值的参数的右边，不能出现没有指定默认值的参数。</li></ul></li> <li>2021.7月
<ul><li>我对上面的解释：关于汇编的那个事情，我突然记得那时候我学的是X86的汇编</li></ul></li></ul> <h2 id="✅c-输入输出io"><a href="#✅c-输入输出io" class="header-anchor">#</a> ✅C++输入输出IO</h2> <h2 id="_1-iostream的设计初衷"><a href="#_1-iostream的设计初衷" class="header-anchor">#</a> 1.<code>iostream</code>的设计初衷</h2> <ul><li>对初学者友好</li> <li>提供一个高效的可扩展的类型安全的IO机制</li></ul> <blockquote><p><code>iostream</code>的现状</p></blockquote> <ul><li>在真实的项目中很少用到<code>iostream</code> <ul><li>参考自“陈硕”</li></ul></li></ul> <h2 id="_2-iostream的特点"><a href="#_2-iostream的特点" class="header-anchor">#</a> 2.<code>iostream</code>的特点</h2> <ul><li>不同于标准库其他class的“值语义(value semantics)”，<code>iostream</code>是“对象语义(object semantics)”
<ul><li>即iostream是<code>non-copyable</code></li> <li>iostream禁止拷贝，利用对象的生命期来明确管理资源（如文件）</li></ul></li> <li><code>iostream</code>在<strong>线程安全</strong>方面没有保证！</li></ul> <h2 id="✅c-高阶论题"><a href="#✅c-高阶论题" class="header-anchor">#</a> ✅C++高阶论题</h2> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>术语
    内存泄漏
c++编程风格惯用法
    1.类初始化列表
    2.枚举类替换命名空间
    3.RAII(资源获取即初始化)
    4.copy and swap
    5.pImpl(指针指向具体实现)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_1-c-惯用法"><a href="#_1-c-惯用法" class="header-anchor">#</a> 1.C++惯用法</h2> <h3 id="_1-1-raii-资源获取即初始化"><a href="#_1-1-raii-资源获取即初始化" class="header-anchor">#</a> 1.1.RAII(资源获取即初始化)</h3> <blockquote><p>RAII（资源获取即初始化）『<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization』</p></blockquote> <ul><li><a href="https://zh.wikipedia.org/wiki/RAII" target="_blank" rel="noopener noreferrer">维基百科<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：RAII</li> <li>为解决资源管理时的<font style="background:yellow;">异常安全性</font></li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>它是在一些面向对象语言中的一种惯用法。

RAII源于C++
在Java，C#，D，Ada，Vala和Rust中也有应用
1984-1989年期间，比雅尼·斯特劳斯特鲁普和安德鲁·柯尼希在设计C++异常时，为解决资源管理时的异常安全性而使用了该用法[1]，后来比雅尼·斯特劳斯特鲁普将其称为RAII[2]。

RAII要求，资源的有效期与持有资源的对象的生命期严格绑定，即由对象的构造函数完成资源的分配（获取），同时由析构函数完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现资源泄露问题。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_1-2-pimpl"><a href="#_1-2-pimpl" class="header-anchor">#</a> 1.2.pImpl</h3> <blockquote><p>pImpl（指向实现的指针）『<strong>P</strong>ointer to <strong>Impl</strong>ementation』，Implementation，实现，实施</p></blockquote> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>是一种 C++ 编程技巧
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>它将类的<strong>实现细节</strong>从对象表示中移除，放到一个『<strong>分离的类</strong>』中，并以一个『<strong>不透明的指针</strong>』进行访问。</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>优点：
    1、减少依赖项（降低耦合性）：其一减少原类不必要的头文件的依赖，加速编译；其二对Impl类进行修改，无需重新编译原类。
    2、接口和实现的分离（隐藏了类的实现）：私有成员完全可以隐藏在共有接口之外，给用户一个间接明了的使用接口，尤其适合闭源API设计。
    3、可使用惰性分配技术：类的某部分实现可以写成按需分配或者实际使用时再分配，从而节省资源。

缺点：
    1、每个类需要占用小小额外的指针内存。

    2、每个类每次访问具体实现时都要多一个间接指针操作的开销，并且在使用、阅读和调试上都可能有所不便
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>参考自：<a href="https://www.cnblogs.com/KillerAery/p/9539705.html" target="_blank" rel="noopener noreferrer">博客园<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="_1-3-copy-and-swap"><a href="#_1-3-copy-and-swap" class="header-anchor">#</a> 1.3.copy and swap</h3> <h2 id="_2-value-semantics和object-semantics"><a href="#_2-value-semantics和object-semantics" class="header-anchor">#</a> 2.<code>value semantics</code>和<code>object semantics</code></h2> <ul><li>参考自：《Linux多线程服务器编程》，使用muduoC++网络库</li></ul> <p><font style="background:yellow;">仔细理解：书上P482-484</font></p> <h3 id="_2-1-值语义-value-semantics"><a href="#_2-1-值语义-value-semantics" class="header-anchor">#</a> 2.1.值语义（value semantics）</h3> <ul><li>所谓值语义是指目标对象由源对象拷贝生成，且生成后与源对象完全无关，彼此独立存在，改变互不影响。就像 int 类型变量相互拷贝一样。</li> <li>value semantics：指的是对象的拷贝与原对象无关</li></ul> <blockquote><p>举例：</p></blockquote> <ul><li><font style="background:yellow;">C++</font>的内置类型（<code>bool/int/double/char</code>）都是值语义，标准库里的 <code>complex&lt;&gt;</code>、<code>pair&lt;&gt;</code>、<code>vector&lt;&gt;</code>、<code>map&lt;&gt;</code>、<code>string</code> 等等类型也都是值语义。</li> <li><font style="background:yellow;">Java</font>语言中的<code>primitive types（基础类型）比如：int 、short、long</code>也是值语义</li></ul> <p><strong>拷贝之后就与源对象完全脱离关系</strong></p> <h3 id="_2-2-对象语义-object-semantics"><a href="#_2-2-对象语义-object-semantics" class="header-anchor">#</a> 2.2.对象语义（object semantics）</h3> <ul><li><font style="background:yellow;">别名：</font>对象语义也叫<strong>指针语义</strong>，**引用语义（reference semantics）**等</li> <li>通常是指一个目标对象由源对象拷贝生成，但生成后与源对象之间依然共享底层资源，对任何一个的改变都将随之改变另一个。就像包含有指针成员变量的自定义类在默认拷贝构造函数下对其对象之间进行的拷贝。拷贝后目标对象和源对象的指针成员变量仍指向同一块内存数据。如果当其中一个被析构掉后，另一个对象的指针成员就会沦为名副其实的悬垂指针！</li></ul> <p>核心理解：”对象语义“这个词中“对象”指的是<font style="background:yellow;">『<strong>面向对象</strong>』</font>意义下的对象，并不是我们<font style="background:yellow;">『<strong>语法意义上class生成的</strong>』</font>对象，我们的结论是：『面向对象意义下的对象，对象拷贝是禁止的』</p> <ul><li>例子：</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>薪资管理系统中，一个对象叫：员工张三
我们拷贝“员工张三”这个对象是没有意义的！！
因为员工张三这个对象代表的是一个活生生的人，我们拷贝它是被禁止的。

服务器开发中，也有类似的情况
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>结论：<font style="background:yellow;">『面向对象』意义下的&quot;对象&quot;是<code>non-copyable</code>（不能够拷贝的）</font></li></ul> <blockquote><p>举例：</p></blockquote> <ul><li><p><font style="background:yellow;">Java</font>语言中class对象<font style="background:yellow;">都是</font>“对象语义”</p> <ul><li><font style="background:yellow;">Java</font>语言没有办法实现『真正的』“值语义”class，只好用<code>immutable object</code>来模拟</li> <li><font style="background:yellow;">Java</font>语言中有<code>value object</code>一说，按照定义，它实际上是<code>immutable object（不可改变的对象）</code>，比如<code>Interger，String，BigInterger</code></li></ul></li> <li><p><font style="background:yellow;">C++</font>语言中class本质上是<font style="background:yellow;">值语义</font>，值语义对象，比如<code>pair&lt;&gt;，vector&lt;&gt;，string&lt;&gt;</code>等，都是可修改的（mutable）</p></li></ul> <h3 id="_2-3-优点缺点对比"><a href="#_2-3-优点缺点对比" class="header-anchor">#</a> 2.3.优点缺点对比</h3> <p>值语义（value semantics）</p> <ul><li>优点：生命期管理很简单，比如 C++中<code>int</code>类型一样—你不需要操心 int 对象 的生命期。
<ul><li>因为：值语义的对象要么是<code>stack object</code>，要么是<code>作为其他object的成员</code></li></ul></li></ul> <p>对象语义（object semantics）</p> <ul><li><p>缺点：对象语义的object由于不能拷贝，因此我们只能在<font style="background:yellow;">C++的实现</font>是通过’指针“或”引用“来使用它</p></li> <li><p><code>immutable</code>不可修改的</p></li> <li><p><code>mutable</code>可修改的</p></li></ul> <h2 id="_3-c-惯用法和value-semantics组合拳"><a href="#_3-c-惯用法和value-semantics组合拳" class="header-anchor">#</a> 3.C++惯用法和<code>value semantics</code>组合拳</h2> <ul><li>值语义，对象语义</li> <li>RAII</li> <li>智能指针</li></ul> <h3 id="_3-1-c-的值语义是『双刃剑』"><a href="#_3-1-c-的值语义是『双刃剑』" class="header-anchor">#</a> 3.1.C++的值语义是『双刃剑』</h3> <ul><li>由于C++中class本质上是<font style="background:yellow;">值语义</font>，这
<ul><li>才会出现<code>object slicing</code>这种语言独有的问题！！</li> <li>才会需要程序员注意：<code>pass-by-value</code>和<code>pass-by-const-reference</code>的取舍</li></ul></li> <li>在其他『面向对象语言』，比如Java中，这都不需要费脑筋。。</li></ul> <p>书上P488</p> <ul><li>值语义是<strong>C++语言3大约束之一</strong>，C++的设计初衷是让用户定义的类型（class）能像内置类型（int）一样工作，具有<strong>同等</strong>的地位。</li></ul> <h3 id="_3-3-问题-智能指针"><a href="#_3-3-问题-智能指针" class="header-anchor">#</a> 3.3.问题：智能指针？</h3> <ul><li><font style="background:yellow;">智能指针既不是『值语义』也不是『对象语义』</font></li> <li>由于『值语义和对象语义的原因』
<ul><li><font style="background:yellow;">如果不使用智能指针，用C++做面向对象编程将会困难重重</font></li></ul></li></ul> <h2 id="_4-c-语言层面高度探讨"><a href="#_4-c-语言层面高度探讨" class="header-anchor">#</a> 4.C++语言层面高度探讨</h2> <p>C++复杂的根源在于三大约束：</p> <ul><li>与C的完全兼容</li> <li>静态类型检查</li> <li>最高性能</li></ul> <p><strong>在三大约束下，C++未能完善对于面向对象思想的支持，未能建立强大的动态能力，从而使得C++在OO这个单项上存在本质缺陷</strong>。</p> <ul><li>事实上，C++的过程、OB模型相当成熟和稳定</li> <li>而泛型模型，就单项来说，除了语法丑陋之外也没有大的问题。</li> <li>缺陷集中体现在OO模型的实现，并因此干扰了其他几个范式的完整程度。
<ul><li>然而，OO的缺陷绝非设计者的偏执，其原因在于三大约束。如果坚持三大约束，则即使再重新设计一次，结果也与今日相差不远。Stroustrup在多种场合表示，对C++的设计没有大的后悔之处，意思就是这个。</li> <li>侯捷先生早在2001年初即对我说，C++在OO上不及Java，当时体会不深，认为没有大一统的单根类库会使设计更加灵活，后来又认为凭借GP可以抵消OO的不足甚至超越之，现在看来即使不是不可能，这条道路也必然是艰辛异常，成败难以预料。</li></ul></li></ul> <blockquote><p>参考自：<a href="https://blog.csdn.net/myan/article/details/148900" target="_blank" rel="noopener noreferrer">CSDN的myan（孟岩）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="_5-c-的编程范式"><a href="#_5-c-的编程范式" class="header-anchor">#</a> 5.C++的编程范式</h2> <p>5.1.过程式编程</p> <p>5.2.基于对象编程</p> <p>5.3.面向对象编程</p> <p>5.4.泛型编程</p> <p>5.5.函数式编程</p> <h2 id="_6-c-11、c-14、c-17以及c-20有什么区别呢"><a href="#_6-c-11、c-14、c-17以及c-20有什么区别呢" class="header-anchor">#</a> 6.c++11、c++14、C++17以及C++20有什么区别呢?</h2> <ul><li>字节跳动，一面</li> <li>参考：https://github.com/AnthonyCalandra/modern-cpp-features</li></ul> <blockquote><p>C++11</p></blockquote> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>C++11 includes the following new language features:

move semantics
variadic templates
rvalue references
forwarding references
initializer lists
static assertions
auto
lambda expressions
decltype
<span class="token builtin class-name">type</span> aliases
nullptr
strongly-typed enums
attributes
constexpr
delegating constructors
user-defined literals
explicit virtual overrides
final specifier
default functions
deleted functions
range-based <span class="token keyword">for</span> loops
special member functions <span class="token keyword">for</span> move semantics
converting constructors
explicit conversion functions
inline-namespaces
non-static data member initializers
right angle brackets
ref-qualified member functions
trailing <span class="token builtin class-name">return</span> types
noexcept specifier
char32_t and char16_t
raw string literals


C++11 includes the following new library features:

std::move
std::forward
std::thread
std::to_string
<span class="token builtin class-name">type</span> traits
smart pointers
std::chrono
tuples
std::tie
std::array
unordered containers
std::make_shared
std::ref
memory model
std::async
std::begin/end
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><blockquote><p>C++14</p></blockquote> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>C++14 includes the following new language features:

binary literals
generic lambda expressions
lambda capture initializers
<span class="token builtin class-name">return</span> <span class="token builtin class-name">type</span> deduction
decltype<span class="token punctuation">(</span>auto<span class="token punctuation">)</span>
relaxing constraints on constexpr functions
variable templates
<span class="token punctuation">[</span><span class="token punctuation">[</span>deprecated<span class="token punctuation">]</span><span class="token punctuation">]</span> attribute
C++14 includes the following new library features:

user-defined literals <span class="token keyword">for</span> standard library types
compile-time integer sequences
std::make_unique
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><blockquote><p>C++17</p></blockquote> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>C++17 includes the following new language features:

template argument deduction <span class="token keyword">for</span> class templates
declaring non-type template parameters with auto
folding expressions
new rules <span class="token keyword">for</span> auto deduction from braced-init-list
constexpr lambda
lambda capture this by value
inline variables
nested namespaces
structured bindings
selection statements with initializer
constexpr <span class="token keyword">if</span>
utf-8 character literals
direct-list-initialization of enums
fallthrough, nodiscard, maybe_unused attributes
C++17 includes the following new library features:

std::variant
std::optional
std::any
std::string_view
std::invoke
std::apply
std::filesystem
std::byte
splicing <span class="token keyword">for</span> maps and sets
parallel algorithms
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><blockquote><p>C++20</p></blockquote> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>C++20 includes the following new language features:

coroutines
concepts
designated initializers
template syntax <span class="token keyword">for</span> lambdas
range-based <span class="token keyword">for</span> loop with initializer
likely and unlikely attributes
deprecate implicit capture of this
class types <span class="token keyword">in</span> non-type template parameters
constexpr virtual functions
explicit<span class="token punctuation">(</span>bool<span class="token punctuation">)</span>
immediate functions
using enum
lambda capture of parameter pack
char8_t
C++20 includes the following new library features:

concepts library
synchronized buffered outputstream
std::span
bit operations
math constants
std::is_constant_evaluated
std::make_shared supports arrays
starts_with and ends_with on strings
check <span class="token keyword">if</span> associative container has element
std::bit_cast
std::midpoint
std::to_array
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h2 id="_7-c和c-在编译时-函数名会怎么变化-那如果是匿名空间呢"><a href="#_7-c和c-在编译时-函数名会怎么变化-那如果是匿名空间呢" class="header-anchor">#</a> 7.C和C++在编译时,函数名会怎么变化,那如果是匿名空间呢?</h2> <p>​	在匿名命名空间中声明的名称也将被编译器转换，与编译器为这个匿名命名空间生成的唯一内部名称(即这里的<code>__UNIQUE_NAME_)</code>绑定在一起</p> <h2 id="_8-萃取-traits-技巧「模版的应用」"><a href="#_8-萃取-traits-技巧「模版的应用」" class="header-anchor">#</a> 8.萃取 traits 技巧「模版的应用」</h2> <p>​	 面试时候，大概回答：traits，一种模板偏特化的应用。《STL源码剖析》一书中提到<strong>Traits编程技法</strong>，它的作用是获取型别(associated type)的特性。</p> <ul><li>参考资料：https://mp.weixin.qq.com/s/rPh9PfTjPCROj1EmWHA6nw</li></ul> <p>在 STL 编程中，容器和算法是独立设计的，即数据结构和算法是独立设计的，连接容器和算法的桥梁就是迭代器了，迭代器使其独立设计成为可能</p> <p>​	这样讲比较抽象，到底什么是相应型别</p> <p>​	或者到底什么时候需要用到Traits编程技法呢？</p> <p>​	traits 是模板元编程中的一个非常重要的概念，它可以<strong>萃取</strong>类型中的许多重要信息，利于 我们在<strong>编译期</strong>提早做出决断。</p> <p>​	<strong>traits，又被叫做特性萃取技术</strong>，说得简单点就是提取“被传进的对象”对应的返回类型，让同一个接口实现对应的功能。因为STL的算法和容器是分离的，两者通过迭代器链接。算法的实现并不知道自己被传进来什么。萃取器相当于在接口和实现之间加一层封装，来隐藏一些细节并协助调用合适的方法，这需要一些技巧（例如，偏特化）。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">TraitsHelper</span> <span class="token punctuation">{</span>
     <span class="token keyword">typedef</span> T ret_type<span class="token punctuation">;</span> <span class="token comment">//返回值</span>
     <span class="token keyword">typedef</span> T par_type<span class="token punctuation">;</span> <span class="token comment">//对应的值</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">TraitsHelper</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token comment">//模版偏特化</span>
     <span class="token keyword">typedef</span> <span class="token keyword">int</span> ret_type<span class="token punctuation">;</span>
     <span class="token keyword">typedef</span> <span class="token keyword">int</span> par_type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">TraitsHelper</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
     <span class="token keyword">typedef</span> <span class="token keyword">float</span> ret_type<span class="token punctuation">;</span>
     <span class="token keyword">typedef</span> <span class="token keyword">int</span> par_type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
     TraitsHelper<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>ret_type  <span class="token comment">//借助传入的T，走一遍偏特化的路径，完美就能获得一个返回值类型</span>
       	<span class="token function">Compute</span><span class="token punctuation">(</span> TraitsHelper<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>par_type d <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这样完美的Compute函数，就能根据不能类型的类型，进行不同的处理！</span>
<span class="token keyword">private</span><span class="token operator">:</span>
     T mData<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><ul><li>【C++模版之旅】<a href="https://blog.csdn.net/my_business/article/details/7891687" target="_blank" rel="noopener noreferrer">神奇的Traits<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>「解释得最简单」</li> <li>参考资料：https://yosef-gao.github.io/2016/10/05/cpp-traits/「举例」</li> <li>第 3 章 类型特征萃取，C++11/14高级编程，Boost程序库探秘，http://www.tup.tsinghua.edu.cn/upload/books/yz/069426-01.pdf</li></ul> <h2 id="_9-菱形继承「虚基础」"><a href="#_9-菱形继承「虚基础」" class="header-anchor">#</a> 9.菱形继承「虚基础」</h2> <ul><li>CSDN<a href="https://blog.csdn.net/jackystudio/article/details/17877219" target="_blank" rel="noopener noreferrer">解释得不错<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>​	菱形继承是多重继承中跑不掉的，Java拿掉了多重继承，辅之以接口。C++中虽然没有明确说明接口这种东西，但是只有纯虚函数的类可以看作Java中的接口。</p> <p>​	如下是菱形继承的代码。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">printA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span>  <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span> <span class="token punctuation">,</span>  <span class="token keyword">public</span> <span class="token class-name">C</span></span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    D d<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h2 id="_10-volatile「adj-不稳定的」"><a href="#_10-volatile「adj-不稳定的」" class="header-anchor">#</a> 10.volatile「adj，不稳定的」</h2> <p>​	C/C++ 中的 <strong>volatile 关键字和 const 对应</strong>，用来修饰变量，通常用于建立语言级别的 memory barrier。这是 BS 在 &quot;The C++ Programming Language&quot; 对 volatile 修饰词的说明：</p> <p>​	volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：<strong>int volatile vInt;</strong> 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</p> <h2 id="mutable和volatile是啥"><a href="#mutable和volatile是啥" class="header-anchor">#</a> mutable和volatile是啥？</h2> <p>​	C++中修饰数据可变性的关键字有三个：const、volatile和mutable。const比较好理解，表示其修饰的内容不可改变（至少编译期不可改变），而<strong>volatile和mutable恰好相反，指示数据总是可变的</strong>。mutable和volatile均可以和const搭配使用，但两者在使用上有比较大差别。</p> <p>​	若要修改const修饰的变ᰁ的值，需要加上关键字volatile；</p> <p>若想要修改<strong>const成员函数</strong>中某些<strong>与类状态⽆关</strong>的数据成员，可以使⽤mutable关键字来修饰这个数据成员；</p> <ul><li><p>如上，const方法中不允许对常规成员进行变动，但mutable成员不受此限制</p></li> <li><p>参考资料：https://juejin.cn/post/7051552359389855757</p></li></ul> <h2 id="c-中inline和define的区别"><a href="#c-中inline和define的区别" class="header-anchor">#</a> C++中inline和define的区别？</h2> <table><thead><tr><th></th> <th>define</th> <th>inline</th></tr></thead> <tbody><tr><td>处理阶段</td> <td>在预处理阶段就换成了字符串的替换</td> <td>inline在<strong>编译阶段</strong>进行</td></tr> <tr><td>类型安全检查</td> <td>简单的字符串替换「不存在」</td> <td>inline函数还是一个函数，编译器会进行类型安全检查，因此更加安全</td></tr> <tr><td>是否强制</td> <td>只要定义了就会替换</td> <td>inline只是建议，编译器可以拒绝替换</td></tr> <tr><td>替换方式</td> <td>单纯的字符串替换</td> <td>inline是代码嵌入，也就是说<strong>编译器在函数调用的地方直接将inline函数代码写进去，这样就不会产生函数的调用跳转（无栈帧消耗）</strong>，因此适用于短小的函数，并且安全可靠。</td></tr></tbody></table> <p>​	在汇编中，inline生效的表现是，编译器会将汇编代码中的指令<strong>嵌入到</strong>调用函数的位置，而<strong>不是将指令放入一个独立的函数</strong>中。这样做的好处是，可以减少函数调用时的开销，提高程序的运行效率。</p> <ul><li>最后还要提醒一点：<strong>inline关键字必须在函数定义处，位于函数声明处则无效</strong>，因此一般将公共的inline函数的定义写在头文件中。</li></ul> <h2 id="define-和-typedef-的区别"><a href="#define-和-typedef-的区别" class="header-anchor">#</a> define 和 typedef 的区别？</h2> <table><thead><tr><th></th> <th>define</th> <th>typedef</th></tr></thead> <tbody><tr><td>处理阶段</td> <td>预处理</td> <td>在编译、运⾏的时候起作⽤</td></tr> <tr><td>类型检查</td> <td>简单的字符串替换，没有类型检查</td> <td>有对应的数据类型，是要进⾏判断的</td></tr> <tr><td></td> <td></td> <td></td></tr></tbody></table> <h2 id="new-和-malloc"><a href="#new-和-malloc" class="header-anchor">#</a> new 和 malloc？</h2> <p>首先，new是new表达式（是关键词！注意⚠️：不是运算符！），malloc是函数</p> <p>new表达式，会被编译器转换为3步</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Demo <span class="token operator">*</span> pc<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">try</span><span class="token punctuation">{</span>
  	<span class="token keyword">void</span> <span class="token operator">*</span> mem<span class="token operator">=</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Demo<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//allocate，这个operator new函数是能抛异常的！！</span>
  	pc<span class="token operator">=</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Demo<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//cast</span>
  	pc<span class="token operator">-&gt;</span><span class="token class-name">Demo</span><span class="token double-colon punctuation">::</span><span class="token function">Demo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//	注意，只有编译器才能像上面，那样，直接呼叫ctor //构造函数</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>、new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。
2、使⽤new操作符申请内存分配时⽆须指定内存块的⼤⼩「因为这是编译器自己转换的」，⽽malloc则需要显式地指出所需内存的尺⼨。
3、opeartor new /operator delete可以被᯿载，⽽malloc/free并不允许᯿载。
4、new/delete会调⽤对象的构造函数/析构函数以完成对象的构造/析构。⽽malloc则不会
5、malloc与free是C++/C语⾔的标准库函数,new/delete是C++的运算符
6、new操作符从⾃由存储区上为对象动态分配内存空间，⽽malloc函数从堆上动态分配内存</p> <h2 id="lambda-表达式、std-function、函数指针这三者有什么区别「旷视」"><a href="#lambda-表达式、std-function、函数指针这三者有什么区别「旷视」" class="header-anchor">#</a> lambda 表达式、std::function、函数指针这三者有什么区别「旷视」</h2> <p>Lambda表达式、std::function和函数指针都可以在C++中用于表示函数，但它们有一些不同之处</p> <ol><li>Lambda表达式 Lambda表达式是一种匿名函数，可以在程序中<strong>直接定义</strong>并传递给其他函数。Lambda表达式可以捕获外部变量，以在函数中使用。Lambda表达式的语法如下：</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token punctuation">[</span>capture list<span class="token punctuation">]</span> <span class="token punctuation">(</span>parameters<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">return</span><span class="token operator">-</span>type <span class="token punctuation">{</span> function body <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其中，捕获列表是在函数体中使用的外部变量列表。参数是函数的形参列表，返回类型是函数的返回类型，函数体是实现函数的语句块。例如，以下Lambda表达式返回两个数的和：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">auto</span> sum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>2,<code>std::function</code> 是一个<strong>模板类</strong>，用于包装任何<strong>可调用对象</strong>，包括<strong>函数指针</strong>、<strong>Lambda表达式</strong>和<strong>函数对象</strong>。std::function的语法如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>cCopy code
std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">return</span><span class="token operator">-</span><span class="token function">type</span><span class="token punctuation">(</span>parameters<span class="token punctuation">)</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>其中，返回类型是函数的返回类型，参数是函数的形参列表。例如，以下std::function包装了一个返回两个数的和的Lambda表达式：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>
std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> sum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以使用std::function调用包装的函数，就像调用普通函数一样：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>int result = sum(3, 4);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>3/函数指针 函数指针是指向函数的指针，可以将其用作函数的参数或返回值。函数指针的语法如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>pythonCopy code
return-type (*pointer-name)(parameters)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>其中，返回类型是函数的返回类型，参数是函数的形参列表，指针名称是指向函数的指针名称。例如，以下函数指针指向一个返回两个数的和的函数：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;functional&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    function<span class="token operator">&lt;</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> f<span class="token operator">=</span>demo<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span> <span class="token string">&quot;val=&quot;</span><span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>

    function<span class="token operator">&lt;</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> mysum <span class="token operator">=</span> 
        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">int</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;val=&quot;</span><span class="token operator">&lt;&lt;</span> <span class="token function">mysum</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>参考<a href="https://www.nowcoder.com/discuss/389795188493889536?sourceSSR=search" target="_blank" rel="noopener noreferrer">资料<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>4 中提到的都可以转换为 <code>std::function</code></li> <li>没有什么可以直接转换为 lambda</li> <li>一个没有捕获变量的 lambda 函数, 可以显式转换成函数指针：</li></ul> <p>参考<a href="https://cloud.tencent.com/developer/article/2007300" target="_blank" rel="noopener noreferrer">资料<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="如果一个-lambda-表达式作为参数传递给一个函数-那这个函数可以使用这个-lambda-表达式捕获的变量吗「旷视」"><a href="#如果一个-lambda-表达式作为参数传递给一个函数-那这个函数可以使用这个-lambda-表达式捕获的变量吗「旷视」" class="header-anchor">#</a> 如果一个 lambda 表达式作为参数传递给一个函数，那这个函数可以使用这个 lambda 表达式捕获的变量吗「旷视」</h2> <p>在这个程序中，变量 <code>y</code> 是在 lambda 表达式中被捕获的，因此它只能在 lambda 表达式的<strong>作用域</strong>内使用。如果我们尝试在 <code>print_result</code> 函数中访问 <code>y</code>，将会导致编译错误。</p> <p>在 C++ 中，当我们将一个 lambda 表达式作为参数传递给一个函数时，lambda 表达式中捕获的变量==只能在 <strong>lambda 表达式内部访问</strong>==。如果我们需要在调用该函数时将 lambda 表达式中的变量值传递给函数的其他参数，我们需要将它们显式地传递给该函数。</p> <p>如下</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">print_result</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> func<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Input: &quot;</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Result: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  <span class="token comment">//std::cout &lt;&lt; &quot;y=&quot;&lt;&lt; y &lt;&lt;std::endl;这行不能写，不然会错误</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token function">print_result</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> y <span class="token operator">*</span> z<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="那么反过来呢"><a href="#那么反过来呢" class="header-anchor">#</a> 那么反过来呢？</h2> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">test_lambda</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> my_lambda <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;a = &quot;</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, b = &quot;</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">my_lambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">test_lambda</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>验证 lambda 表达式在函数中的捕获变量的行为：在这个示例中，我们定义了一个名为 <code>test_lambda</code> 的函数，该函数接受一个整数参数 <code>a</code>，并在函数内部定义了另一个整数变量 <code>b</code>。然后，我们定义了一个 lambda 表达式 <code>my_lambda</code>，它捕获了 <code>a</code> 和 <code>b</code> 两个变量，并在 lambda 表达式内部打印这些变量的值。最后，我们在 <code>test_lambda</code> 函数中调用了 <code>my_lambda</code>。</p> <p>表明 lambda 表达式可以访问和使用它所捕获的变量。在这个例子中，lambda 表达式使用了<strong>函数参数 <code>a</code></strong> 和<strong>函数内部定义的变量</strong> <code>b</code>，并且输出了它们的值</p> <h2 id="🔋-参考资料"><a href="#🔋-参考资料" class="header-anchor">#</a> 🔋 参考资料</h2> <ul><li>孟岩<a href="https://blog.csdn.net/myan" target="_blank" rel="noopener noreferrer">在CSDN上的博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>《Linux多线程服务端编程》，陈硕</li> <li>光城，<a href="https://light-city.club/sc/" target="_blank" rel="noopener noreferrer">C++那些事<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>重要网站：『<a href="https://www.stroustrup.com/bs_faq2.html#virtual-ctor" target="_blank" rel="noopener noreferrer">Bjarne Stroustrup's C++ Style and Technique FAQ<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>』
<ul><li><a href="https://www.stroustrup.com/bs_faq2.html#virtual-ctor" target="_blank" rel="noopener noreferrer">https://www.stroustrup.com/bs_faq2.html#virtual-ctor<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f308a922.js" defer></script><script src="/assets/js/2.443c6f9e.js" defer></script><script src="/assets/js/46.08940884.js" defer></script>
  </body>
</html>
