<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++核心详解 | whoway</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/images/photo.jpg">
    <link rel="manifest" href="/images/photo.jpg">
    <link rel="apple-touch-icon" href="/images/photo.jpg">
    <meta name="description" content="Personal Blog Website">
    <meta http-quiv="pragma" cotent="no-cache">
    <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
    <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.e8e4f3a3.css" as="style"><link rel="preload" href="/assets/js/app.b7604e5b.js" as="script"><link rel="preload" href="/assets/js/2.443c6f9e.js" as="script"><link rel="preload" href="/assets/js/3.aa43f56f.js" as="script"><link rel="prefetch" href="/assets/js/10.564ba24d.js"><link rel="prefetch" href="/assets/js/100.2ebdba45.js"><link rel="prefetch" href="/assets/js/101.6a7d2a75.js"><link rel="prefetch" href="/assets/js/102.75571ccf.js"><link rel="prefetch" href="/assets/js/103.27f85c5f.js"><link rel="prefetch" href="/assets/js/104.b49f3562.js"><link rel="prefetch" href="/assets/js/105.55722df3.js"><link rel="prefetch" href="/assets/js/106.4febf552.js"><link rel="prefetch" href="/assets/js/107.466f75db.js"><link rel="prefetch" href="/assets/js/108.7dce91c1.js"><link rel="prefetch" href="/assets/js/109.7653e57f.js"><link rel="prefetch" href="/assets/js/11.d3f4ebcf.js"><link rel="prefetch" href="/assets/js/110.8d237041.js"><link rel="prefetch" href="/assets/js/111.aedc587c.js"><link rel="prefetch" href="/assets/js/112.77a8d2e8.js"><link rel="prefetch" href="/assets/js/113.be14b056.js"><link rel="prefetch" href="/assets/js/114.cdc44fe7.js"><link rel="prefetch" href="/assets/js/115.72fb48af.js"><link rel="prefetch" href="/assets/js/116.e2543774.js"><link rel="prefetch" href="/assets/js/117.f7246ebf.js"><link rel="prefetch" href="/assets/js/118.c76f8bf6.js"><link rel="prefetch" href="/assets/js/119.45591954.js"><link rel="prefetch" href="/assets/js/12.4349f2c1.js"><link rel="prefetch" href="/assets/js/120.412903b7.js"><link rel="prefetch" href="/assets/js/121.722dd678.js"><link rel="prefetch" href="/assets/js/122.4e6f6daa.js"><link rel="prefetch" href="/assets/js/123.86727329.js"><link rel="prefetch" href="/assets/js/124.50c73eb7.js"><link rel="prefetch" href="/assets/js/125.2a66403c.js"><link rel="prefetch" href="/assets/js/126.322a960a.js"><link rel="prefetch" href="/assets/js/127.d41425dd.js"><link rel="prefetch" href="/assets/js/128.8301ecd7.js"><link rel="prefetch" href="/assets/js/129.ab6fdd31.js"><link rel="prefetch" href="/assets/js/13.25838ded.js"><link rel="prefetch" href="/assets/js/130.a7162308.js"><link rel="prefetch" href="/assets/js/131.41ec22ef.js"><link rel="prefetch" href="/assets/js/132.b400684c.js"><link rel="prefetch" href="/assets/js/133.003bc28c.js"><link rel="prefetch" href="/assets/js/134.0f6eeac8.js"><link rel="prefetch" href="/assets/js/135.5fda8606.js"><link rel="prefetch" href="/assets/js/136.e2e84beb.js"><link rel="prefetch" href="/assets/js/137.64174c48.js"><link rel="prefetch" href="/assets/js/138.30e82718.js"><link rel="prefetch" href="/assets/js/139.a9df2326.js"><link rel="prefetch" href="/assets/js/14.492747a7.js"><link rel="prefetch" href="/assets/js/140.40d122e3.js"><link rel="prefetch" href="/assets/js/141.9d2bf7ad.js"><link rel="prefetch" href="/assets/js/142.cb8e7ebe.js"><link rel="prefetch" href="/assets/js/143.50f1f158.js"><link rel="prefetch" href="/assets/js/144.41ae6c1a.js"><link rel="prefetch" href="/assets/js/145.212fdadc.js"><link rel="prefetch" href="/assets/js/146.63b9b18e.js"><link rel="prefetch" href="/assets/js/147.dc24d218.js"><link rel="prefetch" href="/assets/js/148.37d24ad0.js"><link rel="prefetch" href="/assets/js/149.0d8f8dd0.js"><link rel="prefetch" href="/assets/js/15.92fda6fa.js"><link rel="prefetch" href="/assets/js/150.94277dfa.js"><link rel="prefetch" href="/assets/js/151.3df13eb7.js"><link rel="prefetch" href="/assets/js/152.4e8fe968.js"><link rel="prefetch" href="/assets/js/153.ad545d78.js"><link rel="prefetch" href="/assets/js/154.4a6fa382.js"><link rel="prefetch" href="/assets/js/155.1a78a587.js"><link rel="prefetch" href="/assets/js/156.b27c6ebf.js"><link rel="prefetch" href="/assets/js/157.dfd440c0.js"><link rel="prefetch" href="/assets/js/158.23f0ef83.js"><link rel="prefetch" href="/assets/js/159.7ef31469.js"><link rel="prefetch" href="/assets/js/16.d24af773.js"><link rel="prefetch" href="/assets/js/160.4ab131cc.js"><link rel="prefetch" href="/assets/js/161.58a6051f.js"><link rel="prefetch" href="/assets/js/162.6b175aba.js"><link rel="prefetch" href="/assets/js/163.7a8a079f.js"><link rel="prefetch" href="/assets/js/164.1da7d96e.js"><link rel="prefetch" href="/assets/js/165.de8cdd95.js"><link rel="prefetch" href="/assets/js/166.4d66bdf1.js"><link rel="prefetch" href="/assets/js/167.9e20095b.js"><link rel="prefetch" href="/assets/js/168.ae386c3f.js"><link rel="prefetch" href="/assets/js/169.c3fc0944.js"><link rel="prefetch" href="/assets/js/17.6c788e13.js"><link rel="prefetch" href="/assets/js/170.23b1f319.js"><link rel="prefetch" href="/assets/js/171.38dbb172.js"><link rel="prefetch" href="/assets/js/172.efcdbdaf.js"><link rel="prefetch" href="/assets/js/173.d252e347.js"><link rel="prefetch" href="/assets/js/174.e6cf64a9.js"><link rel="prefetch" href="/assets/js/175.6c78c61c.js"><link rel="prefetch" href="/assets/js/176.14513d1d.js"><link rel="prefetch" href="/assets/js/177.779323b7.js"><link rel="prefetch" href="/assets/js/178.5773ac63.js"><link rel="prefetch" href="/assets/js/179.61f21be1.js"><link rel="prefetch" href="/assets/js/18.873a8359.js"><link rel="prefetch" href="/assets/js/180.e73d03a9.js"><link rel="prefetch" href="/assets/js/181.84f5367e.js"><link rel="prefetch" href="/assets/js/182.dd084367.js"><link rel="prefetch" href="/assets/js/183.9541d2fc.js"><link rel="prefetch" href="/assets/js/184.1f899d50.js"><link rel="prefetch" href="/assets/js/185.46799590.js"><link rel="prefetch" href="/assets/js/186.b30df7c9.js"><link rel="prefetch" href="/assets/js/187.c8fcc019.js"><link rel="prefetch" href="/assets/js/188.634a0124.js"><link rel="prefetch" href="/assets/js/189.e2be2f2f.js"><link rel="prefetch" href="/assets/js/19.ee2c88d0.js"><link rel="prefetch" href="/assets/js/190.d637ee53.js"><link rel="prefetch" href="/assets/js/191.3eeae49a.js"><link rel="prefetch" href="/assets/js/192.7c6e424b.js"><link rel="prefetch" href="/assets/js/193.656bada0.js"><link rel="prefetch" href="/assets/js/194.5b913ada.js"><link rel="prefetch" href="/assets/js/195.c0e57251.js"><link rel="prefetch" href="/assets/js/196.a3043fe5.js"><link rel="prefetch" href="/assets/js/197.c1a14633.js"><link rel="prefetch" href="/assets/js/198.9fd1955e.js"><link rel="prefetch" href="/assets/js/199.426bbffa.js"><link rel="prefetch" href="/assets/js/20.39da0aac.js"><link rel="prefetch" href="/assets/js/200.e050cd06.js"><link rel="prefetch" href="/assets/js/201.b74358b2.js"><link rel="prefetch" href="/assets/js/202.0036d6a2.js"><link rel="prefetch" href="/assets/js/203.203cfc84.js"><link rel="prefetch" href="/assets/js/204.87d8130b.js"><link rel="prefetch" href="/assets/js/205.83be4756.js"><link rel="prefetch" href="/assets/js/206.c08749f8.js"><link rel="prefetch" href="/assets/js/207.af9964c7.js"><link rel="prefetch" href="/assets/js/208.9bfa460b.js"><link rel="prefetch" href="/assets/js/209.8e69dd8f.js"><link rel="prefetch" href="/assets/js/21.edd943cc.js"><link rel="prefetch" href="/assets/js/210.ba52cf79.js"><link rel="prefetch" href="/assets/js/211.6ba75e73.js"><link rel="prefetch" href="/assets/js/212.560c9624.js"><link rel="prefetch" href="/assets/js/213.ff5d0b35.js"><link rel="prefetch" href="/assets/js/214.23648a33.js"><link rel="prefetch" href="/assets/js/215.3b678a3c.js"><link rel="prefetch" href="/assets/js/216.839e9301.js"><link rel="prefetch" href="/assets/js/217.89659726.js"><link rel="prefetch" href="/assets/js/218.1aacedde.js"><link rel="prefetch" href="/assets/js/219.8ef45f86.js"><link rel="prefetch" href="/assets/js/22.1101d3a0.js"><link rel="prefetch" href="/assets/js/220.97a992d0.js"><link rel="prefetch" href="/assets/js/221.0426b24f.js"><link rel="prefetch" href="/assets/js/222.de58c422.js"><link rel="prefetch" href="/assets/js/223.f013c481.js"><link rel="prefetch" href="/assets/js/224.6f91b728.js"><link rel="prefetch" href="/assets/js/225.f5dd93ef.js"><link rel="prefetch" href="/assets/js/226.db3d9e37.js"><link rel="prefetch" href="/assets/js/227.fb2b2fad.js"><link rel="prefetch" href="/assets/js/228.3abdba44.js"><link rel="prefetch" href="/assets/js/229.47dd6a81.js"><link rel="prefetch" href="/assets/js/23.1c64ff44.js"><link rel="prefetch" href="/assets/js/230.0f6b4a72.js"><link rel="prefetch" href="/assets/js/231.1af884f0.js"><link rel="prefetch" href="/assets/js/232.9fe68501.js"><link rel="prefetch" href="/assets/js/233.7a0cafbf.js"><link rel="prefetch" href="/assets/js/234.4e14c78c.js"><link rel="prefetch" href="/assets/js/24.f57a24cc.js"><link rel="prefetch" href="/assets/js/25.6c1f3e52.js"><link rel="prefetch" href="/assets/js/26.fff5042b.js"><link rel="prefetch" href="/assets/js/27.fb2ac419.js"><link rel="prefetch" href="/assets/js/28.2e15dac9.js"><link rel="prefetch" href="/assets/js/29.9f14ff8d.js"><link rel="prefetch" href="/assets/js/30.2ff65a58.js"><link rel="prefetch" href="/assets/js/31.388bee23.js"><link rel="prefetch" href="/assets/js/32.2bdd0898.js"><link rel="prefetch" href="/assets/js/33.92037cd2.js"><link rel="prefetch" href="/assets/js/34.2b9377f8.js"><link rel="prefetch" href="/assets/js/35.e6469324.js"><link rel="prefetch" href="/assets/js/36.20267bfe.js"><link rel="prefetch" href="/assets/js/37.738ddf6b.js"><link rel="prefetch" href="/assets/js/38.6e536ad3.js"><link rel="prefetch" href="/assets/js/39.356955ac.js"><link rel="prefetch" href="/assets/js/4.ed2516f6.js"><link rel="prefetch" href="/assets/js/40.b210e6fc.js"><link rel="prefetch" href="/assets/js/41.dc08fc34.js"><link rel="prefetch" href="/assets/js/42.71d97baf.js"><link rel="prefetch" href="/assets/js/43.25c6b21a.js"><link rel="prefetch" href="/assets/js/44.18c4ae8f.js"><link rel="prefetch" href="/assets/js/45.4c20a706.js"><link rel="prefetch" href="/assets/js/46.08940884.js"><link rel="prefetch" href="/assets/js/47.0059baec.js"><link rel="prefetch" href="/assets/js/48.3fb2f49e.js"><link rel="prefetch" href="/assets/js/49.bf896a48.js"><link rel="prefetch" href="/assets/js/5.ec3b3bef.js"><link rel="prefetch" href="/assets/js/50.6c254d4b.js"><link rel="prefetch" href="/assets/js/51.f15ecdc3.js"><link rel="prefetch" href="/assets/js/52.02b61012.js"><link rel="prefetch" href="/assets/js/53.2c15cd80.js"><link rel="prefetch" href="/assets/js/54.7f112769.js"><link rel="prefetch" href="/assets/js/55.34e2f37a.js"><link rel="prefetch" href="/assets/js/56.fe1bb9e6.js"><link rel="prefetch" href="/assets/js/57.205e9911.js"><link rel="prefetch" href="/assets/js/58.9ce60b3f.js"><link rel="prefetch" href="/assets/js/59.8f15a6cc.js"><link rel="prefetch" href="/assets/js/6.a31d63d5.js"><link rel="prefetch" href="/assets/js/60.d7957113.js"><link rel="prefetch" href="/assets/js/61.ef61c216.js"><link rel="prefetch" href="/assets/js/62.87a781f9.js"><link rel="prefetch" href="/assets/js/63.54dd9a1b.js"><link rel="prefetch" href="/assets/js/64.8e57e0b3.js"><link rel="prefetch" href="/assets/js/65.f26ae1aa.js"><link rel="prefetch" href="/assets/js/66.314e62f6.js"><link rel="prefetch" href="/assets/js/67.84bd37fd.js"><link rel="prefetch" href="/assets/js/68.31894d6a.js"><link rel="prefetch" href="/assets/js/69.d05b524b.js"><link rel="prefetch" href="/assets/js/7.5722c9b9.js"><link rel="prefetch" href="/assets/js/70.48eb7200.js"><link rel="prefetch" href="/assets/js/71.4f4b0093.js"><link rel="prefetch" href="/assets/js/72.54d5f4b1.js"><link rel="prefetch" href="/assets/js/73.4a5743f6.js"><link rel="prefetch" href="/assets/js/74.febacc20.js"><link rel="prefetch" href="/assets/js/75.e4ea311c.js"><link rel="prefetch" href="/assets/js/76.bd56aeb5.js"><link rel="prefetch" href="/assets/js/77.afa5d5d0.js"><link rel="prefetch" href="/assets/js/78.556d3a72.js"><link rel="prefetch" href="/assets/js/79.440bb5d8.js"><link rel="prefetch" href="/assets/js/8.43a034a5.js"><link rel="prefetch" href="/assets/js/80.1cb75bfe.js"><link rel="prefetch" href="/assets/js/81.d58331f2.js"><link rel="prefetch" href="/assets/js/82.f595c5af.js"><link rel="prefetch" href="/assets/js/83.df6e8e34.js"><link rel="prefetch" href="/assets/js/84.d8b04a52.js"><link rel="prefetch" href="/assets/js/85.42cca0b9.js"><link rel="prefetch" href="/assets/js/86.929cb693.js"><link rel="prefetch" href="/assets/js/87.187f4b29.js"><link rel="prefetch" href="/assets/js/88.277f0f52.js"><link rel="prefetch" href="/assets/js/89.69f556b0.js"><link rel="prefetch" href="/assets/js/9.9b2f61c2.js"><link rel="prefetch" href="/assets/js/90.6b7ceb51.js"><link rel="prefetch" href="/assets/js/91.35ee6d03.js"><link rel="prefetch" href="/assets/js/92.ffd42f17.js"><link rel="prefetch" href="/assets/js/93.6f13703b.js"><link rel="prefetch" href="/assets/js/94.a13aa616.js"><link rel="prefetch" href="/assets/js/95.d84a1da6.js"><link rel="prefetch" href="/assets/js/96.b9ca323f.js"><link rel="prefetch" href="/assets/js/97.5e7b5df5.js"><link rel="prefetch" href="/assets/js/98.4d93a866.js"><link rel="prefetch" href="/assets/js/99.e6aa9e67.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e8e4f3a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">whoway</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎓Coding" class="dropdown-title"><span class="title">🎓Coding</span> <span class="arrow down"></span></button> <button type="button" aria-label="🎓Coding" class="mobile-dropdown-title"><span class="title">🎓Coding</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/00.Coding/TheBeautyOfProgramming/" class="nav-link">
  🔖编程之美题解
</a></li><li class="dropdown-item"><!----> <a href="/00.Coding/CodeWarehouse/" class="nav-link">
  🔖代码意识流
</a></li><li class="dropdown-item"><!----> <a href="/00.Coding/" class="nav-link">
  🔖面试题题解
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🚀语言" class="dropdown-title"><span class="title">🚀语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="🚀语言" class="mobile-dropdown-title"><span class="title">🚀语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/01.Language/Overview/" class="nav-link">
  🔖概述
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/C/" class="nav-link">
  ⭐️C
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Cpp/" class="nav-link router-link-active">
  🚀C++
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Java/" class="nav-link">
  ☕️Java
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Python/" class="nav-link">
  🧩Python3
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Fortran/" class="nav-link">
  🎲Fortran
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/JavaScript/" class="nav-link">
  🎨JavaScript
</a></li></ul></div></div><div class="nav-item"><a href="/02.Hardware/" class="nav-link">
  ✔️硬件基础
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="⭐️软件基础" class="dropdown-title"><span class="title">⭐️软件基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="⭐️软件基础" class="mobile-dropdown-title"><span class="title">⭐️软件基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/03.Software/01.DataStructureAndAlgorithm/" class="nav-link">
  🐾数据结构和算法
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/02.server/" class="nav-link">
  🎨server
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/03.Database/" class="nav-link">
  🔖数据库
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/04.SE/" class="nav-link">
  ✅软件工程
</a></li></ul></div></div><div class="nav-item"><a href="/04.PerformanceOpt/" class="nav-link">
  🔥性能调优
</a></div><div class="nav-item"><a href="/05.Engineer/" class="nav-link">
  🔖学术/工程
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="⚙️工具" class="dropdown-title"><span class="title">⚙️工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="⚙️工具" class="mobile-dropdown-title"><span class="title">⚙️工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/06.Tools/01.employment/" class="nav-link">
  🔖求职
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/02.efficiency/" class="nav-link">
  🚀效能
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/03.windows/" class="nav-link">
  ⚙️Windows
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/04.design/" class="nav-link">
  🧩设计
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/whoway" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎓Coding" class="dropdown-title"><span class="title">🎓Coding</span> <span class="arrow down"></span></button> <button type="button" aria-label="🎓Coding" class="mobile-dropdown-title"><span class="title">🎓Coding</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/00.Coding/TheBeautyOfProgramming/" class="nav-link">
  🔖编程之美题解
</a></li><li class="dropdown-item"><!----> <a href="/00.Coding/CodeWarehouse/" class="nav-link">
  🔖代码意识流
</a></li><li class="dropdown-item"><!----> <a href="/00.Coding/" class="nav-link">
  🔖面试题题解
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🚀语言" class="dropdown-title"><span class="title">🚀语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="🚀语言" class="mobile-dropdown-title"><span class="title">🚀语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/01.Language/Overview/" class="nav-link">
  🔖概述
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/C/" class="nav-link">
  ⭐️C
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Cpp/" class="nav-link router-link-active">
  🚀C++
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Java/" class="nav-link">
  ☕️Java
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Python/" class="nav-link">
  🧩Python3
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/Fortran/" class="nav-link">
  🎲Fortran
</a></li><li class="dropdown-item"><!----> <a href="/01.Language/JavaScript/" class="nav-link">
  🎨JavaScript
</a></li></ul></div></div><div class="nav-item"><a href="/02.Hardware/" class="nav-link">
  ✔️硬件基础
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="⭐️软件基础" class="dropdown-title"><span class="title">⭐️软件基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="⭐️软件基础" class="mobile-dropdown-title"><span class="title">⭐️软件基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/03.Software/01.DataStructureAndAlgorithm/" class="nav-link">
  🐾数据结构和算法
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/02.server/" class="nav-link">
  🎨server
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/03.Database/" class="nav-link">
  🔖数据库
</a></li><li class="dropdown-item"><!----> <a href="/03.Software/04.SE/" class="nav-link">
  ✅软件工程
</a></li></ul></div></div><div class="nav-item"><a href="/04.PerformanceOpt/" class="nav-link">
  🔥性能调优
</a></div><div class="nav-item"><a href="/05.Engineer/" class="nav-link">
  🔖学术/工程
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="⚙️工具" class="dropdown-title"><span class="title">⚙️工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="⚙️工具" class="mobile-dropdown-title"><span class="title">⚙️工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/06.Tools/01.employment/" class="nav-link">
  🔖求职
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/02.efficiency/" class="nav-link">
  🚀效能
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/03.windows/" class="nav-link">
  ⚙️Windows
</a></li><li class="dropdown-item"><!----> <a href="/06.Tools/04.design/" class="nav-link">
  🧩设计
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/whoway" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++核心详解</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#📑-目录" class="sidebar-link">📑 目录</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#✅『oob』基于对象的程序设计" class="sidebar-link">✅『OOB』基于对象的程序设计</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_1-对比class-struct-union和enum" class="sidebar-link">1.对比class/struct/union和enum</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_1-1-class" class="sidebar-link">1.1.class</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_1-2-struct『c-中』" class="sidebar-link">1.2.struct『C++中』</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_1-3-union『c-中』" class="sidebar-link">1.3.union『C++中』</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_1-4-enum『只有它不是特殊的类』" class="sidebar-link">1.4.enum『只有它不是特殊的类』</a></li></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_2-类的『成员变量』和『非成员变量』⭐️" class="sidebar-link">2.类的『成员变量』和『非成员变量』⭐️</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_2-1-成员变量" class="sidebar-link">2.1.成员变量</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_2-2-非成员变量" class="sidebar-link">2.2.非成员变量</a></li></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_3-类的『成员函数』和『非成员函数』⭐️" class="sidebar-link">3.类的『成员函数』和『非成员函数』⭐️</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_3-1-成员函数" class="sidebar-link">3.1.成员函数</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_3-2-非成员函数" class="sidebar-link">3.2.非成员函数</a></li></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_4-big-three讲解" class="sidebar-link">4.Big Three讲解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_4-1-构造函数详解" class="sidebar-link">4.1.构造函数详解</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_4-2-析构函数详解" class="sidebar-link">4.2.析构函数详解</a></li></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_5-访问属性" class="sidebar-link">5.访问属性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_5-1-内部访问和对象访问" class="sidebar-link">5.1.内部访问和对象访问</a></li></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_6-namespace命名空间" class="sidebar-link">6.namespace命名空间</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_7-其余" class="sidebar-link">7.其余</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#✅『oop』面向对象的程序设计" class="sidebar-link">✅『OOP』面向对象的程序设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_1-1-类型转换函数-类型转换函数-不等于-类型转换构造函数" class="sidebar-link">1.1.类型转换函数(类型转换函数-不等于-类型转换构造函数)</a></li></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_1-辨析overload、override、overwrite⭐️『已解决』" class="sidebar-link">1.辨析Overload、Override、Overwrite⭐️『已解决』</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#✅区分overload、overwrite和override" class="sidebar-link">✅区分Overload、Overwrite和Override</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#同一个class里面的成员函数加-不加virtual算不算重载" class="sidebar-link">同一个class里面的成员函数加/不加virtual算不算重载？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#那下面这样的叫什么" class="sidebar-link">那下面这样的叫什么？</a></li></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_2-多态与虚函数" class="sidebar-link">2.多态与虚函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_2-1-static变量的说明" class="sidebar-link">2.1.static变量的说明</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_2-2-虚函数相关" class="sidebar-link">2.2.虚函数相关</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_2-2-虚函数能不能inline" class="sidebar-link">2.2.虚函数能不能inline</a></li></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_3-『多态神器』-多态3条件" class="sidebar-link">3.『多态神器』-多态3条件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_3-1-条件1和条件2❎『非多态』" class="sidebar-link">3.1.条件1和条件2❎『非多态』</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_3-2-条件3❎『非多态』" class="sidebar-link">3.2.条件3❎『非多态』</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_3-3-虚析构函数" class="sidebar-link">3.3.虚析构函数</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_3-4-『添加作用域的调用』" class="sidebar-link">3.4.『添加作用域的调用』</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_3-5-静态绑定的核心理解『易错难点』⭐️" class="sidebar-link">3.5.静态绑定的核心理解『易错难点』⭐️</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#✅上面是难点" class="sidebar-link">✅上面是难点</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_3-6-const对象" class="sidebar-link">3.6.const对象</a></li></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_4-构造函数-ctor-和析构函数-dtor-相关⭐️" class="sidebar-link">4.构造函数（ctor）和析构函数（dtor）相关⭐️</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_4-1-c-构造函数和析构函数可以是虚函数嘛" class="sidebar-link">4.1.C++ 构造函数和析构函数可以是虚函数嘛？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_4-2-构造函数中调用虚函数会怎么样" class="sidebar-link">4.2.构造函数中调用虚函数会怎么样？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_4-3-析构函数中调用虚函数会怎么样" class="sidebar-link">4.3.析构函数中调用虚函数会怎么样？</a></li></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#⭐️4-『运算符重载』详解" class="sidebar-link">⭐️4.『运算符重载』详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_4-1-重载的2种函数类型" class="sidebar-link">4.1.重载的2种函数类型</a></li></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#谈一谈null-0-nullptr" class="sidebar-link">谈一谈NULL，0，nullptr</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#✅杂谈" class="sidebar-link">✅杂谈</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_1-常量表达式" class="sidebar-link">1.常量表达式</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_2-c-98关键字" class="sidebar-link">2.C++98关键字</a></li></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#✅常识-非面试" class="sidebar-link">✅常识-非面试</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_1-区分c-和c" class="sidebar-link">1.区分C++和C</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#如果使用brk-c-堆内存为什么不连续" class="sidebar-link">如果使用brk(). C++：堆内存为什么不连续？</a></li></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#引申问题-由new和仅在class上的对象或仅在stack上的对象-⭐️" class="sidebar-link">引申问题-由new和仅在class上的对象或仅在stack上的对象！⭐️</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_1-如何定义1个『只能』在『堆』上生成对象的类" class="sidebar-link">1.如何定义1个『只能』在『堆』上生成对象的类？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#_2-如何定义1个『只能』在『栈』上生成对象的class" class="sidebar-link">2.如何定义1个『只能』在『栈』上生成对象的class？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#追问-c-中-为了让某个class只能通过new来创建-那malloc为啥不可以" class="sidebar-link">追问：C++中，为了让某个class只能通过new来创建？那malloc为啥不可以？</a></li><li class="sidebar-sub-header"><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#追问-那c-里面的strcut也是只能用new-不能用malloc吗" class="sidebar-link">追问：那C++里面的strcut也是只能用new，不能用malloc吗？</a></li></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#c-如何实现多态" class="sidebar-link">C++如何实现多态？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#静态函数可以加virtual吗" class="sidebar-link">静态函数可以加virtual吗？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#new是线程安全的吗" class="sidebar-link">new是线程安全的吗？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/01.Language/Cpp/01.C++98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#gdb如何调试多线程" class="sidebar-link">gdb如何调试多线程？</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="c-核心详解"><a href="#c-核心详解" class="header-anchor">#</a> C++核心详解</h1> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>&lt;font style=&quot;background:pink&quot;&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>学C++的利器：</p> <ul><li>this指针不是object的一部分</li> <li>虚函数表属于class
<ul><li>每个object有属于各自的<strong>虚函数表指针</strong></li></ul></li> <li>静态绑定和动态绑定</li> <li>内存管理</li> <li>《STL源码剖析》</li></ul> <h2 id="📑-目录"><a href="#📑-目录" class="header-anchor">#</a> 📑 目录</h2> <p></p><div class="table-of-contents"><ul><li><a href="#📑-目录">📑 目录</a></li><li><a href="#✅『oob』基于对象的程序设计">✅『OOB』基于对象的程序设计</a></li><li><a href="#_1-对比-class-struct-union-和-enum">1.对比class/struct/union和enum</a><ul><li><a href="#_1-1-class">1.1.class</a></li><li><a href="#_1-2-struct-『c-中』">1.2.struct『C++中』</a></li><li><a href="#_1-3-union-『c-中』">1.3.union『C++中』</a></li><li><a href="#_1-4-enum-『只有它不是特殊的类』">1.4.enum『只有它不是特殊的类』</a></li></ul></li><li><a href="#_2-类的『成员变量』和『非成员变量』⭐️">2.类的『成员变量』和『非成员变量』⭐️</a><ul><li><a href="#_2-1-成员变量">2.1.成员变量</a></li><li><a href="#_2-2-非成员变量">2.2.非成员变量</a></li></ul></li><li><a href="#_3-类的『成员函数』和『非成员函数』⭐️">3.类的『成员函数』和『非成员函数』⭐️</a><ul><li><a href="#_3-1-成员函数">3.1.成员函数</a></li><li><a href="#_3-2-非成员函数">3.2.非成员函数</a></li></ul></li><li><a href="#_4-big-three-讲解">4.Big Three讲解</a><ul><li><a href="#_4-1-构造函数详解">4.1.构造函数详解</a></li><li><a href="#_4-2-析构函数详解">4.2.析构函数详解</a></li></ul></li><li><a href="#_5-访问属性">5.访问属性</a><ul><li><a href="#_5-1-内部访问和对象访问">5.1.内部访问和对象访问</a></li></ul></li><li><a href="#_6-namespace-命名空间">6.namespace命名空间</a></li><li><a href="#_7-其余">7.其余</a></li><li><a href="#✅『oop』面向对象的程序设计">✅『OOP』面向对象的程序设计</a><ul><li><a href="#_1-1-类型转换函数-类型转换函数-不等于-类型转换构造函数">1.1.类型转换函数(类型转换函数-不等于-类型转换构造函数)</a></li></ul></li><li><a href="#_1-辨析overload、override、overwrite⭐️『已解决』">1.辨析Overload、Override、Overwrite⭐️『已解决』</a><ul><li><a href="#✅区分overload、overwrite和override">✅区分Overload、Overwrite和Override</a></li><li><a href="#同一个class里面的成员函数加-不加virtual算不算重载">同一个class里面的成员函数加/不加virtual算不算重载？</a></li><li><a href="#那下面这样的叫什么">那下面这样的叫什么？</a></li></ul></li><li><a href="#_2-多态与虚函数">2.多态与虚函数</a><ul><li><a href="#_2-1-static-变量的说明">2.1.static变量的说明</a></li><li><a href="#_2-2-虚函数相关">2.2.虚函数相关</a></li><li><a href="#_2-2-虚函数能不能inline">2.2.虚函数能不能inline</a></li></ul></li><li><a href="#_3-『多态神器』-多态3条件">3.『多态神器』-多态3条件</a><ul><li><a href="#_3-1-条件1和条件2❎『非多态』">3.1.条件1和条件2❎『非多态』</a></li><li><a href="#_3-2-条件3❎『非多态』">3.2.条件3❎『非多态』</a></li><li><a href="#_3-3-虚析构函数">3.3.虚析构函数</a></li><li><a href="#_3-4-『添加作用域的调用』">3.4.『添加作用域的调用』</a></li><li><a href="#_3-5-静态绑定的核心理解『易错难点』⭐️">3.5.静态绑定的核心理解『易错难点』⭐️</a></li><li><a href="#✅上面是难点">✅上面是难点</a></li><li><a href="#_3-6-const对象">3.6.const对象</a></li></ul></li><li><a href="#_4-构造函数-ctor-和析构函数-dtor-相关⭐️">4.构造函数（ctor）和析构函数（dtor）相关⭐️</a><ul><li><a href="#_4-1-c-构造函数和析构函数可以是虚函数嘛">4.1.C++ 构造函数和析构函数可以是虚函数嘛？</a></li><li><a href="#_4-2-构造函数中调用虚函数会怎么样">4.2.构造函数中调用虚函数会怎么样？</a></li><li><a href="#_4-3-析构函数中调用虚函数会怎么样">4.3.析构函数中调用虚函数会怎么样？</a></li></ul></li><li><a href="#⭐️4-『运算符重载』详解">⭐️4.『运算符重载』详解</a><ul><li><a href="#_4-1-重载的2种函数类型">4.1.重载的2种函数类型</a></li></ul></li><li><a href="#谈一谈null-0-nullptr">谈一谈NULL，0，nullptr</a></li><li><a href="#✅杂谈">✅杂谈</a><ul><li><a href="#_1-常量表达式">1.常量表达式</a></li><li><a href="#_2-c-98关键字">2.C++98关键字</a></li></ul></li><li><a href="#✅常识-非面试">✅常识-非面试</a><ul><li><a href="#_1-区分c-和c">1.区分C++和C</a></li><li><a href="#如果使用brk-c-堆内存为什么不连续">如果使用brk(). C++：堆内存为什么不连续？</a></li></ul></li><li><a href="#引申问题-由new和仅在class上的对象或仅在stack上的对象-⭐️">引申问题-由new和仅在class上的对象或仅在stack上的对象！⭐️</a><ul><li><a href="#_1-如何定义1个『只能』在『堆』上生成对象的类">1.如何定义1个『只能』在『堆』上生成对象的类？</a></li><li><a href="#_2-如何定义1个『只能』在『-栈-』上生成对象的class">2.如何定义1个『只能』在『栈』上生成对象的class？</a></li><li><a href="#追问-c-中-为了让某个class只能通过new来创建-那malloc为啥不可以">追问：C++中，为了让某个class只能通过new来创建？那malloc为啥不可以？</a></li><li><a href="#追问-那c-里面的strcut也是只能用new-不能用malloc吗">追问：那C++里面的strcut也是只能用new，不能用malloc吗？</a></li></ul></li><li><a href="#c-如何实现多态">C++如何实现多态？</a></li><li><a href="#静态函数可以加virtual吗">静态函数可以加virtual吗？</a></li><li><a href="#new是线程安全的吗">new是线程安全的吗？</a></li><li><a href="#gdb如何调试多线程">gdb如何调试多线程？</a></li></ul></div><p></p> <p>[TOC]</p> <h2 id="✅『oob』基于对象的程序设计"><a href="#✅『oob』基于对象的程序设计" class="header-anchor">#</a> ✅『OOB』基于对象的程序设计</h2> <h2 id="_1-对比class-struct-union和enum"><a href="#_1-对比class-struct-union和enum" class="header-anchor">#</a> 1.对比<code>class/struct/union</code>和<code>enum</code></h2> <ul><li>class</li> <li>struct</li> <li>union</li> <li>enum『枚举类型<strong>是1种基本类型</strong>，不是1种构造类型，因为它不能再分解为任何其他基本类型，比如，<code>class</code>，<code>struct</code>，<code>union</code>』</li></ul> <h3 id="_1-1-class"><a href="#_1-1-class" class="header-anchor">#</a> 1.1.<code>class</code></h3> <p>1、继承：默认是『private继承』
2、内部可以放成员变量，成员函数，默认成员变量访问控制是：『private』
3、成员函数分类：
有』构造函数
有』析构函数
有』虚函数</p> <h3 id="_1-2-struct『c-中』"><a href="#_1-2-struct『c-中』" class="header-anchor">#</a> 1.2.<code>struct</code>『C++中』</h3> <blockquote><p>本质：<strong>是一种class</strong></p></blockquote> <p>1、继承：默认是『public继承』
2、内部可以放成员变量，成员函数，默认成员变量访问控制是：『public』
3、成员函数分类：
有』构造函数
有』析构函数
有』虚函数</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

		<span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;a=&quot;</span><span class="token operator">&lt;&lt;</span><span class="token keyword">this</span><span class="token operator">-&gt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;die AAA&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">myPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;*AAA******&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">//struct B : private A</span>
<span class="token comment">//下面的写法，等价于，struct B : public A</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span>  <span class="token base-clause"><span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> b<span class="token punctuation">;</span>
	<span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">888</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;b=&quot;</span><span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;die BBB&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">myPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;*BBBB******&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>

	<span class="token comment">//因为加上了system(&quot;pause&quot;);所以需要下面这样挂掉B，才能知道B的析构函数被调用</span>

	<span class="token punctuation">{</span>
		A one<span class="token punctuation">;</span>
		one<span class="token punctuation">.</span><span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		B two<span class="token punctuation">;</span>
		two<span class="token punctuation">.</span><span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

		A <span class="token operator">*</span> pointer<span class="token operator">=</span><span class="token keyword">new</span> B<span class="token punctuation">;</span>
		pointer<span class="token operator">-&gt;</span><span class="token function">myPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br></div></div><h3 id="_1-3-union『c-中』"><a href="#_1-3-union『c-中』" class="header-anchor">#</a> 1.3.<code>union</code>『C++中』</h3> <blockquote><p>本质：它是一种<strong>特殊的类</strong></p></blockquote> <ul><li>参考《后台开发》</li></ul> <p>1、继承：『不可以继承』继承自别人/能给别人继承都不可以
2、内部可以放成员变量，成员函数，默认成员变量访问控制是：『public』
3、成员函数分类：
有』构造函数
有』析构函数
<strong>不可以有』虚函数</strong></p> <h3 id="_1-4-enum『只有它不是特殊的类』"><a href="#_1-4-enum『只有它不是特殊的类』" class="header-anchor">#</a> 1.4.<code>enum</code>『只有它不是特殊的类』</h3> <p>1、枚举类型<strong>是1种基本类型</strong>，不是1种构造类型</p> <p>2、因为它不能再分解为任何其他基本类型『比如，<code>class</code>，<code>struct</code>，<code>union</code>』</p> <h2 id="_2-类的『成员变量』和『非成员变量』⭐️"><a href="#_2-类的『成员变量』和『非成员变量』⭐️" class="header-anchor">#</a> 2.类的『成员变量』和『非成员变量』⭐️</h2> <img src="/assets/img/成员变量和非成员变量.abeeccdf.png"> <h3 id="_2-1-成员变量"><a href="#_2-1-成员变量" class="header-anchor">#</a> 2.1.成员变量</h3> <p><strong>书中记载</strong>：</p> <ul><li>nonstatic member 非静态成员
<ul><li>普通数据成员</li> <li>const数据成员</li></ul></li> <li>static member 静态成员</li></ul> <p><strong>static成员变量</strong></p> <ul><li>c++的一个类中『<strong>声明</strong>』一个static成员变量，static是加了访问控制的全局变量，不被继承</li> <li>类和子类对象，static变量占有一份内存</li></ul> <blockquote><p>重点理解：<strong>静态成员变量的初始化一定要在『类外』</strong></p></blockquote> <p>原因： 因为静态成员变量本身在main函数未开始时已经存在。不要让成员变量的初始化依赖于对象。不用对象，难到就不能用这一变量了吗？如果将初始化放在类内。那么<strong>当不声明对象时</strong>，无法使用这一静态变量。编译器报错为‘undeclared identifier’</p> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>类中的声明和定义辨析：（重点、难点）
笔者的看法是：
1、逻辑上说明是一起，只能表示可以『声明』在一起。（声明的门槛很低）
2、具体内存在哪分配，这个决定『能不能在类内』进行『定义』

比如：
1、友元函数在『类内』声明，不能在『类内』定义，能在『类外』定义
2、static成员变量在『类内』声明，不能在『类内』定义，能在『类外』定义
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>参考自：<a href="https://www.huaweicloud.com/articles/4637f3d11eb3fd9a38e017041e23e50a.html" target="_blank" rel="noopener noreferrer">华为云<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p><strong>static和非static特点</strong></p> <ul><li>静态成员存在于<strong>内存</strong>，非静态成员需要实例化才会分配内存（注意，也就是在虚拟内存空间中，表示的是.bss和.data段中）</li> <li>非静态成员的生存期决定于该类的生存期，而静态成员生存期则与程序生命期相同</li></ul> <h3 id="_2-2-非成员变量"><a href="#_2-2-非成员变量" class="header-anchor">#</a> 2.2.非成员变量</h3> <h2 id="_3-类的『成员函数』和『非成员函数』⭐️"><a href="#_3-类的『成员函数』和『非成员函数』⭐️" class="header-anchor">#</a> 3.类的『成员函数』和『非成员函数』⭐️</h2> <img src="/assets/img/成员函数和非成员函数.18eaed6b.png"> <blockquote><p>我的<a href="http://naotu.baidu.com/file/02d2413a51829d0c29226a23718613ad?token=d83f2eb1c2d887a6" target="_blank" rel="noopener noreferrer">百度脑图<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>说明：成员函数的分类，需要考虑排序组合，<strong>是很多，很复杂</strong>的，不然就只能一个一个维度去分类。</p></blockquote> <h3 id="_3-1-成员函数"><a href="#_3-1-成员函数" class="header-anchor">#</a> 3.1.成员函数</h3> <ul><li>到底什么是成员函数？</li> <li>类的成员函数：是定义为<strong>类的一部分</strong>的函数，有时也被称为方法。（C++primer第5版，P20）</li> <li>各类函数中：构造函数、析构函数、拷贝初始化构造函数等是类的成员函数。</li> <li>成员函数分下面3类（应该说是2类，纯虚函数属于虚函数的子集的话）</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>1、非虚函数（non-virtual 函数）：
你『不希望』派生类（derived class）重新定义 (override, 复写) 它.



2、虚函数（virtual 函數）：
你希望 derived class 重新定义 (override, 复写) 它，且你对它已有『默认』定义。
3、纯虚函数（pure virtual 函數）：
你希望 derived class 『一定』要重新定义 (override 复写)
它，你对它沒有默认定义。

PS：我们把不是纯的虚函数的虚函数叫作（impure virtual函数）
PS：在语法上，我们只要在任何一个函数前面加上virtual这样一个关键字，它就成为一个虚函数。
数据可以被继承下来，就是占它用了内存。
函数的继承如何理解？但是不应该从内存角度理解，函数的继承，继承的是调用权利

PS：其实纯虚函数是可以有定义的！！
&gt; 出处：《C++Primer》中文版第五版541页第22行。
我们可以为纯虚函数提供定义，不过函数体『必须定义在类的外部』。若定义在类的内部，会出现错误：pure-specifier on function-definition。
》 虚函数是可以定义『在类的内部的』，外部也可以！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><blockquote><p>参考自：侯捷</p></blockquote> <ul><li><p><strong>override</strong>这个术语，在这个主题不能随便用！！</p></li> <li><p>这个术语，<strong>一定是用在『虚函数』被重新定义，才能够叫（override）</strong></p></li> <li><p>🐾<font style="background:yellow;">无法继承的『static成员函数』</font></p></li> <li><p><strong>纯虚函数</strong>：只提供一个<strong>接口</strong>，具体实现方法需要<strong>派生类</strong>自己去实现，纯虚函数本身不可以有实现</p></li> <li><p><strong>非虚函数</strong>：提供接口，并且强制<strong>实现</strong>方法</p></li></ul> <blockquote><p>根据《<strong>深度探索C++对象模型</strong>》一书所说：</p></blockquote> <p>原始的“C with Classes”只支持，<strong>（Nonstatic member function）非静态成员函数</strong></p> <p><strong>（Virtual function）虚函数</strong>，是在20世纪80年代中期加入进来的。</p> <p><strong>（Static member function）静态成员函数</strong>是最后被引入的一种函数类型!</p> <p>书中说道：<font style="background:pink;">C++支持3种类型的**（member function）成员函数**</font>『记住下面的』</p> <ul><li>1、static member function</li> <li>2、nonstatic member function
<ul><li>1、普通的成员函数</li> <li>2、const成员函数</li></ul></li> <li>3、virtual member function</li></ul> <p>成员函数中<strong>易错</strong>：</p> <ul><li>由于成员函数中的const成员函数，const<strong>实际</strong>上修饰的是<strong>this指针</strong>。</li> <li><font style="background:yellow;">所以<strong>在成员函数</strong>中，<strong>static</strong>和<strong>const不能同时</strong>修饰同一个成员函数</font>，因为==static成员函数<strong>没有this指针</strong>==。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">//这行没错</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">1000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
    	<span class="token comment">//修饰变量，这行却没错</span>
		<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>
  
    	<span class="token comment">//下面会出错，[Error] static member function 'static void A::demo()' cannot have cv-qualifier</span>
		<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> 
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="_3-2-非成员函数"><a href="#_3-2-非成员函数" class="header-anchor">#</a> 3.2.非成员函数</h3> <h4 id="_3-2-1-友元函数"><a href="#_3-2-1-友元函数" class="header-anchor">#</a> 3.2.1.友元函数</h4> <ul><li>注意：<font style="background:yellow;">友元函数不是类的成员函数！</font>（<strong>欢聚时代</strong>）</li></ul> <p>1、友元函数的『<strong>声明</strong>』可以放在类<strong>声明</strong>的任何地方，不受访问限定关键字private、protected、public的限制</p> <p>2、尽管友元函数的<strong>原型</strong>有在<strong>类的定义</strong>中出现过，但是<strong>友元函数并不是成员函数</strong>。</p> <p>3、友元是一种<strong>定义在类外部</strong>的普通函数（友元函数既可以在类的内部，也可以在类的外部定义《<strong>C++primer</strong>》中说了），但它需要在类体内进行<strong>说明『声明』</strong>，为了与该类的成员函数加以区别，在说明时前面加以关键字friend</p> <blockquote><p>参考自：菜鸟教程<a href="https://www.runoob.com/cplusplus/cpp-friend-functions.html" target="_blank" rel="noopener noreferrer">C++ 友元函数<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h4 id="_3-2-2-友元"><a href="#_3-2-2-友元" class="header-anchor">#</a> 3.2.2.友元</h4> <p>1、『<font style="background:yellow;">友元函数是不能被继承的</font>——解释，你父亲的朋友不能继承给你？』，<font style="background:yellow;">友元函数<strong>没有this指针</strong></font>。</p> <p>2、友元只是破坏了类的隐藏性和封装性，<font style="background:yellow;">可以直接调用，不需要通过对象或者指针</font></p> <h2 id="_4-big-three讲解"><a href="#_4-big-three讲解" class="header-anchor">#</a> 4.<code>Big Three</code>讲解</h2> <p>参考自：侯捷的说法，好像来自《C++ Primer》</p> <h3 id="_4-1-构造函数详解"><a href="#_4-1-构造函数详解" class="header-anchor">#</a> 4.1.构造函数详解</h3> <h4 id="_1-普通ctor-普通构造函数"><a href="#_1-普通ctor-普通构造函数" class="header-anchor">#</a> 1.普通ctor（普通构造函数）</h4> <ul><li>1、无参的普通构造函数</li> <li>2、<strong>有参</strong>的普通构造函数
<ul><li>（1）<strong>类型转换</strong>构造函数：只有<strong>1个参数</strong>的普通构造函数一般都可以称作『类型转换构造函数』</li> <li>（2）其他<strong>有参</strong>的普通构造函数</li></ul></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
    	
    	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//无参的『普通构造函数』</span>
  
  	
    	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token comment">//有参的『普通构造函数』，并且由于只有1个参数，也叫『类型转换构造函数』</span>
        <span class="token punctuation">{</span>
          	cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;Int Constructor calles&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
    	<span class="token function">A</span><span class="token punctuation">(</span>A <span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token comment">//拷贝构造函数，原因是参数是『本类类型的引用』</span>
        <span class="token punctuation">{</span>
            cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;Copy ctor&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
            
        <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h4 id="_2-copy-ctor"><a href="#_2-copy-ctor" class="header-anchor">#</a> 2.copy ctor</h4> <p>copy ctor又称：复制构造函数，拷贝构造函数，拷贝<strong>初始化</strong>构造函数</p> <p>分为：</p> <p>1、默认的『copy ctor』</p> <p>2、如果你自行编写了新的copy ctor，那么默认的copy ctor就不存在了</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Demo <span class="token function">c2</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//会调用copy ctor，初始化</span>

Demo c2<span class="token operator">=</span>c1<span class="token punctuation">;</span> <span class="token comment">//会调用copy ctor，注意是初始化，不是赋值！</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_4-2-析构函数详解"><a href="#_4-2-析构函数详解" class="header-anchor">#</a> 4.2.析构函数详解</h3> <h4 id="_4-2-1-有无virtual"><a href="#_4-2-1-有无virtual" class="header-anchor">#</a> 4.2.1.有无virtual</h4> <p>1、<strong>没有</strong>virtual的析构函数，又称：<strong>一般</strong>的析构函数</p> <p>2、<strong>有</strong>virtual的析构函数</p> <p>tips：析构时注意区别 <code>delete</code> 和 <code>delete[]</code></p> <h4 id="_4-2-2-是否私有"><a href="#_4-2-2-是否私有" class="header-anchor">#</a> 4.2.2.是否私有</h4> <p>在C++中，为了让某个类<strong>只能通过new来创建</strong>（即如果直接创建对象，编译器将报错）</p> <ul><li>应该将<strong>析构函数设为<font style="background:pink;">私有</font></strong></li></ul> <h2 id="_5-访问属性"><a href="#_5-访问属性" class="header-anchor">#</a> 5.访问属性</h2> <h3 id="_5-1-内部访问和对象访问"><a href="#_5-1-内部访问和对象访问" class="header-anchor">#</a> 5.1.内部访问和对象访问</h3> <p>​	类的成员有三种访问属性，分别是public、protected、private，<a href="https://www.nowcoder.com/test/question/done?tid=44308742&amp;qid=1618#summary" target="_blank" rel="noopener noreferrer">子类能够访问的成员<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是</p> <blockquote><p>参考牛客的答案：</p></blockquote> <img src="/assets/img/访问权限.ce788b0d.png"> <h2 id="_6-namespace命名空间"><a href="#_6-namespace命名空间" class="header-anchor">#</a> 6.<code>namespace</code>命名空间</h2> <p>namespace，是指标识符的各种可见范围</p> <p>C++标准程序库中的所有标识符都被定义于一个名为<code>std</code>的namespace中。</p> <p>1、<code>&lt;iostream&gt;</code>和&lt;iostream.h&gt;格式不一样，前者没有后缀，实际上，在你的编译器include文件夹里面可以看到，二者是两个文件，打开文件就会发现，里面的代码是不一样的。</p> <p>2、后缀为.h的头文件c++标准已经明确提出不支持了，早些的实现将标准库功能定义在<strong>全局空间</strong>里，声明在带.h后缀的头文件里，c++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。</p> <p>3、因此。命名空间主要是将全局空间『<strong>划分</strong>为更加小块的全局空间』</p> <h2 id="_7-其余"><a href="#_7-其余" class="header-anchor">#</a> 7.其余</h2> <p>​	1、一个基类的声明中有纯虚函数，该基类派生类一定不再是抽象类（说法错误！）</p> <p>原因：如果在派生类中<strong>没有</strong>对所有纯虚函数进行定义，则此派生类仍然是抽象类，不能用来定义对象。所以A错.</p> <p>​	2、构造函数<strong>不能</strong>被覆盖</p> <h2 id="✅『oop』面向对象的程序设计"><a href="#✅『oop』面向对象的程序设计" class="header-anchor">#</a> ✅『OOP』面向对象的程序设计</h2> <p>1、面向对象的三大基本特征：封装、继承、多态</p> <p>2、面向对象的五大基本原则：</p> <p>单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则</p> <h3 id="_1-1-类型转换函数-类型转换函数-不等于-类型转换构造函数"><a href="#_1-1-类型转换函数-类型转换函数-不等于-类型转换构造函数" class="header-anchor">#</a> 1.1.类型转换函数(类型转换函数-不等于-类型转换构造函数)</h3> <p>1、带<strong>非默认参数</strong>的构造函数可以把<strong>基本类型数据</strong>转换成类类型对象。</p> <p>2、『类型转换函数』可以把类类型对象转换为其他指定类型对象。</p> <p>3、『类型转换函数』只能定义为一个类的成员函数，<strong>不能</strong>定义为类的<strong>友元函数。</strong></p> <h2 id="_1-辨析overload、override、overwrite⭐️『已解决』"><a href="#_1-辨析overload、override、overwrite⭐️『已解决』" class="header-anchor">#</a> 1.辨析Overload、Override、Overwrite⭐️『已解决』</h2> <h4 id="_1-1-函数名称相同和重载不是一回事-比如全局函数和class里面的函数-作用域都不一样了"><a href="#_1-1-函数名称相同和重载不是一回事-比如全局函数和class里面的函数-作用域都不一样了" class="header-anchor">#</a> 1.1.函数名称相同和重载不是一回事！比如全局函数和class里面的函数，作用域都不一样了</h4> <ul><li>函数名称相同，参赛列表相同，但是也可以不是重载、重写、重定义</li></ul> <p>如下，是2个不同的函数！他们的<strong>作用域都不一样</strong>！</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//a.cpp</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//b.cpp</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="_1-2-重载-overload"><a href="#_1-2-重载-overload" class="header-anchor">#</a> 1.2.<strong>重载(Overload)</strong>：</h4> <ul><li><strong>在同一作用域内</strong>，函数名相同，函数的参数个数、参数类型或参数顺序三者中必须至少有一种不同。函数返回值的类型可以相同，也可以不相同。比如：发生在一个类内部。</li></ul> <p>​	郑莉：C++允许功能相近的函数在<strong>相同的作用域内</strong>以相同函数名声明。从而形成重载。方便使用记忆。</p> <p>​	《<strong>C++ Primer</strong>》P206，如果“<strong>同一作用域</strong>”内的几个函数名字相同但“形参列表”不同，我们称之为重载（<strong>overloaded</strong>）函数</p> <h4 id="_1-3-重写-override-「我觉得翻译为覆盖更好-」"><a href="#_1-3-重写-override-「我觉得翻译为覆盖更好-」" class="header-anchor">#</a> 1.3.<strong>重写(Override)</strong>：「我觉得翻译为<strong>覆盖</strong>更好！」</h4> <p>​	也叫做<strong>覆盖</strong>，也叫<strong>复写</strong>，一般发生在子类和父类继承关系之间「发生在继承这种类型的不同作用域」。子类<strong>重新定义</strong>父类中有相同名称和参数的<font style="background:yellow;">『<strong>虚函数</strong>』</font></p> <h4 id="_1-4-隐藏-hide-好像还有人说overwrite是重定义"><a href="#_1-4-隐藏-hide-好像还有人说overwrite是重定义" class="header-anchor">#</a> 1.4.**隐藏（hide）**好像还有人说overwrite是重定义</h4> <p>​	子类<strong>重新定义</strong>父类中有相同名称的<font style="background:yellow;">『<strong>非虚函数</strong>』 </font>( 参数列表可以不同 ) ，指派生类的函数<strong>屏蔽</strong>了与其同名的基类函数。可以理解成发生在继承中的重载。</p> <blockquote><p>参考：<a href="https://blog.csdn.net/u010275850/article/details/45583705" target="_blank" rel="noopener noreferrer">C++_重载、重写和重定义的区别<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>PS：但是，从很多英语教材上面，来说，重定义和重写都是单词（override），理解参考第4节</p> <ul><li>子类重新定义父类虚函数的方法叫做覆写</li> <li>多态是为了<strong>接口</strong>重用，封装和继承是为了代码重用</li></ul> <p>是的，override和overwrite是同一个概念。Override指的是在继承类中重写父类的方法，而overwrite指的是覆盖源文件中的内容。例如，在<strong>Java中</strong>，如果在子类中重写父类的方法，就可以使用<strong>override关键字</strong>，而如果要覆盖文件中的内容，就可以使用<strong>overwrite关键字</strong>。</p> <h3 id="✅区分overload、overwrite和override"><a href="#✅区分overload、overwrite和override" class="header-anchor">#</a> ✅区分Overload、Overwrite和Override</h3> <ul><li>注意，由于这3个词的翻译很尴尬，众说纷纭，我们直接考虑单词来</li> <li>『记忆版』</li></ul> <blockquote><p>参考：<a href="https://blog.csdn.net/jszhangyili/article/details/7570311" target="_blank" rel="noopener noreferrer">CSDN的jszhangyili博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <img src="/assets/img/class中函数3大概念.43294c4e.png"> <blockquote><p>都是在函数名相同的时候，都不考虑返回值的情况下，我们讨论下面3组</p></blockquote> <ul><li>Overload
<ul><li><strong>相同作用域</strong>『可以不是class中』
<ul><li>参数相同，如果在class中，这样写就很奇怪了，<font style="background:yellow;">报错</font></li> <li>参数不同，就是重载</li></ul></li></ul></li> <li>Override『显然是继承才有这个概念！whoway』覆写
<ul><li>==继承==体系，不同作用域</li> <li>基类该函数是虚函数</li> <li>参数相同</li></ul></li> <li>Overwrite
<ul><li>继承体系，不同作用域
<ul><li>情况1：参数不同，无论基类该函数是不是虚函数</li> <li>情况2：参数相同，基类如果是『非虚函数』，那么就意味着在派生类中<strong>重新定义</strong>一个函数，<font style="background:yellow;">也就是非多态</font></li></ul></li></ul></li></ul> <h3 id="同一个class里面的成员函数加-不加virtual算不算重载"><a href="#同一个class里面的成员函数加-不加virtual算不算重载" class="header-anchor">#</a> 同一个class里面的成员函数加/不加virtual算不算重载？</h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>

    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;non-virtual=%d\n&quot;</span><span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;virtual=%d\n&quot;</span><span class="token punctuation">,</span> val<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;BBB&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    A a<span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@CentosLinux apue<span class="token punctuation">]</span><span class="token comment"># g++ demo.cpp </span>
demo.cpp:15:18: error: ‘virtual void A::test<span class="token punctuation">(</span><span class="token punctuation">)</span>’ cannot be ⭐️overloaded「重载」⭐️
     virtual void test<span class="token punctuation">(</span><span class="token punctuation">)</span>
                  ^
demo.cpp:11:10: error: with ‘void A::test<span class="token punctuation">(</span><span class="token punctuation">)</span>’
     void test<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>如上，<code>virtual void A::test()</code>不能被<strong>重载！！</strong></li></ul> <h3 id="那下面这样的叫什么"><a href="#那下面这样的叫什么" class="header-anchor">#</a> 那下面这样的叫什么？</h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;global=%d\n&quot;</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>

    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;virtual=%d\n&quot;</span><span class="token punctuation">,</span> val<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    A a<span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>​</p> <p>​	在上面的代码中，全局的<code>test()</code>函数和类<code>A</code>中的<code>test()</code>函数<strong>虽然具有相同的名称</strong>，但它们<strong>所在作用域不同</strong>，<strong>就像两个不同文件里面的作用域分别都叫test</strong>，因此它们不是函数的重载（overloading）。实际上，全局的<code>test()</code>函数和类<code>A</code>中的<code>test()</code>函数属于<strong>两个不同的函数</strong>。</p> <p>​	全局的<code>test()</code>函数和类<code>A</code>中的<code>test()</code>函数是两个不同的函数，它们没有重载的关系，也没有覆盖或重写的关系!</p> <p>​	因为函数重载，强调了，要在同一作用域。</p> <h4 id="chatgpt"><a href="#chatgpt" class="header-anchor">#</a> chatgpt</h4> <p>那给我区别一下C++里面的Overload、Override、Overwrite</p> <p>在C++中，<code>Overload</code>、<code>Override</code>和<code>Overwrite</code>都是与函数有关的概念，它们分别表示不同的含义：</p> <ol><li>Overload（重载）：是指在<strong>同一作用域</strong>内，定义多个函数名相同但参数列表不同的函数。C++允许在同一个作用域内定义多个同名函数，只要它们的参数列表不同，这就是函数重载。重载的目的是为了提高代码的复用性和可读性。</li> <li>Override（覆盖）：是指在==派生类==中重新定义（或覆盖）基类中的==虚函数==。当一个派生类重定义了一个虚函数时，它将覆盖基类中的函数，从而在运行时调用派生类的函数而不是基类的函数。这样做可以实现运行时多态性，从而允许以统一的方式操作不同类型的对象。</li> <li>Overwrite（覆盖）：是指在==派生类==中定义与基类中的==非虚函数同名==的函数。当派生类定义一个与基类中的非虚函数同名的函数时，该函数将覆盖基类中的函数，从而在运行时调用派生类的函数而不是基类的函数。由于C++不支持非虚函数的多态性，因此覆盖非虚函数往往不是一个好的编程实践，容易导致意外的行为。</li></ol> <p>我觉得回答还好！</p> <p>​	总的来说，我觉得这些区别，可能是这么比较，但是像<strong>编译器</strong>可能还是会将像：同一个class里面的成员函数加/不加virtual算重载，虽然是同一作用域，但是参数列表不是一样吗？「但是这样又破除了，咋们对这些的理解」</p> <h2 id="_2-多态与虚函数"><a href="#_2-多态与虚函数" class="header-anchor">#</a> 2.多态与虚函数</h2> <h3 id="_2-1-static变量的说明"><a href="#_2-1-static变量的说明" class="header-anchor">#</a> 2.1.<code>static</code>变量的说明</h3> <p>c++的一个类中声明一个<strong>static成员变量</strong>，下面描述正确的是</p> <ul><li>static是加了<strong>访问控制</strong>的全局变量，『<strong>不被继承</strong>』，类和子类对象，static变量占有一份内存</li></ul> <h3 id="_2-2-虚函数相关"><a href="#_2-2-虚函数相关" class="header-anchor">#</a> 2.2.虚函数相关</h3> <ul><li>1、（static）静态函数不可以是虚函数『虚成员函数不可能是static 成员函数』</li> <li>2、（inline）虚函数可以声明为inline，但是编译器不会将其作为inline函数处理『有的选择题故意为难，但是其实<strong>虚函数是可以声明为inline的，但是分情况</strong>』』</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">a</span>
<span class="token punctuation">{</span>
    <span class="token keyword">inline</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	尽管以上写法是没有语法错误的，并且可以执行，但其实test函数已经不是内联函数了，因为inline只是对编译器的一个建议而已。搞清本质就好。</p> <h3 id="_2-2-虚函数能不能inline"><a href="#_2-2-虚函数能不能inline" class="header-anchor">#</a> 2.2.虚函数能不能inline</h3> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>Q:虚函数不能内联，但是语法不出错？

A:不是的，虚函数在『『没有表现多态的时候』』是可以内联的，表现多态的时候不能

『没有表现多态的时候』:内联只是对编译器的一种请求，是否真正内联要看编译器的处理，虚函数是可以内联的，但是编译器不会响应内联请求，即他会忽略内联说明，将其当做普通虚函数处理。

有说法说：
虚函数不可以内联，因为虚函数是在运行期的时候确定具体调用的函数，内联是在编译期的时候进行代码展开，两者冲突，所以没有一起使用的做法。『『这是不严谨的』』
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_3-『多态神器』-多态3条件"><a href="#_3-『多态神器』-多态3条件" class="header-anchor">#</a> 3.『多态神器』-多态3条件</h2> <ul><li>『『<code>动态绑定3条件</code>』』</li></ul> <blockquote><p>C++编译器，看到一个函数调用，他有2个考量，静态还是动态绑定：</p></blockquote> <ul><li>静态被编译成：<code>call</code></li> <li><font style="background:yellow;">动态绑定：符合某些条件就会做动态绑定，<strong>3个条件</strong></font></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token number">1</span>、通过指针来调用『注意，引用显然也是的，因为底层也是指针』
<span class="token number">2</span>、这个指针是向上转型up cast了。『比如，派生类赋值给基类指针，基类指针调用』
<span class="token number">3</span>、调用虚函数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_3-1-条件1和条件2❎『非多态』"><a href="#_3-1-条件1和条件2❎『非多态』" class="header-anchor">#</a> 3.1.条件1和条件2❎『非多态』</h3> <ul><li><p>例题1.</p></li> <li><p>牛客上配套习题：<a href="https://www.nowcoder.com/test/question/done?tid=44172669&amp;qid=15197#summary" target="_blank" rel="noopener noreferrer">传送门<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>题解：</p></li> <li><p>这一题中，最后一个c，是相当于强制类型转换，『或许叫：向下转型？？』，然后没有通过指针来调用</p></li> <li><p>用牛油的一个解释：动态绑定（多态）只有在指针和引用时才有效，其他情况下无效。</p></li></ul> <h3 id="_3-2-条件3❎『非多态』"><a href="#_3-2-条件3❎『非多态』" class="header-anchor">#</a> 3.2.条件3❎『非多态』</h3> <ul><li>例题2.</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">mytest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;AAA&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mytest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;BBB&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>	
<span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	
	A <span class="token operator">*</span> p<span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span>
	p<span class="token operator">-&gt;</span><span class="token function">mytest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//输出的是AAA</span>
    
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span> 

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><ul><li>本题不是动态绑定原因分析：</li> <li>1、通过指针来调用『注意，引用显然也是的，因为底层也是指针』
<ul><li>满足，用了<code>p-&gt;mytest();</code></li></ul></li> <li>2、这个指针是向上转型up cast了『比如，派生类赋值给基类指针，基类指针调用』
<ul><li>满足，A是B的基类</li></ul></li> <li>3、调用虚函数❎不满足
<ul><li>因为p指针是A类型的，但是在classA中该函数还不是『虚函数』，因此次数，不能走偏移vptr的路径，想走虚函数指针—虚函数表的路径走不通。只能老老实实转换为调用<code>A::test()</code>这个非虚函数</li></ul></li></ul> <h3 id="_3-3-虚析构函数"><a href="#_3-3-虚析构函数" class="header-anchor">#</a> 3.3.虚析构函数</h3> <ul><li><p>例题3</p></li> <li><p><font style="background:yellow;">虚析构函数：是为了解决基类的指针指向派生类对象，并且用『基类指针』删除派生类对象。</font></p></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">A</span><span class="token punctuation">(</span>A <span class="token operator">&amp;</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;3&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;4&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">B</span><span class="token punctuation">(</span>B <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;5&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;6&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    A <span class="token operator">*</span>pa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> pa<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//输出是：1 4 6 3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><ul><li><p>考察的是对继承体系中的构造和析构函数调用顺序的理解。</p></li> <li><p>在调用new B()的时候，因为B继承A，所以会首先调用其父类的构造函数，输出1</p></li> <li><p>然后调用自己的构造函数，输出4</p></li> <li><p>//析构的时候，是会调用的</p></li> <li><p>对比，下面，如果去除掉A的析构函数的，虚函数</p></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-txt line-numbers-mode"><pre class="language-txt"><code>输出为：1 4 3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>原因：
<ul><li><strong>静态绑定，this指针直接调用了A的析构</strong>，B的没有。</li> <li>很显然，有的时候，会出问题。</li></ul></li></ul> <h3 id="_3-4-『添加作用域的调用』"><a href="#_3-4-『添加作用域的调用』" class="header-anchor">#</a> 3.4.『添加作用域的调用』</h3> <ul><li><p>例题4</p></li> <li><p>多态情况下，不调用多态</p></li> <li><p>牛客网<a href="https://www.nowcoder.com/test/question/done?tid=44308742&amp;qid=180817#summary" target="_blank" rel="noopener noreferrer">题目<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：</p></li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>类B是类A的公有派生类，类A和类B中都定义了虚函数func(),p是一个指向类A对象的指针，则p-&gt;A::func()将（）？

正确答案: C   你的答案: C (正确)

A	调用类B中函数func()
B	即调用类A中函数，也调用类B中的函数
C	调用类A中函数func()
D	根据p所指的对象类型而确定调用类A中或类B中的函数func()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>不论指针p是属于类A还是类B，也不论指针p指向的对象属于类A还是类B(当然，不能用类B的指针指向类A的对象)，<strong>因为加了作用域说明符<code>A::</code>，因此都只会调用类A的函数</strong>。</li></ul> <h3 id="_3-5-静态绑定的核心理解『易错难点』⭐️"><a href="#_3-5-静态绑定的核心理解『易错难点』⭐️" class="header-anchor">#</a> 3.5.静态绑定的核心理解『易错难点』⭐️</h3> <ul><li>例题5</li> <li>易错的题目<a href="https://www.nowcoder.com/test/question/done?tid=44470246&amp;qid=44536#summary" target="_blank" rel="noopener noreferrer">传送门<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
		<span class="token punctuation">{</span> 
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;test A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	A <span class="token operator">*</span>pA <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//注意『这是个幌子』</span>
	pA<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ul><li>有4个选项</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>问你选什么？
A    编译出错
B    程序运行奔溃
C    输出&quot;test A&quot;
D    输出乱码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>答案选C：<strong>输出&quot;test A&quot;</strong></li></ul> <p><img src="https://cdn.jsdelivr.net/gh/whoway/picture/img/image-20210711202412877.png" alt="image-20210711202412877"></p> <ul><li>原因：
<ul><li>因为<strong>对于非虚成员函数，Ｃ++这门语言是静态绑定的</strong>。</li> <li><font style="background:yellow;">这也是Ｃ++语言和其它语言Java, Python的一个显著区别</font></li> <li><code>//pA-&gt;test();</code>这语句的意图是：调用对象 pA 的 test 成员函数。如果这句话在Java或Python等动态绑定的语言之中，编译器生成的代码大概是：
<ul><li>找到 pA 的 test 成员函数，调用它。（注意，这里的找到是程序运行的时候才找的，这也是所谓动态绑定的含义：运行时才绑定这个函数名与其对应的实际代码。有些地方也称这种机制为迟绑定，晚绑定。）</li></ul></li> <li>但是对于C++。为了保证程序的运行时效率，Ｃ++的设计者认为凡是编译时能确定的事情，就不要拖到运行时再查找了。所以C++的编译器看到这句话会这么干：
<ul><li>１：查找 pA 的类型，发现它有一个非虚的成员函数叫 test 。（编译器干的）</li> <li>２：找到了，在这里生成一个函数调用，直接调<code>A:: test ( pA )</code>。</li></ul></li> <li>所以到了运行时，由于 test ()函数里面并没有任何需要解引用 pA 指针的代码，所以真实情况下也不会引发<code>segment fault</code>。
<ul><li><font style="background:yellow;">这里对成员函数的解析，和查找其对应的代码的工作都是在编译阶段完成而非运行时完成的，这就是所谓的静态绑定，也叫早绑定。正确理解C++的静态绑定可以理解一些特殊情况下C++的行为。『贼容易错』</font></li></ul></li></ul></li></ul> <h3 id="✅上面是难点"><a href="#✅上面是难点" class="header-anchor">#</a> ✅上面是难点</h3> <ul><li>因为<strong>对于非虚成员函数，Ｃ++这门语言是静态绑定的</strong>。</li> <li><font style="background:yellow;">这也是Ｃ++语言和其它语言Java, Python的一个显著区别</font></li></ul> <h3 id="_3-6-const对象"><a href="#_3-6-const对象" class="header-anchor">#</a> 3.6.const对象</h3> <ul><li><p>例题6</p></li> <li><p>题目来源和<a href="https://www.nowcoder.com/test/question/done?tid=44470458&amp;qid=1318#summary" target="_blank" rel="noopener noreferrer">参考资料<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A::f() &quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A::f() const &quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B::f() &quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">//还是虚函数！，只是说，覆盖了，其实是vitual</span>
	<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B::f() const &quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">const</span> A <span class="token operator">*</span>a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	a<span class="token operator">-&gt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	A <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	p<span class="token operator">-&gt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//多态</span>
	<span class="token function">g</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//先转换为const指针，由于只能调用const函数，所以不是多态了「因为此时不需要借助vptr去偏移了」</span>
	<span class="token keyword">delete</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//输出</span>
<span class="token comment">//B::f() A::f() const</span>
<span class="token comment">//输出前面是因为多态</span>
<span class="token comment">//输出后面是因为不是多态！！！（注意）</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><ul><li>解释原因</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>由于<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>在基类中声明为虚的，则p<span class="token operator">-&gt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>根据『对象类型』<span class="token punctuation">(</span>B<span class="token punctuation">)</span>调用<span class="token class-name">B</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，
  此时编译器对虚方法使用动态联编，输出<span class="token class-name">B</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>。
    
由于<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>在基类中未声明为虚的，故p<span class="token operator">-&gt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> 『根据指针类型』<span class="token punctuation">(</span>A<span class="token punctuation">)</span>调用<span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>，此时编译器对非虚方法使用静态联编，输出<span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><p>C++ primer告诉我们，P537</p> <p>当我们在派生类中覆盖某个虚函数时，可以再次使用virtual关键字指出该函数的性质，然而<strong>这么做并非必须</strong>！因为，<strong>基类中的虚函数，在派生类中隐含的也是1个虚函数！</strong></p></li></ul> <h2 id="_4-构造函数-ctor-和析构函数-dtor-相关⭐️"><a href="#_4-构造函数-ctor-和析构函数-dtor-相关⭐️" class="header-anchor">#</a> 4.构造函数（ctor）和析构函数（dtor）相关⭐️</h2> <h3 id="_4-1-c-构造函数和析构函数可以是虚函数嘛"><a href="#_4-1-c-构造函数和析构函数可以是虚函数嘛" class="header-anchor">#</a> 4.1.C++ 构造函数和析构函数可以是虚函数嘛？</h3> <ul><li>构造函数<strong>不可以</strong>是虚函数</li></ul> <p>​	因为虚函数只有和类的对象结合才能体现多态性，<strong>构造函数被调用时，类对象还没有完成建立</strong>，所以无意义。</p> <ul><li>析构函数<strong>可以且常常</strong>是虚函数</li></ul> <p>在多个派生类中如果动态分配了内存，虚析构函数可以分别释放。不然有可能造成内存泄漏。</p> <p>虚析构函数是为了解决：基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p> <blockquote><p>参考自：《面向对象技术与Visual C++学习指导》，甘玲， 邱劲，张璞</p></blockquote> <ul><li>参考代码：http://c.biancheng.net/view/269.html</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">CShape</span>  <span class="token comment">//基类</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token operator">~</span><span class="token function">CShape</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;CShape::destrutor&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">CRectangle</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">CShape</span>  <span class="token comment">//派生类</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> w<span class="token punctuation">,</span> h<span class="token punctuation">;</span>  <span class="token comment">//宽度和高度</span>
    <span class="token operator">~</span><span class="token function">CRectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;CRectangle::destrutor&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    CShape<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> CRectangle<span class="token punctuation">;</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>​	输出结果说明，<code>delete p;</code>只引发了 CShape 类的析构函数被调用，没有引发 CRectangle 类的析构函数被调用。这是因为该语句是「静态联编」的，<font style="background:pink;"><strong>编译器编译到此时，「不可能知道此时 p 到底指向哪个类型的对象」</strong>，它<strong>只根据 p 的类型是 <code>CShape *</code> 来决定应该调用 CShape 类的析构函数</strong></font>。</p> <p>​	按理说，<code>delete p;</code>会导致一个 CRectangle 类的对象消亡，应该调用 CRectangle 类的析构函数才符合逻辑，否则有可能引发程序的问题。</p> <p>​	例如，假设程序需要对 CRetangle 类的对象进行计数，如果此处不调用 CRetangle 类的析构函数，就会导致计数不正确。</p> <p>​	再如，假设 CRectangle 类的对象在存续期间进行了动态内存分配，而释放内存的操作都是在析构函数中进行的，如果此处不调用 CRetangle 类的析构函数，就会导致被释放的对象中动态分配的内存以后再也没有机会回收。</p> <p>综上所述，人们希望<code>delete p;</code>这样的语句能够聪明地根据 p 所指向的对象执行相应的析构函数。实际上，这也是多态。为了在这种情况下实现多态，<a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener noreferrer">C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 规定，需要将基类的析构函数声明为虚函数，即虚析构函数。</p> <h3 id="_4-2-构造函数中调用虚函数会怎么样"><a href="#_4-2-构造函数中调用虚函数会怎么样" class="header-anchor">#</a> 4.2.构造函数中调用虚函数会怎么样？</h3> <blockquote><p>参考：<a href="https://www.huaweicloud.com/articles/ce10c517a25e175c5ab5d0c751c0319c.html" target="_blank" rel="noopener noreferrer">华为云博客：构造函数和析构函数中可以调用调用虚函数吗<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>１.　从语法上讲，调用完全没有问题。
２.　但是从效果上看，往往不能达到需要的目的。</p> <ul><li>《Effective C++ 》条款9：永远不要在构造函数或析构函数中调用虚函数</li></ul> <p>为什么不能在析构和构造函数中调用呢,实际上这样做是不会报错的(试过了),但是不建议这样用</p> <p>书上,其实就是作者告诉你<strong>构造函数和析构函数中调用虚函数不会呈现出多态</strong></p> <p>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化， 因此调用子类的虚函数是不安全的，故而C++不会进行动态联编。</p> <h3 id="_4-3-析构函数中调用虚函数会怎么样"><a href="#_4-3-析构函数中调用虚函数会怎么样" class="header-anchor">#</a> 4.3.析构函数中调用虚函数会怎么样？</h3> <p>​	<strong>不要</strong>在析构函数中调用虚函数的原因：</p> <p>​	析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。</p> <p>​	所以<strong>在调用基类的析构函数时，派生类对象的数据成员已经“销毁”，这个时再调用子类的虚函数已经没有意义了</strong>。</p> <h2 id="⭐️4-『运算符重载』详解"><a href="#⭐️4-『运算符重载』详解" class="header-anchor">#</a> ⭐️4.『运算符重载』详解</h2> <p>（本质还是函数重载）</p> <h3 id="_4-1-重载的2种函数类型"><a href="#_4-1-重载的2种函数类型" class="header-anchor">#</a> 4.1.重载的2种函数类型</h3> <ul><li>1、成员函数</li> <li>2、友元函数『属于，非成员函数』</li></ul> <p>易错：有的运算符，<strong>只能重载</strong>为『成员函数』</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token operator">=</span> 			
<span class="token punctuation">[</span><span class="token punctuation">]</span>			<span class="token comment">//重载，下标运算符，比如重载后，返回当前vetor中的元素，需要this指针，而非成员函数是没有this指针的233</span>
<span class="token punctuation">(</span><span class="token punctuation">)</span>			<span class="token comment">//重载，函数调用运算符，</span>
<span class="token operator">-&gt;</span>
上面<span class="token number">4</span>个，『只能』通过成员函数进行重载
我的理解，备注如上
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="谈一谈null-0-nullptr"><a href="#谈一谈null-0-nullptr" class="header-anchor">#</a> 谈一谈NULL，0，nullptr</h2> <p>​	 nullptr是<strong>一个编译期常量，其类型为nullptr_t</strong>。 它既不是整型类型，也不是指针类型； 在模板推导中，nullptr被推导为nullptr_t类型，仍<strong>可隐式转为指针</strong></p> <p>在C中NULL是什么，在C的头文件中，通常定义如下：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>但是在C++中，它是这样定义的：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>或者你可以在stddef.h看到完整的这段：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression"><span class="token constant">NULL</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>__cplusplus<span class="token punctuation">)</span>  </span><span class="token comment">//C++里面</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>   <span class="token comment">//大概是C里面</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>也就是说，在C++中，NULL不过也是0罢了，把它当成空指针只是一个无可奈何的选择罢了。</p> <p>那么为什么在C++和C中不一样呢？因为C++中不能将<code>void *</code>类型的指针<strong>隐式转换</strong>成其他指针类型，从下面的例子可以看出来：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//null.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;12345&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>编译：</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>$ g+ -o null null.cpp
null.cpp: In function 'int main()':
null.cpp:5:17: error: invalid conversion from 'void*' to 'int*' [-fpermissive]
  int *a = (void*)p;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>所以不能将NULL定义为(void*)0。</p> <p>nullptr并非整型类别，甚至也不是指针类型，但是能转换成任意指针类型。nullptr的实际类型是std:nullptr_t。</p> <p><strong>std::nullptr_t</strong> 是空指针字面量 <a href="https://www.apiref.com/cpp-zh/cpp/language/nullptr.html" target="_blank" rel="noopener noreferrer"><code>nullptr</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的类型。它是既非指针类型亦非指向成员指针类型的独立类型。</p> <p>参考资料：https://www.apiref.com/cpp-zh/cpp/types/nullptr_t.html</p> <p>这个新特性特别有助于避免将空指针解释为整数值发生的错误。</p> <p>nullptr是一个新的关键字。它会自动转换为一个指针类型，但<strong>不会转换为任何整数类型</strong>。它的类型是std::nullptr_t，所以你现在甚至可以重载传递空指针的操作。std::nullptr_t算作一个<strong>基本数据类型</strong></p> <h2 id="✅杂谈"><a href="#✅杂谈" class="header-anchor">#</a> ✅杂谈</h2> <h3 id="_1-常量表达式"><a href="#_1-常量表达式" class="header-anchor">#</a> 1.常量表达式</h3> <ul><li>《<a href="https://www.nowcoder.com/test/question/done?tid=43575799&amp;qid=67992" target="_blank" rel="noopener noreferrer">C++Primer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>》</li></ul> <h3 id="_2-c-98关键字"><a href="#_2-c-98关键字" class="header-anchor">#</a> 2.C++98关键字</h3> <ul><li><p>1、<code>static</code></p> <ul><li><p>修改变量或函数存储的形式，比如<code>.data</code>，<code>.bss</code></p></li> <li><p>作用是：穿透作用域、『C++ primer PXX好像是这么说的』</p></li> <li><p>参考：牛客网：<a href="https://www.nowcoder.com/test/question/done?tid=44308658&amp;qid=14302#summary" target="_blank" rel="noopener noreferrer">关于static用途说法正确的是<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>？</p></li></ul></li> <li><p>2、<code>const</code></p> <ul><li>修改变量or函数的只读方式</li></ul></li> <li><p>3、<code>inline</code></p></li> <li><p>建议在“编译期”，直接将整个函数的代码插入调用语句处</p></li> <li><p>4、<code>friend</code></p> <ul><li>声明友元，包括，友元函数，友元类</li></ul></li></ul> <h2 id="✅常识-非面试"><a href="#✅常识-非面试" class="header-anchor">#</a> ✅常识-非面试</h2> <h3 id="_1-区分c-和c"><a href="#_1-区分c-和c" class="header-anchor">#</a> 1.区分C++和C</h3> <p>​	C和C++从来就不是一个东西！C++部分兼容C</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>C<span class="token operator">++</span><span class="token number">11</span>中没有的C99<span class="token operator">/</span>C11特性
    虽然在过去C或多或少可以看作是C<span class="token operator">++</span>的子集，但是C99标准增加了一些C<span class="token operator">++</span>没有的新特性
下面列出了一些只有C99<span class="token operator">/</span>C11中才有的特性<span class="token operator">:</span>	
	指定初始化器<span class="token punctuation">;</span>
	复合初始化器<span class="token punctuation">(</span>Compound initializer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	受限指针<span class="token punctuation">(</span> Restricted pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>即，restric指针<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  变长数组<span class="token punctuation">;</span>
	伸缩型数组成员<span class="token punctuation">;</span>
	带可变数量参数的宏。

注意
以上所列只是在特定时期内的情况，随着时间的推移和C、C<span class="token operator">++</span>的不断发展，列表中的项会有所增减。
    例如，C<span class="token operator">++</span><span class="token number">14</span>新增的一个特性就与『C99的变长数组』类似。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li>参考自：《C Primer Plus》P730</li></ul> <h3 id="如果使用brk-c-堆内存为什么不连续"><a href="#如果使用brk-c-堆内存为什么不连续" class="header-anchor">#</a> 如果使用brk(). C++：堆内存为什么不连续？</h3> <ul><li>栈中的内存是操作系统自动分配的，可以理解成是连续的
<ul><li>堆的内存分配是因为我们malloc空间的时候，申请的空间的大小不一样造成了碎片。使用malloc的时候系统内部有一个<strong>空闲内存映射表</strong>，系统会自动查找空闲内存中的第一个合适大小的空间分配</li> <li>分配和释放不一定什么时候发生。内核有自己申请内存的算法。当然不一定是连续的，如果想连续就一起申请</li> <li>malloc 通过 <strong>brk()</strong> 方式申请的内存，free 释放内存的时候，==<strong>并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用</strong>；==
<ul><li>随着系统频繁地 malloc 和 free ，尤其对于小块内存，堆内将产生越来越多不可用的碎片，导致“内存泄露”。而这种“泄露”现象使用 valgrind 是无法检测出来的。</li></ul></li> <li>malloc 通过 <strong>mmap()</strong> 方式申请的内存，free 释放内存的时候，<strong>会把内存归还给操作系统，内存得到真正的释放</strong>。</li></ul></li></ul> <p>我的理解，就是先前brk的可能没还给操作系统，然后我们就继续申请，然后</p> <h2 id="引申问题-由new和仅在class上的对象或仅在stack上的对象-⭐️"><a href="#引申问题-由new和仅在class上的对象或仅在stack上的对象-⭐️" class="header-anchor">#</a> 引申问题-由new和仅在class上的对象或仅在stack上的对象！⭐️</h2> <h3 id="_1-如何定义1个『只能』在『堆』上生成对象的类"><a href="#_1-如何定义1个『只能』在『堆』上生成对象的类" class="header-anchor">#</a> 1.如何定义1个『只能』在『堆』上生成对象的类？</h3> <p>​	在C++中，为了让某个class**只能通过new（不能通过malloc）**来创建（即如果直接创建对象，编译器将报错），应该</p> <ul><li>将『析构函数』设为『<strong>私有</strong>』</li> <li>原因：C++是静态，如果在栈上分配，那是编译期间（静态）就搞定了构造和析构的<strong>汇编</strong>！
<ul><li>只要把某个步骤截断！比如构造函数or析构函数，但是构造函数为私有的话，意味着只有类的成员函数或友元函数才能调用该构造函数，比如单例模式「引申到单例模式的代码」</li></ul></li></ul> <p>​	原因：C++ 是<strong>静态绑定语言</strong>，编译器管理<strong>栈</strong>上对象的生命周期，编译器在为类对象分配栈空间时，会<strong>先检查</strong>class的<strong>析构函数的访问性</strong>。若析构函数不可访问，则不能在栈上创建对象。</p> <h3 id="_2-如何定义1个『只能』在『栈』上生成对象的class"><a href="#_2-如何定义1个『只能』在『栈』上生成对象的class" class="header-anchor">#</a> 2.如何定义1个『只能』在『<strong>栈</strong>』上生成对象的class？</h3> <p>将这个class的operator new和delete重载为『<strong>私有</strong>』</p> <p>​	原因：在堆上生成class的object，使用new关键字操作。（不能使用malloc，所以不要阻断）</p> <ul><li>看过源代码知道过程是3步！</li> <li>1、使用operator new在『堆』上找可用的内存，分配给对象</li> <li>2、类型转换</li> <li>3、调用构造函数生成对象</li> <li>所以，如果将new操作设置为『私有』，那么第1阶段就不能完成。『就不能在堆上生成对象』</li></ul> <h3 id="追问-c-中-为了让某个class只能通过new来创建-那malloc为啥不可以"><a href="#追问-c-中-为了让某个class只能通过new来创建-那malloc为啥不可以" class="header-anchor">#</a> 追问：C++中，为了让某个class只能通过new来创建？那malloc为啥不可以？</h3> <p>​	<code>new</code>关键字会调用类的<strong>构造函数</strong>，而<code>malloc</code>只是简单地分配内存。那你后续咋构造函数？这问题就转换为</p> <h3 id="追问-那c-里面的strcut也是只能用new-不能用malloc吗"><a href="#追问-那c-里面的strcut也是只能用new-不能用malloc吗" class="header-anchor">#</a> 追问：那C++里面的strcut也是只能用new，不能用malloc吗？</h3> <p>​	是的！因为C++里面的struct底层也是结构体实现</p> <h2 id="c-如何实现多态"><a href="#c-如何实现多态" class="header-anchor">#</a> C++如何实现多态？</h2> <p>多态是用虚函数来实现，结合<strong>动态绑定</strong></p> <p>C++的多态性用一句话概括就是：</p> <p>在基类的函数前加上virtual关键字，在派生类中override该函数，运行时将会根据对象的实际类型来调用相应的函数。</p> <p>如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p> <h2 id="静态函数可以加virtual吗"><a href="#静态函数可以加virtual吗" class="header-anchor">#</a> 静态函数可以加virtual吗？</h2> <p>不可以！virtual用在继承体系中。</p> <h2 id="new是线程安全的吗"><a href="#new是线程安全的吗" class="header-anchor">#</a> new是线程安全的吗？</h2> <p>赵4老师：new和delete线程安全不安全还决定于链接的是否支持多线程的库。</p> <p>libc中有非线程安全/线程安全两个版本malloc函数</p> <ul><li>参考资料：[About thread safety in malloc and free <a href="https://stackoverflow.com/questions/987444/about-thread-safety-in-malloc-and-free" target="_blank" rel="noopener noreferrer">duplicate]<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="gdb如何调试多线程"><a href="#gdb如何调试多线程" class="header-anchor">#</a> gdb如何调试多线程？</h2> <ul><li>安装pstack，使用<code>pstack pid</code></li> <li>pstree好像默认又</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>//查看当前运行的进程
<span class="token function">ps</span> aux<span class="token operator">|</span><span class="token function">grep</span> a.out
//查看当前运行的轻量级进程
<span class="token function">ps</span> -aL<span class="token operator">|</span><span class="token function">grep</span> a.out
//查看主线程和新线程的关系
pstree <span class="token parameter variable">-p</span> 主线程id
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>参考资料：<a href="https://blog.csdn.net/zhangye3017/article/details/80382496" target="_blank" rel="noopener noreferrer">线程的查看以及利用gdb调试多线程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b7604e5b.js" defer></script><script src="/assets/js/2.443c6f9e.js" defer></script><script src="/assets/js/3.aa43f56f.js" defer></script>
  </body>
</html>
