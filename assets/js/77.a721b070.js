(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{368:function(t,_,a){"use strict";a.r(_);var s=a(14),r=Object(s.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"c-智能指针-面试"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#c-智能指针-面试"}},[t._v("#")]),t._v(" C++智能指针-面试")]),t._v(" "),_("h2",{attrs:{id:"目录"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[t._v("#")]),t._v(" 目录")]),t._v(" "),_("p",[t._v("[TOC]")]),t._v(" "),_("h2",{attrs:{id:"智能指针4个『c-11』"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#智能指针4个『c-11』"}},[t._v("#")]),t._v(" 智能指针4个『C++11』")]),t._v(" "),_("p",[t._v("​\t智能指针（Smart pointer）  是一种"),_("code",[t._v("pointer-like class")]),t._v("『行为像指针的class』  。智能指针是C++提供给我们的一种工具，用来管理对象的一个生命周期的，简单来说就是来帮我们管理动态内存（也就是heap）的")]),t._v(" "),_("p",[_("font",{staticStyle:{background:"yellow"}},[t._v("C++有个规定，除非如果你是智能指针，否则始终用深拷贝，vector为深拷贝")])],1),t._v(" "),_("p",[_("strong",[t._v("C++中所有的对象都是深拷贝，只有shared_ptr和weak_ptr是浅拷贝，然后unique_ptr则是直接"),_("font",{staticStyle:{background:"yellow"}},[t._v("禁止拷贝")]),t._v("这样的。")],1)]),t._v(" "),_("p",[t._v("在C语言中，他们有特定的算法来解决循环引用")]),t._v(" "),_("ul",[_("li",[t._v("但在C++中，"),_("strong",[t._v("shared_ptr是解决不了，循环引用")]),t._v("的。我们需要自己手动把其中1个需要的shared_ptr改为weak_ptr")])]),t._v(" "),_("h3",{attrs:{id:"三五法则-让我意识到设计自己的class的时候-深浅拷贝的重要性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三五法则-让我意识到设计自己的class的时候-深浅拷贝的重要性"}},[t._v("#")]),t._v(" 三五法则-让我意识到设计自己的class的时候，深浅拷贝的重要性")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/image-20220725210641673.png",alt:"image-20220725210641673"}})]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("Java的话，这时候所以说他们索性")]),t._v("简化说一切非基础类型的对象都是浅拷贝，然后都有1个引用计数，就不管你有没有自己用shared_ptr，它始终都是有引用计数的，然后引用计数"),_("strong",[t._v("它为了解决循环引用，它又用了垃圾回收机制自动管理")]),t._v("。")]),t._v(" "),_("li",[t._v("所以说"),_("strong",[t._v("Java他们这些管资源的语言呢")]),t._v("，他们就喜欢把所有"),_("strong",[t._v("非基础")]),t._v("都认为是一个shared pointer")])]),t._v(" "),_("p",[t._v("而C++是因为系统级的这些原因，才发展出三五法则那些东西。所以说我们如果想学好高性能计算的话，一定要学C++")]),t._v(" "),_("p",[t._v("其余的；")]),t._v(" "),_("p",[t._v("P-IMPL模式，它可以分离声明和定义。")]),t._v(" "),_("p",[t._v("pybind能调用C++，而且能共享C++的vector啥的，taichen编译器用的pybind,现在试着转到ctypes里面")]),t._v(" "),_("h3",{attrs:{id:"_1-1-unique-ptr-独享指针-raii"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-unique-ptr-独享指针-raii"}},[t._v("#")]),t._v(" 1.1. "),_("code",[t._v("unique_ptr")]),t._v("（独享指针）(RAII)")]),t._v(" "),_("ul",[_("li",[t._v("学这个，一定要回move语句，"),_("code",[t._v("std::move")])])]),t._v(" "),_("p",[_("strong",[t._v("替换auto_ptr")])]),t._v(" "),_("p",[t._v("前置知识点：C++11引入的术语，右值引用，move语义")]),t._v(" "),_("p",[t._v("特点：")]),t._v(" "),_("ul",[_("li",[t._v("unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。")]),t._v(" "),_("li",[t._v("采用l『『独占式拥有』』，意味着可以确保"),_("strong",[t._v("一个对象和其相应的资源同一时间只被一个 pointer 拥有")]),t._v("。")]),t._v(" "),_("li",[t._v("一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[_("code",[t._v("unique_ptr")])]),t._v(" "),_("th",[_("code",[t._v("auto_ptr")])])])]),t._v(" "),_("tbody",[_("tr",[_("td",[_("font",{staticStyle:{background:"yellow"}},[t._v("C++11引入")])],1),t._v(" "),_("td",[t._v("C++98引入，"),_("font",{staticStyle:{background:"yellow"}},[t._v("C++11弃用")])],1)]),t._v(" "),_("tr",[_("td",[t._v("1、无拷贝赋值语义2、但实现了"),_("code",[t._v("move")]),t._v(" 语义；")]),t._v(" "),_("td",[t._v("1、可以赋值拷贝 2、复制拷贝后所有权转移")])]),t._v(" "),_("tr",[_("td",[t._v("unique_ptr 可以管理数组（析构调用 "),_("code",[t._v("delete[]")]),t._v(" ）")]),t._v(" "),_("td",[t._v("auto_ptr 对象不能管理数组（析构调用 "),_("code",[t._v("delete")]),t._v("）")])])])]),t._v(" "),_("h3",{attrs:{id:"_1-2-shared-ptr-共享指针"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-shared-ptr-共享指针"}},[t._v("#")]),t._v(" 1.2."),_("code",[t._v("shared_ptr")]),t._v("（共享指针）")]),t._v(" "),_("ul",[_("li",[t._v("面试的时候读：share指针")])]),t._v(" "),_("p",[t._v("设计思想：实现：共享式拥有（shared ownership）概念")]),t._v(" "),_("p",[t._v("应用场景举例：程序需要在多个对象间『共享数据』（或者叫：允许多个对象共享相同的状态）")]),t._v(" "),_("ul",[_("li",[t._v("参考自《C++ primer》")])]),t._v(" "),_("p",[t._v("缺点：")]),t._v(" "),_("p",[t._v("shared_ptr指针要是碰到，两个对象互相指向，导致“"),_("strong",[t._v("循环引用")]),t._v("”会导致“"),_("font",{staticStyle:{background:"yellow"}},[_("strong",[t._v("内存泄漏")])]),t._v("”")],1),t._v(" "),_("p",[t._v("特点：")]),t._v(" "),_("ul",[_("li",[t._v("1、支持定制型删除器（custom deleter）")]),t._v(" "),_("li",[t._v("2、可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）")]),t._v(" "),_("li",[t._v("3、自动解除互斥锁")]),t._v(" "),_("li",[t._v("4、线程不安全")])]),t._v(" "),_("div",{staticClass:"language-txt line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-txt"}},[_("code",[t._v("线程安全分为两个方面：\n    shared_ptr智能指针对象中的引用计数是多个智能指针对象共享的，两个线程中智能指针的引用计数同时进行++或者 - -操作，在为加锁的情况下，会导致计数混乱，这样有可能造成资源泄漏或者程序奔溃的问题\n    而且++和- -操作本身也不是原子的。智能指针管理的对象保存在堆上，两个线程同时去访问，也会导致线程安全问题。\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br")])]),_("h4",{attrs:{id:"_1-1-1缺点的代码『环形引用』"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1缺点的代码『环形引用』"}},[t._v("#")]),t._v(" 1.1.1缺点的代码『环形引用』")]),t._v(" "),_("ul",[_("li",[t._v("参考"),_("a",{attrs:{href:"https://blog.csdn.net/lijinqi1987/article/details/79005738",target:"_blank",rel:"noopener noreferrer"}},[t._v("博客"),_("OutboundLink")],1)])]),t._v(" "),_("h4",{attrs:{id:"_1-1-2shared-ptr的源代码『精华版』"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-2shared-ptr的源代码『精华版』"}},[t._v("#")]),t._v(" 1.1.2"),_("code",[t._v("shared_ptr")]),t._v("的源代码『精华版』")]),t._v(" "),_("ul",[_("li",[t._v("参考源代码，自行写一份代码『模板版本』")])]),t._v(" "),_("div",{staticClass:"language-cpp line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-cpp"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("shared_ptr")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n        T "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("make_shared")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("use_count")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n        T "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" ptr"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" count"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br"),_("span",{staticClass:"line-number"},[t._v("7")]),_("br"),_("span",{staticClass:"line-number"},[t._v("8")]),_("br"),_("span",{staticClass:"line-number"},[t._v("9")]),_("br"),_("span",{staticClass:"line-number"},[t._v("10")]),_("br")])]),_("h3",{attrs:{id:"_1-3-weak-ptr-弱指针-有失效检测"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-weak-ptr-弱指针-有失效检测"}},[t._v("#")]),t._v(" 1.3. "),_("code",[t._v("weak_ptr")]),t._v("（弱指针）有失效检测")]),t._v(" "),_("p",[t._v("为了解决“循环引用”导致的“内存泄漏”，引入了weak_ptr指针。")]),t._v(" "),_("ul",[_("li",[t._v("《C++ Primer》一书中说它一个伴随类，它是一种"),_("code",[t._v("弱引用")]),t._v("，指向"),_("code",[t._v("shared_ptr")]),t._v("所管理的对象。")])]),t._v(" "),_("p",[t._v("特点：将一个weak_ptr绑定到一个shared_ptr"),_("strong",[t._v("不会改变")]),t._v("shared_ptr的引用计数！！")]),t._v(" "),_("ul",[_("li",[t._v("一旦最后1个指向对象的"),_("code",[t._v("shared_ptr")]),t._v("被销毁，对象就会被释放，即时有"),_("code",[t._v("weak_ptr")]),t._v("指向对象，对象也还是会被释放！！")]),t._v(" "),_("li",[t._v('因此，weak_ptr的名字抓住了这种智能指针"弱"共享对象的特点！！')])]),t._v(" "),_("p",[t._v("参考：")]),t._v(" "),_("ul",[_("li",[t._v("weak_ptr 允许你"),_("strong",[t._v("共享但不拥有某对象")]),t._v("『『好像，你没有权利拥有"),_("code",[t._v("中科院文凭")]),t._v("，但是你有权利观察"),_("code",[t._v("某个学生的中科院文凭上的学号")]),t._v("，但是观察不代表什么』』，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。")]),t._v(" "),_("li",[t._v("可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题")])]),t._v(" "),_("h3",{attrs:{id:"_1-4-auto-ptr-弃用的-c-98标准❌"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-auto-ptr-弃用的-c-98标准❌"}},[t._v("#")]),t._v(" 1.4 "),_("code",[t._v("auto_ptr")]),t._v("（弃用的）C++98标准❌")]),t._v(" "),_("p",[t._v("C++98的时候的方案，C++11已抛弃")]),t._v(" "),_("ul",[_("li",[t._v("采用所有权模式")]),t._v(" "),_("li",[t._v("被 c++11 弃用，原因是缺乏语言特性如 “针对"),_("strong",[t._v("构造")]),t._v("和"),_("strong",[t._v("赋值")]),t._v("” 的 "),_("code",[t._v("std::move")]),t._v(" 语义（"),_("strong",[t._v("移动语义")]),t._v("），以及其他瑕疵")])]),t._v(" "),_("h3",{attrs:{id:"_1-5-当智能指针-作为class的成员变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-当智能指针-作为class的成员变量"}},[t._v("#")]),t._v(" 1.5.当智能指针-作为class的成员变量")]),t._v(" "),_("p",[t._v("如果你的class里面有智能指针的话，那你可能这个类就变成1个浅拷贝的类了")]),t._v(" "),_("p",[t._v("要么你的这个类里面有unique pointer，因为unique pointer他是禁止拷贝的。所以你这个类也会变成禁止拷贝的，就是呃他是会导致拷贝被删除，但移动还是有的。")]),t._v(" "),_("p",[t._v("什么时候用什么类型的智能指针的时候，")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/image-20220725173403313.png",alt:"image-20220725173403313"}})]),t._v(" "),_("ul",[_("li",[t._v("weak_ptr和shared_ptr一起用")]),t._v(" "),_("li",[t._v("原始指针和unique_ptr一起用")])]),t._v(" "),_("p",[_("strong",[t._v("因为weak_ptr他只能用shared_ptr")])]),t._v(" "),_("p",[t._v("而unique_ptr是不能生成1个weak_ptr的，unique只能生成1个原始指针，而原始指针是没有失效检测的。")]),t._v(" "),_("blockquote",[_("p",[t._v("第5点建议的原因：")])]),t._v(" "),_("p",[t._v("1、一方面有unique_ptr"),_("strong",[t._v("禁止拷贝")]),t._v("，可能就觉得很难用，然后原始指针又不能提供失效检测。所以share_ptr和weak_ptr的组合，所以这2可能是更安全，但是他是有性能损耗的。")]),t._v(" "),_("p",[t._v("2、解决C++的share_ptr的"),_("strong",[t._v("循环引用")]),t._v("，可以采用2个方案")]),t._v(" "),_("ul",[_("li",[t._v("shared_ptr和weak_ptr")]),t._v(" "),_("li",[t._v("shared_ptr和原始指针（"),_("strong",[t._v("缺点")]),t._v("是没有失效检测）")])]),t._v(" "),_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),_("p",[t._v("1、智能指针是"),_("strong",[t._v("代理模式")]),t._v("的具体应用，它使用 RAII 技术代理了裸指针，能够自动释放内存，无效手动 delete。")]),t._v(" "),_("p",[t._v("2、unique_ptr 为独占式智能指针，它为裸指针添加了很多限制，使用更加安全；shared_ptr 为共享式智能指针，功能非常完善，用法几乎与原是指针一样。")]),t._v(" "),_("p",[t._v("3、应当使用工厂函数 make_unique()、make_shared() 来参加智能指针，强制初始化，而且还能使用 auto 来简化声明。")]),t._v(" "),_("p",[t._v("4、工程项目中尽量不要使用裸指针，new/delete 来操作内存，尽量使用智能指针。")]),t._v(" "),_("h2",{attrs:{id:"参考资料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),_("ul",[_("li",[t._v("B站up主，双笙子佯谬，第02讲："),_("a",{attrs:{href:"https://www.bilibili.com/video/BV1LY411H7Gg?spm_id_from=666.25.top_right_bar_window_custom_collection.content.click&vd_source=ea20f1fccee6fd3f1af7d59cd3ae7575",target:"_blank",rel:"noopener noreferrer"}},[t._v("RAII与智能指针"),_("OutboundLink")],1)]),t._v(" "),_("li",[t._v("https://cplusplus.com/reference/memory/shared_ptr/?kw=shared_ptr+")]),t._v(" "),_("li",[t._v("https://en.cppreference.com/w/cpp/memory/shared_ptr")]),t._v(" "),_("li",[t._v("https://maodanp.github.io/2020/05/31/cpp_raii/")])])])}),[],!1,null,null,null);_.default=r.exports}}]);