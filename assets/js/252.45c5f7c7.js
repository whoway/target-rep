(window.webpackJsonp=window.webpackJsonp||[]).push([[252],{545:function(s,a,e){"use strict";e.r(a);var t=e(14),n=Object(t.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"nasm编译器常用指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nasm编译器常用指令"}},[s._v("#")]),s._v(" NASM编译器常用指令")]),s._v(" "),a("div",{staticClass:"language-txt line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-txt"}},[a("code",[s._v('<font style="background: yellow" >\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h2",{attrs:{id:"目录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[s._v("#")]),s._v(" 目录")]),s._v(" "),a("p",[s._v("[TOC]")]),s._v(" "),a("ul",[a("li",[a("font",{staticStyle:{background:"yellow"}},[s._v("32位汇编为例，结合X86寄存器理解")])],1),s._v(" "),a("li",[a("code",[s._v("NASM用的是intel汇编语法，和Linux反汇编的有区别")])])]),s._v(" "),a("h2",{attrs:{id:"_1-通用汇编指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-通用汇编指令"}},[s._v("#")]),s._v(" 1.通用汇编指令")]),s._v(" "),a("h3",{attrs:{id:"★分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#★分类"}},[s._v("#")]),s._v(" ★分类")]),s._v(" "),a("p",[s._v("汇编指令通常可以分为数据传送指令，算术和逻辑预算指令，控制流指令")]),s._v(" "),a("p",[s._v("PS：我们的操作数是:★")]),s._v(" "),a("ul",[a("li",[s._v("寄存器")]),s._v(" "),a("li",[s._v("立即数")]),s._v(" "),a("li",[s._v("内存")])]),s._v(" "),a("h3",{attrs:{id:"_1-1-数据传送指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-数据传送指令"}},[s._v("#")]),s._v(" 1.1.数据传送指令")]),s._v(" "),a("p",[s._v("1."),a("strong",[s._v("mov 目标操作数,源操作数")])]),s._v(" "),a("blockquote",[a("p",[s._v("排列数，A（底3,2）=3*2=6")])]),s._v(" "),a("ul",[a("li",[a("code",[s._v("mov 寄存器,寄存器")])]),s._v(" "),a("li",[a("code",[s._v("mov 寄存器,立即数")])]),s._v(" "),a("li",[a("code",[s._v("mov 寄存器,内存")])]),s._v(" "),a("li",[a("code",[s._v("mov 内存,寄存器")])]),s._v(" "),a("li",[a("code",[s._v("mov 内存,立即数")])]),s._v(" "),a("li",[a("font",{staticStyle:{background:"yellow"}},[s._v("mov 内存直接到内存是不准的！")])],1)]),s._v(" "),a("div",{staticClass:"language-asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("mov byte ptr[var],5\nmov eax,ebx\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("2."),a("strong",[s._v("push 操作数")])]),s._v(" "),a("blockquote",[a("p",[s._v("表示：将操作数，压入stack")])]),s._v(" "),a("ul",[a("li",[a("code",[s._v("push 寄存器")]),s._v("（注意要")]),s._v(" "),a("li",[a("code",[s._v("push 内存")])]),s._v(" "),a("li",[a("code",[s._v("push 立即数")])])]),s._v(" "),a("div",{staticClass:"language-asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("push eax\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("3."),a("strong",[s._v("pop 操作数")])]),s._v(" "),a("h3",{attrs:{id:"_1-2-算术运算指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-算术运算指令"}},[s._v("#")]),s._v(" 1.2.算术运算指令")]),s._v(" "),a("p",[s._v("1.加、减（add / "),a("strong",[s._v("sub")]),s._v("tract，v.减去）")]),s._v(" "),a("blockquote",[a("p",[s._v("排列数，A（底3,2）=3*2=6")])]),s._v(" "),a("ul",[a("li",[a("code",[s._v("add/sub 目标操作数,被加/减的数字")])]),s._v(" "),a("li",[a("code",[s._v("add/sub 寄存器,寄存器")])]),s._v(" "),a("li",[a("code",[s._v("add/sub 寄存器,立即数")])]),s._v(" "),a("li",[a("code",[s._v("add/sub 寄存器,内存")])]),s._v(" "),a("li",[a("code",[s._v("add/sub 内存,寄存器")])]),s._v(" "),a("li",[a("code",[s._v("add/sub 内存,立即数")])]),s._v(" "),a("li",[a("font",{staticStyle:{background:"yellow"}},[s._v("add/sub 内存,内存是不准的！")])],1)]),s._v(" "),a("div",{staticClass:"language-asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("sub eax,10\t\t\n;假设eax是变量，用C语言解释就是eax=eax-10\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("2."),a("code",[s._v("带符号")]),s._v("乘法（"),a("strong",[s._v("mul")]),s._v("tiplication,n.乘法）")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("格式1")]),s._v("：imul 目标操作数,操作数\n"),a("ul",[a("li",[s._v("imul 寄存器,寄存器")]),s._v(" "),a("li",[s._v("imul 寄存器,内存")]),s._v(" "),a("li",[a("font",{staticStyle:{background:"yellow"}},[s._v("Tips：只能是上面的，目标操作只能是寄存器")])],1)])]),s._v(" "),a("li",[a("strong",[s._v("格式2")]),s._v("：imul 目标操作数,操作数1,操作数2\n"),a("ul",[a("li",[s._v("imul 寄存器,寄存器,立即数")]),s._v(" "),a("li",[s._v("imul 寄存器,内存,立即数")])])])]),s._v(" "),a("div",{staticClass:"language-asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v(";假设eax，edi是变量，用C语言解释就是eax=eax*edi\nimul eax,edi\n;假设eax，edi是变量，用C语言解释就是eax=edi*5\nimul eax,edi,5\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("3."),a("code",[s._v("带符号")]),s._v("除法（division,n.除法）")]),s._v(" "),a("p",[s._v("idiv 除数操作数")]),s._v(" "),a("blockquote",[a("ul",[a("li",[s._v("idiv 寄存器")]),s._v(" "),a("li",[s._v("idiv 内存")])]),s._v(" "),a("blockquote",[a("ul",[a("li",[a("font",{staticStyle:{background:"yellow"}},[s._v("被除数在"),a("code",[s._v("edx:eax")]),s._v("中，此外，操作结果，"),a("code",[s._v("商送到eax")]),s._v(","),a("code",[s._v("余数送到edx")])])],1)])])]),s._v(" "),a("div",{staticClass:"language-asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("idiv ebx\nidiv dword ptr [var]\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("4.自加和自减（"),a("strong",[s._v("inc")]),s._v("rease,v.增加 / "),a("strong",[s._v("dec")]),s._v("rease,v.减少）")]),s._v(" "),a("p",[s._v("inc/dec 操作数，本来操作数分3种，但是立即数显然不能加or减")]),s._v(" "),a("ul",[a("li",[s._v("inc/dec 寄存器")]),s._v(" "),a("li",[s._v("inc/dec 内存")]),s._v(" "),a("li",[a("font",{staticStyle:{background:"yellow"}},[s._v("inc/dec 立即数显然是不准！")])],1)]),s._v(" "),a("blockquote",[a("ul",[a("li",[s._v("这就是C语言中"),a("code",[s._v("i++,--i")]),s._v("的汇编实现")])])]),s._v(" "),a("p",[s._v("5.取负（"),a("strong",[s._v("neg")]),s._v("ative，v.否定，adj.负面的）")]),s._v(" "),a("p",[s._v("neg 操作数，本来操作数分3种，但是立即数显然不能加or减")]),s._v(" "),a("ul",[a("li",[s._v("neg 寄存器")]),s._v(" "),a("li",[s._v("neg 内存")]),s._v(" "),a("li",[a("font",{staticStyle:{background:"yellow"}},[s._v("neg  立即数\t显然是不准！！！")])],1)]),s._v(" "),a("div",{staticClass:"language-asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("neg eax\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h3",{attrs:{id:"_1-3-逻辑运算指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-逻辑运算指令"}},[s._v("#")]),s._v(" 1.3.逻辑运算指令")]),s._v(" "),a("p",[a("font",{staticStyle:{background:"red"}},[s._v("位运算大类指令")])],1),s._v(" "),a("p",[s._v("1.按位取反（位翻转）指令（not）")]),s._v(" "),a("p",[s._v("not 操作数，本来操作数分3种，但是立即数显然不能加or减（因为保存不了）")]),s._v(" "),a("blockquote",[a("ul",[a("li",[a("code",[s._v("not 寄存器")])]),s._v(" "),a("li",[a("code",[s._v("not 内存")])]),s._v(" "),a("li",[a("font",{staticStyle:{background:"yellow"}},[s._v("not  立即数\t显然是不准！")])],1)])]),s._v(" "),a("div",{staticClass:"language-asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("not byte ptr [var]\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("2."),a("font",{staticStyle:{background:"yellow"}},[s._v("逻辑")]),s._v("移位指令（"),a("strong",[s._v("sh")]),s._v("ift v.移动，转移）")],1),s._v(" "),a("ul",[a("li",[s._v("shl/shr（left，逻辑左移/right，逻辑右移）")]),s._v(" "),a("li",[a("code",[s._v("shl/shr 被操作数 , 移位的位数的操作数")])])]),s._v(" "),a("div",{staticClass:"language-asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("shl eax,1\nshr ebx,2  \n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("3."),a("font",{staticStyle:{background:"yellow"}},[s._v("算术")]),s._v("移位指令（"),a("strong",[s._v("sh")]),s._v("ift v.移动，转移）（arithmetic，n.算术，算术运算）")],1),s._v(" "),a("p",[s._v("4.逻辑与，或，异或（and/or/xor）")]),s._v(" "),a("div",{staticClass:"language-asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("and eax,0fH\nor eax,0fH\nxor edx,edx\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("h3",{attrs:{id:"_1-4-控制流指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-控制流指令"}},[s._v("#")]),s._v(" 1.4.控制流指令")]),s._v(" "),a("p",[s._v("1.循环(loop)（可以说是C语言中循环的汇编语言实现）")]),s._v(" "),a("blockquote",[a("ul",[a("li",[s._v("loop 地址")])]),s._v(" "),a("blockquote",[a("ul",[a("li",[s._v("loop指令，在执行的时候，会顺序做两件事：（1）寄存器cx减一  （2）如果cx的内容不为0，则转移到指定的位置去执行，否则顺序执行后面的指令。")])])])]),s._v(" "),a("div",{staticClass:"language-asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("mov cx,5 ;循环次数\nmov si,10 ;除数\ndigit:\n     xor dx,dx\n\t div si\n\t mov [bx],dl ;保存数位\n\t inc bx\n\t loop digit\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("2.跳转（jump)（可以说是C语言中goto的汇编语言实现）")]),s._v(" "),a("blockquote",[a("ul",[a("li",[s._v("jmp 标签所在地址")])])]),s._v(" "),a("div",{staticClass:"language-.asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("begin: \nadd eax,1\njmp begin\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("3.比较和转移（可以说是C语言条件语句的汇编语言实现）")]),s._v(" "),a("blockquote",[a("ul",[a("li",[s._v("指令（1）cmp 操作数,操作数")])]),s._v(" "),a("blockquote",[a("ul",[a("li",[s._v("cmp 寄存器,寄存器")]),s._v(" "),a("li",[s._v("cmp 寄存器,立即数")]),s._v(" "),a("li",[s._v("cmp 寄存器,内存")]),s._v(" "),a("li",[s._v("cmp 内存,寄存器")])]),s._v(" "),a("blockquote",[a("ul",[a("li",[s._v("比较两个操作数的值，并且根据结果，设置eflags寄存器中的条件码")])])])]),s._v(" "),a("ul",[a("li",[s._v("指令（2）j开头的转移指令")])]),s._v(" "),a("table",[a("thead",[a("tr",[a("th",[s._v("语法")]),s._v(" "),a("th",[s._v("说明")])])]),s._v(" "),a("tbody",[a("tr",[a("td",[s._v("je 标签")]),s._v(" "),a("td",[s._v("jump when  "),a("strong",[s._v("equal")])])]),s._v(" "),a("tr",[a("td",[s._v("jne 标签")]),s._v(" "),a("td",[s._v("jump when "),a("strong",[s._v("not equal")])])]),s._v(" "),a("tr",[a("td",[s._v("jz 标签")]),s._v(" "),a("td",[s._v("jump when "),a("strong",[s._v("last reult was zero")])])]),s._v(" "),a("tr",[a("td",[s._v("jg 标签")]),s._v(" "),a("td",[s._v("jump when "),a("strong",[s._v("greater than")])])]),s._v(" "),a("tr",[a("td",[s._v("jge 标签")]),s._v(" "),a("td",[s._v("jump when "),a("strong",[s._v("greater than or equal to")])])]),s._v(" "),a("tr",[a("td",[s._v("jl 标签")]),s._v(" "),a("td",[s._v("jump when "),a("strong",[s._v("less than")])])]),s._v(" "),a("tr",[a("td",[s._v("jle 标签")]),s._v(" "),a("td",[s._v("jump when "),a("strong",[s._v("less than or equal to")])])])])]),s._v(" "),a("ul",[a("li",[s._v("代码样例")])])]),s._v(" "),a("div",{staticClass:"language-.asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("begin:\n\tinc ebx\n\tcmp eax,ebx\t\t;比较\n\tjge begin\t\t;当eax>=ebx的时候，就跳转到begin\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("4.子程序调用（C语言中函数调用的汇编实现，也解释了为什么我们自己模拟的栈比C语言自身的栈消耗资源更少）")]),s._v(" "),a("ul",[a("li",[s._v("指令1）函数调用（call）")]),s._v(" "),a("li",[s._v("指令2）函数返回（ret）")])]),s._v(" "),a("blockquote",[a("ul",[a("li",[s._v("call指令：(语法: call 标签)\n首先：将"),a("code",[s._v("当前执行指令")]),s._v("的"),a("code",[s._v("地址")]),s._v("入栈\n然后：无条件转移到由标签指示的地址的指令\nTips：和简单的跳转指令（jmp）不同，call指令保存调用之前的地址信息")]),s._v(" "),a("li",[s._v("ret指令:(语法:  ret)\n实现子程序的返回机制\nret指令首先：弹出栈中保存的指令地址\n然后：无条件转移到保存的指令地址处执行")])])]),s._v(" "),a("blockquote",[a("ul",[a("li",[s._v("用一个C语言反汇编说明（测试环境VS2012反汇编）")])])]),s._v(" "),a("div",{staticClass:"language-asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("省略——————\nint test(int a,int b)\n{\n00D41460  push        ebp  \n00D41461  mov         ebp,esp  \n00D41463  sub         esp,0C0h  \n00D41469  push        ebx  \n00D4146A  push        esi  \n00D4146B  push        edi  \n00D4146C  lea         edi,[ebp-0C0h]  \n00D41472  mov         ecx,30h  \n00D41477  mov         eax,0CCCCCCCCh  \n00D4147C  rep stos    dword ptr es:[edi]  \n\treturn a+b;\n00D4147E  mov         eax,dword ptr [a]  \n00D41481  add         eax,dword ptr [b]  \n}\n00D41484  pop         edi  \n00D41485  pop         esi  \n00D41486  pop         ebx  \n00D41487  mov         esp,ebp  \n00D41489  pop         ebp  \n00D4148A  ret \t\t\t ;调用返回\n省略------------\n\tint a=3;\n00D413EE  mov         dword ptr [a],3  \n\tint b=7;\n00D413F5  mov         dword ptr [b],7  \n\tint c=test(a,b);\n00D413FC  mov         eax,dword ptr [b]  \n00D413FF  push        eax  \n00D41400  mov         ecx,dword ptr [a]  \n00D41403  push        ecx  \n00D41404  call        _test (0D4114Ah)  ;_test是函数的符号表，编译原理中讲过。此次调用test函数\n00D41409  add         esp,8  \n00D4140C  mov         dword ptr [c],eax  \n省略------------\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br")])]),a("h3",{attrs:{id:"★1-5-其他指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#★1-5-其他指令"}},[s._v("#")]),s._v(" ★1.5.其他指令")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("cld指令（clear Direction Flag）\n无操作数指令。\n将标志寄存器（flags）的DF（Direction Flag，方向标志位）置0\n0表示，movsb或者movsw等指令的传送方向是正向的（从低地址到高地址）")])]),s._v(" "),a("li",[a("p",[s._v("std指令（set Direction Flag）\n无操作数指令。\n将标志寄存器（flags）的DF（Direction Flag，方向标志位）置0\n1表示，movsb或者movsw等指令的传送方向是反向的（从高地址到低地址）")])]),s._v(" "),a("li",[a("p",[s._v("movsb（move string byte)\n无操作数指令。\n把数据从一个地方批量传送（复制）到另一个地方，是以byte为单位")])]),s._v(" "),a("li",[a("p",[s._v("movsw（move string word)\n无操作数指令。\n把数据从一个地方批量传送（复制）到另一个地方，是以word（字）为单位")])]),s._v(" "),a("li",[a("p",[s._v("movsb和movsw要是只写他，而不加rep，则它们只能执行一次\n如果想要处理器自动的反复执行，那么要加上指令前缀rep(repeat)\n意思是cx（count Register）不为0则反复执行，")])])]),s._v(" "),a("div",{staticClass:"language-asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("rep mobsw\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h2",{attrs:{id:"_2-nasm编译指令-伪指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-nasm编译指令-伪指令"}},[s._v("#")]),s._v(" 2.NASM编译指令（"),a("font",{staticStyle:{background:"yellow"}},[s._v("伪指令")]),s._v("）")],1),s._v(" "),a("p",[s._v("也就是我们所说的"),a("font",{staticStyle:{background:"yellow"}},[s._v("伪指令")]),s._v("，不是CPU的指令")],1),s._v(" "),a("p",[s._v("1）db/dw声明一些数据\n用伪指令db声明的数据都只有一个字节的长度\n用伪指令db声明的数据都只有一个字的长度")]),s._v(" "),a("div",{staticClass:"language-.asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("db -1\t;初始化为0xFF\ndw -1\t;初始化为0xFFFF\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("2）times 是一个比较实用伪指令，用来重复定义数据或指令。")]),s._v(" "),a("div",{staticClass:"language-asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("times 510-($-$$) db 0\ndw 0xaa55\t\n;这段代码经常出现在 boot 磁盘 MBR 引导代码中\n;目的是除了最后 2 个字节和 code 代码外的区域全部写 0 值\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("times 还可以使用在重复写某一条指令")]),s._v(" "),a("div",{staticClass:"language-asm line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("times 10 nop\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("div",{staticClass:"language-txt line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-txt"}},[a("code",[s._v("这段代码结果是重复填入了 10 条 nop 指令：\n\n00000000  90                nop\n00000001  90                nop\n00000002  90                nop\n00000003  90                nop\n00000004  90                nop\n00000005  90                nop\n00000006  90                nop\n00000007  90                nop\n00000008  90                nop\n00000009  90                nop\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("h2",{attrs:{id:"_3-cpu寄存器分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-cpu寄存器分类"}},[s._v("#")]),s._v(" 3.CPU寄存器分类")]),s._v(" "),a("ul",[a("li",[s._v("CPU中寄存器大致分为两类")])]),s._v(" "),a("h3",{attrs:{id:"_3-1-用户可见"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-用户可见"}},[s._v("#")]),s._v(" 3.1.用户可见")]),s._v(" "),a("p",[a("strong",[s._v("可以")]),s._v("对这类寄存器编程"),a("br"),s._v("\neg.")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("通用")]),s._v("寄存器组")]),s._v(" "),a("li",[s._v("程序状态字寄存器")])]),s._v(" "),a("h3",{attrs:{id:"_3-2-用户不可见"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-用户不可见"}},[s._v("#")]),s._v(" 3.2.用户不可见")]),s._v(" "),a("p",[a("strong",[s._v("不可以")]),s._v("对这类寄存器编程"),a("br"),s._v("\neg.")]),s._v(" "),a("ul",[a("li",[s._v("存储器"),a("strong",[s._v("地址")]),s._v("寄存器（MAR）")]),s._v(" "),a("li",[s._v("存储器"),a("strong",[s._v("数据")]),s._v("寄存器（MDR）")]),s._v(" "),a("li",[a("strong",[s._v("指令")]),s._v("寄存器（IR）")])])])}),[],!1,null,null,null);a.default=n.exports}}]);