(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{400:function(t,s,a){"use strict";a.r(s);var n=a(14),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"part01-多进程和多线程服务器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#part01-多进程和多线程服务器"}},[t._v("#")]),t._v(" Part01.多进程和多线程服务器")]),t._v(" "),s("h2",{attrs:{id:"_1-多线程服务器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-多线程服务器"}},[t._v("#")]),t._v(" 1.多线程服务器")]),t._v(" "),s("h3",{attrs:{id:"_1-1-pthread线程库和c-11线程库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-pthread线程库和c-11线程库"}},[t._v("#")]),t._v(" 1.1.pthread线程库和C++11线程库")]),t._v(" "),s("blockquote",[s("p",[t._v("参考："),s("a",{attrs:{href:"https://developer.aliyun.com/article/383405",target:"_blank",rel:"noopener noreferrer"}},[t._v("阿里云"),s("OutboundLink")],1)])]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<pthread.h>")])]),t._v("\nLinux下"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"undefined reference to ‘pthread_create’"')]),t._v("問題解決\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("ul",[s("li",[t._v("解决方案")])]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("pthread 库不是 Linux 系统默认的库，连接时需要使用静态库libpthread"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a，所以在使用"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("创建线程，以及调用 "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_atfork")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("函数建立fork处理程序时，需要链接该库。\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("ul",[s("li",[t._v("编译的时候加上"),s("code",[t._v("-lpthread")])])]),t._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("g++ glb_var_pthrd.c "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-lpthread")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h3",{attrs:{id:"_1-2-tcp在网络编程当中的地位"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-tcp在网络编程当中的地位"}},[t._v("#")]),t._v(" 1.2.TCP在网络编程当中的地位")]),t._v(" "),s("ul",[s("li",[t._v("TCP在网络编程当中的地位，相当于你吃饭过程当中，筷子的地位")]),t._v(" "),s("li",[t._v("MTU、mss、半关闭（这是我们在TCP3次握手中，分支的一些细小的知识）")])]),t._v(" "),s("p",[s("font",{staticStyle:{background:"yellow"}},[t._v("Windows和Linux下的netstat命令的配合复习")])],1),t._v(" "),s("h2",{attrs:{id:"_2-tcp状态转换『重要』⭐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-tcp状态转换『重要』⭐"}},[t._v("#")]),t._v(" 2.TCP状态转换『重要』⭐")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("03.『TCP状态转换记忆TCP状态转换图『记忆』")])]),t._v(" "),s("li",[s("p",[t._v("Windows下可以用命令查看这些状态")])])]),t._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("netstat")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-a")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("Linux下，我们测试，服务器的命令（注意，后面的6666是端口号）")]),t._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("netstat")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-apn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("grep")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6666")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("ul",[s("li",[t._v("这是我们在网络开发过程当中，进行客户端服务器调试的，一个非常重要的依据和手段。我们可以通过我们看到的各种状态，来达到推测出，客户端或服务器当前处于服务器通信的哪个阶段。")]),t._v(" "),s("li",[t._v("有这些之后，我们就能知道，当前为什么出现这样的错误")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/status01.png",alt:"status01"}})]),t._v(" "),s("ul",[s("li",[t._v("图大致分3部分\n1.实线---主动发起连接，主动关闭连接（C或S都可能）\n2.虚线——被动发起/关闭连接\n3.小细线——两端同时操作部分。（同时，我们指的是它发送过来，我接收到了）")])]),t._v(" "),s("p",[t._v("这个图N多人都知道，它排除和定位网络或系统故障时大有帮助，但是怎样牢牢地将这张图刻在脑中呢？那么你就一定要对这张图的每一个状态，及转换的过程有深刻的认识，不能只停留在一知半解之中。下面对这张图的11种状态详细解析一下，以便加强记忆！\nC/S通信过程中，每一个阶段和服务器，它所处于的状态。")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("CLOSED")]),t._v("：表示初始状态。")]),t._v(" "),s("li",[s("code",[t._v("LISTEN")]),t._v("：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。\n"),s("code",[t._v("SYN_SENT")]),t._v("：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。")]),t._v(" "),s("li",[s("code",[t._v("SYN_RCVD")]),t._v(": 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。")]),t._v(" "),s("li",[s("code",[t._v("ESTABLISHED")]),t._v("：（三次握手已经完成）表示连接已经建立。")]),t._v(" "),s("li",[s("code",[t._v("FIN_WAIT_1")]),t._v(":  FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：\nFIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。\nFIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。")]),t._v(" "),s("li",[s("code",[t._v("FIN_WAIT_2")]),t._v("：（主动发起关闭的一端。半关闭完成）主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。")]),t._v(" "),s("li",[s("code",[t._v("TIME_WAIT")]),t._v(":（主动发起关闭的这端） 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL（我们使用的Linux下，这个时间大概是1分钟左右，等这个的目的是。我饿不确定对方是否能够收到我发送的ACK）后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。")]),t._v(" "),s("li",[s("code",[t._v("CLOSING")]),t._v(": 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。")]),t._v(" "),s("li",[s("code",[t._v("CLOSE_WAIT")]),t._v(": 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。")]),t._v(" "),s("li",[s("code",[t._v("LAST_ACK")]),t._v(": 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。")])]),t._v(" "),s("p",[t._v("问题：为啥主动关闭这一端，要设计一个"),s("code",[t._v("TIME_WAIT")]),t._v("状态？\n确保最后一个发送的ACK（主动关闭一端的）能够顺利到达。")]),t._v(" "),s("p",[t._v("其实，我们也只是了解上面的那些状态中能够被程序捕捉的，因为有的状态，转瞬即逝。")]),t._v(" "),s("h3",{attrs:{id:"_2-1-『2msl』-maximum-segment-lifetime"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-『2msl』-maximum-segment-lifetime"}},[t._v("#")]),t._v(" 2.1.『2MSL』 (Maximum Segment Lifetime)")]),t._v(" "),s("p",[t._v("TIME_WAIT状态的存在有两个理由：")]),t._v(" "),s("ul",[s("li",[t._v("（1）让4次握手关闭流程更加可靠；4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。")]),t._v(" "),s("li",[t._v("（2）防止lost duplicate对后续新建正常链接的传输造成破坏。lost uplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/temp02.png",alt:"temp02"}})]),t._v(" "),s("blockquote",[s("p",[t._v("2MSL的缺点和解决")])]),t._v(" "),s("ul",[s("li",[t._v("缺点：要等2MSL才能释放我用的那个端口号。"),s("br"),t._v("\n虽说不错，但是如果重启，这样维护需要2MSL，但是不方便。")]),t._v(" "),s("li",[t._v("解决方案：那个2MSL需要等1分钟，你继续等待1分钟，但是我们的端口允许我们重复使用。")]),t._v(" "),s("li",[t._v("端口复用")])]),t._v(" "),s("h3",{attrs:{id:"_2-2-半关闭"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-半关闭"}},[t._v("#")]),t._v(" 2.2.半关闭")]),t._v(" "),s("p",[t._v("RST指的是（标志位，和SYN啥的是对等的，实际上不太会用到，"),s("strong",[t._v("『RST表示reset』")]),t._v("）")]),t._v(" "),s("p",[t._v("从程序的角度，可以使用API来控制实现半连接状态。")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<sys/socket.h>")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("shutdown")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" sockfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" how"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nsockfd"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" 需要关闭的socket的描述符\nhow"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\t允许为shutdown操作选择以下几种方式"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SHUT_RD")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("：\t关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。\n\t\t\t\t\t该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。\n\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SHUT_WR")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\t\t关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。\n\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SHUT_RDWR")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\t关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("然后以SHUT_WR。\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),s("h2",{attrs:{id:"_3-网络套接字相关函数『记忆』"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-网络套接字相关函数『记忆』"}},[t._v("#")]),t._v(" 3.网络套接字相关函数『记忆』")]),t._v(" "),s("p",[t._v("借助套接字完成TCP下的C/S模型")]),t._v(" "),s("h3",{attrs:{id:"_3-1-字节序和主机字节序的转换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-字节序和主机字节序的转换"}},[t._v("#")]),t._v(" 3.1.字节序和主机字节序的转换")]),t._v(" "),s("p",[t._v("TCP/IP协议规定，网络数据流应采用"),s("strong",[t._v("大端字节序")]),t._v("，即低地址高字节")]),t._v(" "),s("blockquote",[s("ul",[s("li",[t._v("原因，因为TCP/IP最早诞生的时候，几乎是和Unix一块诞生的")]),t._v(" "),s("li",[t._v("那个年代，数据存储主要是IBM公司来做，那那时候，他们选用的存储方式都是大端存储法。")]),t._v(" "),s("li",[t._v("现在IBM的好多大型机，还是采用的大端法")]),t._v(" "),s("li",[t._v("后来，小端法，实际上是在Windows才有的。Intel架构的时候")]),t._v(" "),s("li",[t._v("后来在Intel架构上几乎都是用的小端法、")])])]),t._v(" "),s("p",[t._v("为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<arpa/inet.h>")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint32_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("htonl")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint32_t")]),t._v(" hostlong"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint16_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("htons")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint16_t")]),t._v(" hostshort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint32_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ntohl")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint32_t")]),t._v(" netlong"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint16_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ntohs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint16_t")]),t._v(" netshort"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[t._v("h表示host，n表示network，l表示32位长整数，s表示16位短整数。\n32位的显然是IP，16位的是端口号。\n如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。")]),t._v(" "),s("h3",{attrs:{id:"_3-3-sockaddr数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-sockaddr数据结构"}},[t._v("#")]),t._v(" 3.3.sockaddr数据结构")]),t._v(" "),s("p",[t._v("strcut sockaddr "),s("strong",[t._v("很多网络编程函数诞生早于IPv4协议（强调，理解bind等）")]),t._v("\n那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用\n传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定\n然后函数内部再强制类型转化为所需的地址类型。")]),t._v(" "),s("blockquote",[s("ul",[s("li",[t._v("由于，在其中，把结构体sockaddr改为了sockaddr_in结构体，导致编程的时候变麻烦了、")]),t._v(" "),s("li",[t._v("特别是这3个函数，他们需要的是sockaddr")]),t._v(" "),s("li",[t._v("struct sockaddr_in addr;(定义的时候，要这么定义，原因：sockaddr已经被废弃了，不能用了)")]),t._v(" "),s("li",[t._v("bind(,(struct sockaddr*)&addr );")]),t._v(" "),s("li",[t._v("accept()")]),t._v(" "),s("li",[t._v("connect()")])])]),t._v(" "),s("p",[s("font",{staticStyle:{background:"yellow"}},[t._v("我们现在讲的套接字默认指的是"),s("strong",[t._v("网络套接字")]),t._v("。注意，我们进程通信的是"),s("strong",[t._v("本地套接字")]),t._v("，所谓本地套接字就是不使用网络结构呗，不使用IP地址，但是端口号还是得用")])],1),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/temp01.png",alt:"temp01"}})]),t._v(" "),s("p",[s("font",{staticStyle:{background:"yellow"}},[t._v("上图可能疑惑点：为什么客户端没有bind呢？难度不需要绑定吗？原因：其实，你如皋没有调用，那么你的操作系统会给你"),s("strong",[t._v("自动分配")]),t._v("一个端口号和IP地址。")])],1),t._v(" "),s("p",[t._v("服务器端，肯定不能自动分配：如果这样，那我的客户端，上"),s("strong",[t._v("哪里绑定")]),t._v("去2333\n其实，客户端也可以bind，但是，我们不绑定的话，我们可以看做（隐式绑定）")]),t._v(" "),s("p",[t._v("要想通过socket完成通信，显然我们必须要创建套接字。")]),t._v(" "),s("h2",{attrs:{id:"_4-tcp的两份代码-要倒背如流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-tcp的两份代码-要倒背如流"}},[t._v("#")]),t._v(" 4.TCP的两份代码（要倒背如流）")]),t._v(" "),s("h3",{attrs:{id:"_4-1-只写了服务器端-如何测试-nc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-只写了服务器端-如何测试-nc"}},[t._v("#")]),t._v(" 4.1.只写了服务器端，如何测试？nc")]),t._v(" "),s("p",[t._v("问题来了，如果只写了服务器端，如何测试？")]),t._v(" "),s("p",[t._v("命令")]),t._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("nc")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("nc还有人读脑残。（net connect）")]),t._v(" "),s("p",[t._v("nc加上你要连接的目标IP的地址，比如说我们本机的127.0.0.1   再加上端口号")]),t._v(" "),s("p",[t._v("比如上面的程序，我们可以测试")]),t._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("nc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("127.0")]),t._v(".0.1 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6666")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("这样就可以进行")]),t._v(" "),s("p",[t._v("客户端和服务器启动后可以使用netstat命令查看链接情况：\nnetstat -apn|grep 6666")]),t._v(" "),s("p",[t._v("ARP攻击：针对你当前某一个IP地址，不断的给你发送数据包。\n那就当你当前网卡里面读取数据的那个进程给拥塞住。")]),t._v(" "),s("h2",{attrs:{id:"_4-错误处理函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-错误处理函数"}},[t._v("#")]),t._v(" 4.错误处理函数")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("错误处理函数（让网络编程程序更加健壮）（错误封装，这种思想很重要")]),t._v("）")])]),t._v(" "),s("li",[s("p",[t._v("为使错误处理的代码不影响主程序的可读性，我们把与socket相关的一些系统函数加上错误处理代码包装成新的函数，做成一个"),s("strong",[t._v("模块")]),t._v("wrap.c：")])]),t._v(" "),s("li",[s("p",[s("font",{staticStyle:{background:"yellow"}},[t._v("（也就是将我们要用到的函数重新进行封装一下，比如说listen啥的）(很好的。可以和主控程序联合编译，方式：你在程序当中要使用的所有系统调用，你都把它重命名一下，函数参数，返回值啥的都不变）")])],1)]),t._v(" "),s("li",[s("p",[t._v("模块：.c和.h")])])]),t._v(" "),s("h2",{attrs:{id:"_5-『tcp3次握手和4次挥手』"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-『tcp3次握手和4次挥手』"}},[t._v("#")]),t._v(" 5.『TCP3次握手和4次挥手』")]),t._v(" "),s("ul",[s("li",[t._v("传输层：\n1）对不稳定的网络层，完全不弥补——能不能接受到，无所谓——UDP，无连接的 『不可靠**报文（因为有去无回，所以叫报）"),s("strong",[t._v("传输（有去无回的，我们认为这个数据传输方向是单向的） 』\n2）对不稳定的网络层，做完全弥补。对我们每发的数据包进行记录，发现没有接收到，重发——TCP\n面向连接的可靠")]),t._v("数据包（难怪叫包）**传递")])]),t._v(" "),s("h3",{attrs:{id:"_2-4次挥手-原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4次挥手-原因"}},[t._v("#")]),t._v(" 2.4次挥手（原因）")]),t._v(" "),s("p",[t._v("Linux操作系统中，我允许，建立连接的双方有一端关闭连接，但是另一端不关闭。（这种状态，称为"),s("strong",[t._v("半关闭")]),t._v("）")]),t._v(" "),s("p",[t._v("场景：你那边申请结束，我虽然同意，但是我还有部分数据没有传输完，所以，我待会再和你申请，我这边的结束")]),t._v(" "),s("ul",[s("li",[t._v("疑惑：")])]),t._v(" "),s("blockquote",[s("ul",[s("li",[t._v("IP层， 我所能容纳的上限是65535（也就是16bit）（他所能容纳的数据上限是16位数，这个65535是指你网络层，如果我单独把他拎出来，单独看他，他所能够携带的数据上限是65535这么多，但是我们知道，你在网络中传输，你不能单独用IP进行传输，脱离了应用层，传输层，链路层，你根本无法传输到外面，额，这些概念真是坑）")]),t._v(" "),s("li",[t._v("以太网，所能容纳的上限是1500\n两者的关系，这就涉及到数据包在各个路由器的")])])]),t._v(" "),s("p",[t._v("虽然，IP这层设计的时候是有65535那么大，但是他会收到传输层和链路层的夹板，导致我这一个数据包，能不能带这么大的数据？？\n不能。比如，他们都比我小，我就要迁就一下他们**（难道，是几个协议封装，像板子，弄成筒子，短板效应？？对的，这个理解很好）**")]),t._v(" "),s("p",[t._v("同理，所以最后受到限制的就是以太网（链路层？？），他默认就能传，1500\n所以，虽然你IP层可以那么大，但是由于“木桶效应”，所以不能那么大。")]),t._v(" "),s("p",[t._v("其实，我们的以太网的数据包的大小，1500是符合我们日常的\n我们经常只是几KB的，所以说，1，2个数据包就过去了。\n所以，也没有必要把这个设计很大。")]),t._v(" "),s("p",[t._v("TCP还是会丢包，只是丢包，可以重传。\nUDP的话，丢包了就丢包了。")]),t._v(" "),s("h3",{attrs:{id:"_3mtu-最大传输单元"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3mtu-最大传输单元"}},[t._v("#")]),t._v(" 3MTU（最大传输单元）")]),t._v(" "),s("ul",[s("li",[t._v("通信术语： "),s("strong",[t._v("最大传输单元")]),t._v("（Maximum Transmission Unit，MTU）")])]),t._v(" "),s("p",[t._v("是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。从上面的MTU，我们引出了——"),s("strong",[t._v("最大传输大小mss")])]),t._v(" "),s("h3",{attrs:{id:"_4滑动窗口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4滑动窗口"}},[t._v("#")]),t._v(" 4滑动窗口")]),t._v(" "),s("ul",[s("li",[t._v("(TCP流量控制)")])]),t._v(" "),s("p",[t._v("介绍UDP时我们描述了这样的问题：如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会丢失数据。")]),t._v(" "),s("p",[t._v("UDP中有没有，滑动窗口这样的东西呢？因为我们知道，滑动窗口是在TCP数据包中记录的，但是UDP协议中，没有描述窗口这件事。")]),t._v(" "),s("h2",{attrs:{id:"_6-总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-总结"}},[t._v("#")]),t._v(" 6.总结")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("我们上面的多进程和多线程服务器,能不能直接用他来支持高并发啊？\n比如开个网站")])]),t._v(" "),s("li",[s("p",[t._v("**实际上是不行的！因为开销太大。**好一点的处理方式，我的服务器只有一个程序。  不应该产生这么多个.c")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("不需要，你来一个，我就产生一个线程或者进程去处理。我们后面有更好的处理方式！"),s("br"),t._v("\n就是select活poll或者epoll")])])]),t._v(" "),s("li",[s("p",[t._v("这种才是我们正儿八经去处理，高并发服务器的方法。")])]),t._v(" "),s("li",[s("p",[t._v("那么是不是多进程或者多线程是不是没用了呢？当你连接的客户端不那么多的场景，你就可以使用多线程和多进程。比如，智能家电，大概就40-50个，用多进程就好，要是还有省一点，我用多线程。几十，几百还是可以，多进程或者多线程还是可以满足的，比如，有的Linux线程能起5百多，1千多啥的。")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);