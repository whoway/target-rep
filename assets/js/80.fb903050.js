(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{372:function(t,r,a){"use strict";a.r(r);var e=a(14),s=Object(e.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"改善c-编程与设计书籍阅读笔记"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#改善c-编程与设计书籍阅读笔记"}},[t._v("#")]),t._v(" 改善C++编程与设计书籍阅读笔记")]),t._v(" "),r("div",{staticClass:"language-txt line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-txt"}},[r("code",[t._v('<font style="background:yellow">\t⭐️✔️\n<font style="background:pink">\n<font style="background: MediumSpringGreen">\n')])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br")])]),r("h2",{attrs:{id:"目录"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[t._v("#")]),t._v(" 目录")]),t._v(" "),r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#目录"}},[t._v("目录")])]),r("li",[r("a",{attrs:{href:"#《effective-c-》"}},[t._v("《Effective C++》")])]),r("li",[r("a",{attrs:{href:"#《more-effective-c-》"}},[t._v("《More Effective C++》")]),r("ul",[r("li",[r("a",{attrs:{href:"#📑基础议题-basic"}},[t._v("📑基础议题(Basic)")])]),r("li",[r("a",{attrs:{href:"#✔️1-区别pointers和references"}},[t._v("✔️1.区别pointers和references")])]),r("li",[r("a",{attrs:{href:"#✔️2-最好使用c-转型操作符"}},[t._v("✔️2.最好使用C++转型操作符")])]),r("li",[r("a",{attrs:{href:"#📑操作符-operators"}},[t._v("📑操作符(Operators)")])]),r("li",[r("a",{attrs:{href:"#_5-对定制的-类型转换函数-保持警觉"}},[t._v("5.对定制的“类型转换函数”保持警觉")])]),r("li",[r("a",{attrs:{href:"#📑异常-exceptions"}},[t._v("📑异常(Exceptions)")])]),r("li",[r("a",{attrs:{href:"#_9-利用destructors避免泄漏资源"}},[t._v("9.利用destructors避免泄漏资源")])]),r("li",[r("a",{attrs:{href:"#📑效率-efficiency"}},[t._v("📑效率(Efficiency)")])]),r("li",[r("a",{attrs:{href:"#_16-谨记80-20法则"}},[t._v("16.谨记80-20法则")])]),r("li",[r("a",{attrs:{href:"#✔️17-考虑使用-lazy-evaluation-缓式评估"}},[t._v("✔️17.考虑使用lazy evaluation(缓式评估)")])]),r("li",[r("a",{attrs:{href:"#✔️18-分期-摊还-预期的计算成本"}},[t._v("✔️18.分期“摊还”预期的计算成本")])]),r("li",[r("a",{attrs:{href:"#✔️23-考虑使用其他程序库"}},[t._v("✔️23.考虑使用其他程序库")])]),r("li",[r("a",{attrs:{href:"#⭐️技术"}},[t._v("⭐️技术")])]),r("li",[r("a",{attrs:{href:"#⭐️25-将constructor和non-member-functions虚化"}},[t._v("⭐️25.将constructor和non-member-functions虚化")])])])])])]),r("p"),t._v(" "),r("p",[t._v("[TOC]")]),t._v(" "),r("h2",{attrs:{id:"《effective-c-》"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#《effective-c-》"}},[t._v("#")]),t._v(" 《Effective C++》")]),t._v(" "),r("h2",{attrs:{id:"《more-effective-c-》"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#《more-effective-c-》"}},[t._v("#")]),t._v(" 《More Effective C++》")]),t._v(" "),r("ul",[r("li",[r("font",{staticStyle:{background:"yellow"}},[t._v("我看的是第1版，是在C++98标准出现前的，但是"),r("strong",[t._v("几乎接近C++98")]),t._v("，"),r("strong",[t._v("注意：没有C++11、14、17的特性")])])],1)]),t._v(" "),r("h3",{attrs:{id:"📑基础议题-basic"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#📑基础议题-basic"}},[t._v("#")]),t._v(" 📑基础议题(Basic)")]),t._v(" "),r("h3",{attrs:{id:"✔️1-区别pointers和references"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#✔️1-区别pointers和references"}},[t._v("#")]),t._v(" ✔️1.区别pointers和references")]),t._v(" "),r("ul",[r("li",[t._v("没有所谓的null references。一个reference必须总代表某个对象")])]),t._v(" "),r("h3",{attrs:{id:"✔️2-最好使用c-转型操作符"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#✔️2-最好使用c-转型操作符"}},[t._v("#")]),t._v(" ✔️2.最好使用C++转型操作符")]),t._v(" "),r("p",[r("font",{staticStyle:{background:"yellow"}},[t._v("在写C++的大型项目的时候，要养成用这个的习惯")])],1),t._v(" "),r("ul",[r("li",[t._v("static_cast")]),t._v(" "),r("li",[t._v("const_cast")]),t._v(" "),r("li",[t._v("reinterpret_cast")])]),t._v(" "),r("h3",{attrs:{id:"📑操作符-operators"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#📑操作符-operators"}},[t._v("#")]),t._v(" 📑操作符(Operators)")]),t._v(" "),r("h3",{attrs:{id:"_5-对定制的-类型转换函数-保持警觉"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-对定制的-类型转换函数-保持警觉"}},[t._v("#")]),t._v(" 5.对定制的“类型转换函数”保持警觉")]),t._v(" "),r("h3",{attrs:{id:"📑异常-exceptions"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#📑异常-exceptions"}},[t._v("#")]),t._v(" 📑异常(Exceptions)")]),t._v(" "),r("h3",{attrs:{id:"_9-利用destructors避免泄漏资源"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-利用destructors避免泄漏资源"}},[t._v("#")]),t._v(" 9.利用destructors避免泄漏资源")]),t._v(" "),r("p",[r("font",{staticStyle:{background:"yellow"}},[t._v("感觉这节就是RAII思想的应用")])],1),t._v(" "),r("h3",{attrs:{id:"📑效率-efficiency"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#📑效率-efficiency"}},[t._v("#")]),t._v(" 📑效率(Efficiency)")]),t._v(" "),r("h3",{attrs:{id:"_16-谨记80-20法则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_16-谨记80-20法则"}},[t._v("#")]),t._v(" 16.谨记80-20法则")]),t._v(" "),r("h3",{attrs:{id:"✔️17-考虑使用lazy-evaluation-缓式评估"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#✔️17-考虑使用lazy-evaluation-缓式评估"}},[t._v("#")]),t._v(" ✔️17.考虑使用"),r("code",[t._v("lazy evaluation(缓式评估)")])]),t._v(" "),r("p",[t._v("lazy evaluation("),r("strong",[t._v("缓式")]),t._v("评估)技巧的应用示例")]),t._v(" "),r("ul",[r("li",[t._v("引用计数")]),t._v(" "),r("li",[t._v("区分读和写\n"),r("ul",[r("li",[t._v("要借助其他写法")])])]),t._v(" "),r("li",[t._v("缓式取出")]),t._v(" "),r("li",[t._v("表达式缓评估")])]),t._v(" "),r("h3",{attrs:{id:"✔️18-分期-摊还-预期的计算成本"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#✔️18-分期-摊还-预期的计算成本"}},[t._v("#")]),t._v(" ✔️18.分期“摊还”预期的计算成本")]),t._v(" "),r("p",[t._v("over-eager evaluation("),r("strong",[t._v("超急")]),t._v("评估)做法2个")]),t._v(" "),r("ul",[r("li",[t._v("缓存，caching")]),t._v(" "),r("li",[t._v("预先取出，Prefetching\n"),r("ul",[r("li",[t._v("比如vector扩容的时候，分配2倍的策略，来自此想法")])])])]),t._v(" "),r("h3",{attrs:{id:"✔️23-考虑使用其他程序库"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#✔️23-考虑使用其他程序库"}},[t._v("#")]),t._v(" ✔️23.考虑使用其他程序库")]),t._v(" "),r("ul",[r("li",[t._v("本节大概说了：有时候你可以找找看是否存在另一个更功能相近的程序库在效率上有较高的设计权重，或许你可以改用它。就可帮助你大幅改善程序性能。")])]),t._v(" "),r("p",[t._v("iostream库和stdio库的对比")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("stdio库")]),t._v(" "),r("th",[t._v("iostream库")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("效率高")]),t._v(" "),r("td",[t._v("效率低")])]),t._v(" "),r("tr",[r("td",[t._v("stdio的可执行文件比iostream小")]),t._v(" "),r("td")]),t._v(" "),r("tr",[r("td",[t._v("stdio函数则是在「运行时期」才解析其格式字符串")]),t._v(" "),r("td",[t._v("iostream在「编译期」就决定其操作数的类型")])]),t._v(" "),r("tr",[r("td",[t._v("printf左边的特性，2者都否")]),t._v(" "),r("td",[t._v("operator<<"),r("strong",[t._v("类型安全")]),t._v("并且"),r("strong",[t._v("可扩充")])])])])]),t._v(" "),r("h3",{attrs:{id:"⭐️技术"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#⭐️技术"}},[t._v("#")]),t._v(" ⭐️技术")]),t._v(" "),r("h3",{attrs:{id:"⭐️25-将constructor和non-member-functions虚化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#⭐️25-将constructor和non-member-functions虚化"}},[t._v("#")]),t._v(" ⭐️25.将constructor和non-member-functions虚化")]),t._v(" "),r("ul",[r("li",[r("font",{staticStyle:{background:"yellow"}},[r("strong",[t._v("易错")]),t._v("：本节的意思是，“偷梁换柱”的概念，请记住："),r("strong",[t._v("constructor无法真正被虚化，non-member-functions也是")]),t._v("！")])],1)]),t._v(" "),r("p",[t._v("本书的所谓的virtual constructor是：某种函数，视其获得的输入，可产生不同类型的对象。")])])}),[],!1,null,null,null);r.default=s.exports}}]);