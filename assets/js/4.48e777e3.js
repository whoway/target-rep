(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{284:function(t,s,a){t.exports=a.p+"assets/img/进程线程与协程.52007b0a.png"},285:function(t,s,a){t.exports=a.p+"assets/img/进程控制块PCB.03966435.png"},286:function(t,s,a){t.exports=a.p+"assets/img/线程同步.3130570c.png"},421:function(t,s,a){"use strict";a.r(s);var n=a(14),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"面试题-操作系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题-操作系统"}},[t._v("#")]),t._v(" 面试题-操作系统")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("硬件")]),t._v(" "),s("th",[t._v("OS管理")]),t._v(" "),s("th",[t._v("说明")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("CPU（控制器和运算器）")]),t._v(" "),s("td",[s("strong",[t._v("进程")]),t._v("管理")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("I/O（输入和输出）")]),t._v(" "),s("td",[t._v("I/O管理")]),t._v(" "),s("td",[t._v("网络数据传输、中断、缓冲区")])]),t._v(" "),s("tr",[s("td",[t._v("存储器")]),t._v(" "),s("td",[t._v("内存管理、外存管理")]),t._v(" "),s("td",[t._v("寄存器、内存、固态/机械硬盘")])])])]),t._v(" "),s("h2",{attrs:{id:"目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[t._v("#")]),t._v(" 目录")]),t._v(" "),s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#目录"}},[t._v("目录")])]),s("li",[s("a",{attrs:{href:"#互斥锁、信号量、条件变量的区别"}},[t._v("互斥锁、信号量、条件变量的区别？")])]),s("li",[s("a",{attrs:{href:"#为什么需要虚拟内存-目的是什么"}},[t._v("为什么需要虚拟内存？目的是什么？")]),s("ul",[s("li",[s("a",{attrs:{href:"#进程和线程区别"}},[t._v("进程和线程区别")])])])]),s("li",[s("a",{attrs:{href:"#进程-线程-协程的区别"}},[t._v("进程-线程-协程的区别？")])]),s("li",[s("a",{attrs:{href:"#请你说说线程和协程的区别"}},[t._v("请你说说线程和协程的区别")])]),s("li",[s("a",{attrs:{href:"#如何实现线程池的"}},[t._v("如何实现线程池的？")])]),s("li",[s("a",{attrs:{href:"#什么叫cpu密集型和i-o密集型任务"}},[t._v("什么叫CPU密集型和I/O密集型任务？")])]),s("li",[s("a",{attrs:{href:"#什么叫-零拷贝"}},[t._v("什么叫“零拷贝”？")])]),s("li",[s("a",{attrs:{href:"#区分mmap和sendfile"}},[t._v("区分mmap和sendfile？")])]),s("li",[s("a",{attrs:{href:"#什么叫同步和异步、阻塞和非阻塞和轮询-star"}},[t._v("什么叫同步和异步、阻塞和非阻塞和轮询⭐️")]),s("ul",[s("li",[s("a",{attrs:{href:"#同步和异步"}},[t._v("同步和异步")])]),s("li",[s("a",{attrs:{href:"#阻塞和非阻塞"}},[t._v("阻塞和非阻塞")])]),s("li",[s("a",{attrs:{href:"#同步和异步-线程-间-调用"}},[t._v("同步和异步（线程==间==调用）")])]),s("li",[s("a",{attrs:{href:"#阻塞和非阻塞-线程-内-调用"}},[t._v("阻塞和非阻塞（线程==内==调用）")])])])]),s("li",[s("a",{attrs:{href:"#比较一下多cpu和多核cpu"}},[t._v("比较一下多CPU和多核cpu")])]),s("li",[s("a",{attrs:{href:"#了解什么是线程池吗-池化的概念"}},[t._v("了解什么是线程池吗？池化的概念？")])]),s("li",[s("a",{attrs:{href:"#cpu时间片多长-ieg"}},[t._v("CPU时间片多长？ieg")])]),s("li",[s("a",{attrs:{href:"#进程之间如何切换"}},[t._v("进程之间如何切换？")])]),s("li",[s("a",{attrs:{href:"#死锁预防-死锁避免-怎么区分"}},[t._v("死锁预防，死锁避免，怎么区分？")])]),s("li",[s("a",{attrs:{href:"#线程和进程对比"}},[t._v("线程和进程对比")]),s("ul",[s("li",[s("a",{attrs:{href:"#_1-1-概念-多任务"}},[t._v("1.1.概念：多任务")])]),s("li",[s("a",{attrs:{href:"#_1-2-q-多进程和多线程的对比-主要优势对比"}},[t._v("1.2.Q：多进程和多线程的对比，主要优势对比")])]),s("li",[s("a",{attrs:{href:"#_1-3-q-为什么需要多线程"}},[t._v("1.3.Q：为什么需要多线程？")])]),s("li",[s("a",{attrs:{href:"#_1-4-q-为什么任何一个线程挂掉都可能直接造成整个进程崩溃"}},[t._v("1.4.Q：为什么任何一个线程挂掉都可能直接造成整个进程崩溃？")])])])]),s("li",[s("a",{attrs:{href:"#图表记忆"}},[t._v("图表记忆")]),s("ul",[s("li",[s("a",{attrs:{href:"#图1-进程控制块-pcb"}},[t._v("图1.进程控制块（PCB）")])]),s("li",[s("a",{attrs:{href:"#解释图1-进程控制块-pcb"}},[t._v("解释图1.进程控制块（PCB）")])])])]),s("li",[s("a",{attrs:{href:"#进程同步『7侠传』进程间通信"}},[t._v("进程同步『7侠传』进程间通信")])]),s("li",[s("a",{attrs:{href:"#线程同步技术『4大天王』"}},[t._v("线程同步技术『4大天王』")])]),s("li",[s("a",{attrs:{href:"#程序员的自我修养-编码链接和库分类"}},[t._v("程序员的自我修养，编码链接和库分类")]),s("ul",[s("li",[s("a",{attrs:{href:"#进程-线程-协程区别"}},[t._v("进程-线程-协程区别")])])])]),s("li",[s("a",{attrs:{href:"#什么是上下文切换"}},[t._v("什么是上下文切换？")])]),s("li",[s("a",{attrs:{href:"#什么是tlb"}},[t._v("什么是TLB？")])]),s("li",[s("a",{attrs:{href:"#大小端之争"}},[t._v("大小端之争")]),s("ul",[s("li",[s("a",{attrs:{href:"#大端和小端存储-引子"}},[t._v("大端和小端存储-引子")])]),s("li",[s("a",{attrs:{href:"#_2-1-概念"}},[t._v("2.1.概念")])]),s("li",[s("a",{attrs:{href:"#_2-2-具体的-大端法和小端法的应用"}},[t._v("2.2.具体的，大端法和小端法的应用")])]),s("li",[s("a",{attrs:{href:"#_2-3-大端法和小端法导致的问题"}},[t._v("2.3.大端法和小端法导致的问题：")])]),s("li",[s("a",{attrs:{href:"#_2-4-如何判别大端和小端"}},[t._v("2.4.如何判别大端和小端")])])])]),s("li",[s("a",{attrs:{href:"#_3-概念辨析"}},[t._v("3.概念辨析")]),s("ul",[s("li",[s("a",{attrs:{href:"#_3-1-终端"}},[t._v("3.1.终端")])]),s("li",[s("a",{attrs:{href:"#_3-2-僵尸进程-zombie"}},[t._v("3.2.僵尸进程（Zombie）")])]),s("li",[s("a",{attrs:{href:"#_3-3-孤儿进程"}},[t._v("3.3.孤儿进程")])]),s("li",[s("a",{attrs:{href:"#_3-4-init-进程"}},[t._v("3.4.init 进程")])]),s("li",[s("a",{attrs:{href:"#_2-5-内核"}},[t._v("2.5.内核")])]),s("li",[s("a",{attrs:{href:"#_2-6-进程组-作业"}},[t._v("2.6.进程组（作业）")])]),s("li",[s("a",{attrs:{href:"#_2-7-会话-session"}},[t._v("2.7.会话（session）")])]),s("li",[s("a",{attrs:{href:"#_2-8-守护进程-daemon-『后台开发核心』"}},[t._v("2.8.守护进程（daemon）『后台开发核心』")])])])]),s("li",[s("a",{attrs:{href:"#select-poll和epoll的区别"}},[t._v("select，poll和epoll的区别？")]),s("ul",[s("li",[s("a",{attrs:{href:"#select"}},[t._v("select")])]),s("li",[s("a",{attrs:{href:"#poll"}},[t._v("poll")])]),s("li",[s("a",{attrs:{href:"#epoll-event-poll"}},[t._v("epoll(event poll)")])])])]),s("li",[s("a",{attrs:{href:"#select和epoll的区别"}},[t._v("select和epoll的区别")])]),s("li",[s("a",{attrs:{href:"#阻塞-忙等待-睡眠-挂起的理解"}},[t._v("阻塞，忙等待，睡眠，挂起的理解？")])]),s("li",[s("a",{attrs:{href:"#linux工程时间"}},[t._v("Linux工程时间")]),s("ul",[s("li",[s("a",{attrs:{href:"#查找大的日志文件的命令-美团"}},[t._v("查找大的日志文件的命令，美团")])])])])])]),s("p"),t._v(" "),s("p",[t._v("[TOC]")]),t._v(" "),s("h2",{attrs:{id:"互斥锁、信号量、条件变量的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#互斥锁、信号量、条件变量的区别"}},[t._v("#")]),t._v(" 互斥锁、信号量、条件变量的区别？")]),t._v(" "),s("ol",[s("li",[t._v("互斥锁：用于保护共享资源，使得同一时刻只有一个线程可以访问该资源。当一个线程获取到互斥锁时，其他线程必须等待该线程释放锁后才能获取锁。")]),t._v(" "),s("li",[t._v("信号量：用于控制并发线程的数量和访问某些资源的次数。信号量可以被看作一种计数器，线程需要获取访问权限时必须先尝试将信号量减1，如果信号量的值大于0，则线程可以访问资源；否则线程必须等待，直到信号量的值大于0。")]),t._v(" "),s("li",[t._v("条件变量：用于线程之间的通信和协调。当一个线程"),s("strong",[t._v("等待某个条件变为真")]),t._v("时，它可"),s("strong",[t._v("以调用条件变量上的wait()函数来挂起自己，并且会释放相应的互斥锁")]),t._v("；当另一个线程满足了条件并且调用了条件变量上的signal()或broadcast()函数时，等待的线程就会被唤醒。")])]),t._v(" "),s("h2",{attrs:{id:"为什么需要虚拟内存-目的是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要虚拟内存-目的是什么"}},[t._v("#")]),t._v(" 为什么需要虚拟内存？目的是什么？")]),t._v(" "),s("ul",[s("li",[t._v("第一，虚拟内存可以使得进程运行内存"),s("strong",[t._v("超过")]),t._v("物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。")]),t._v(" "),s("li",[t._v("第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。")]),t._v(" "),s("li",[t._v("第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写"),s("strong",[t._v("权限")]),t._v("，标记该页是否存在等。在内存访问方面，操作系统提供了更好的"),s("strong",[t._v("安全性")]),t._v("。")]),t._v(" "),s("li",[t._v("参考资料：小林coding")])]),t._v(" "),s("h3",{attrs:{id:"进程和线程区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程区别"}},[t._v("#")]),t._v(" 进程和线程区别")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th"),t._v(" "),s("th",[t._v("进程")]),t._v(" "),s("th",[t._v("线程")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("strong",[t._v("共享")]),t._v("资源")]),t._v(" "),s("td",[t._v("代码段，公共数据，进程目录，进程 ID")]),t._v(" "),s("td",[t._v("1. ⽂件描述符表"),s("br"),t._v("2. 每种信号的处理⽅式"),s("br"),t._v("3. 当前⼯作⽬录"),s("br"),t._v("4. ⽤户ID和组ID"),s("br"),t._v("3. 线程⾮共享资源")])]),t._v(" "),s("tr",[s("td",[t._v("私有资源")]),t._v(" "),s("td",[t._v("地址空间、堆、全局变量、栈、寄存器")]),t._v(" "),s("td",[t._v("1. 线程id"),s("br"),t._v("2. 处理器现场和栈指针(内核栈)"),s("br"),t._v("3. 独⽴的栈空间(⽤户空间栈)"),s("br"),t._v("4. errno变ᰁ"),s("br"),t._v("5. 信号屏蔽字 "),s("br"),t._v("6. 调度优先级")])]),t._v(" "),s("tr",[s("td",[t._v("优点")]),t._v(" "),s("td"),t._v(" "),s("td",[t._v("1. 提⾼程序并发性"),s("br"),t._v("2. 开销⼩"),s("br"),t._v("3. 数据通信、共享数据⽅便")])]),t._v(" "),s("tr",[s("td",[t._v("缺点")]),t._v(" "),s("td"),t._v(" "),s("td",[t._v("1. 库函数，不稳定"),s("br"),t._v("2. 调试、编写困难、gdb不⽀持"),s("br"),t._v("3. 对信号⽀持不好")])]),t._v(" "),s("tr",[s("td"),t._v(" "),s("td"),t._v(" "),s("td")])])]),t._v(" "),s("p",[t._v("线程如何减少开销")]),t._v(" "),s("ol",[s("li",[t._v("线程创建快，进程创建需要资源管理信息，⽐如内存管理信息和⽂件管理信息，⽽线程创建后是共享其所属进\n程的资源管理信息;")]),t._v(" "),s("li",[t._v("线程终⽌时间快，需要回收的仅有少量寄存器和私有的栈区;")]),t._v(" "),s("li",[t._v("线程切换快，因为线程"),s("strong",[t._v("切换")]),t._v("仅涉及到少量寄存器和栈区，⽽进程上下⽂切换有CPU寄存器和程序计数器(CPU\n上下⽂)、虚拟内存空间、⻚表切换、"),s("strong",[t._v("TLB失效")]),t._v("等;")]),t._v(" "),s("li",[t._v("线程因为创建时"),s("strong",[t._v("共享了")]),t._v("其所述进程绝⼤多数资源，因此天⽣具有很好的线程间通信交互效率。")])]),t._v(" "),s("h2",{attrs:{id:"进程-线程-协程的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程-线程-协程的区别"}},[t._v("#")]),t._v(" 进程-线程-协程的区别？")]),t._v(" "),s("img",{attrs:{src:a(284)}}),t._v(" "),s("table",[s("thead",[s("tr",[s("th"),t._v(" "),s("th",[t._v("进程")]),t._v(" "),s("th",[t._v("线程")]),t._v(" "),s("th",[t._v("协程")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("概念")]),t._v(" "),s("td",[t._v("一段"),s("strong",[t._v("程序")]),t._v("的执行过程 - 是"),s("strong",[t._v("资源分配")]),t._v("的最小单位")]),t._v(" "),s("td",[t._v("操作系统（内核）"),s("strong",[t._v("运算调度")]),t._v("的最小单位")]),t._v(" "),s("td",[t._v("用户态实现的"),s("strong",[t._v("运算调度")]),t._v("单位 可暂停和恢复执行的过程(函数)")])]),t._v(" "),s("tr",[s("td",[t._v("独立资源")]),t._v(" "),s("td",[t._v("- 虚拟内存空间（代码段、数据段、堆栈等） - 内核栈、thread_info、task_struct(pid,tgid等） - 寄存器组的值")]),t._v(" "),s("td",[t._v("- 线程id(pid) - 堆栈 - 寄存器组的值")]),t._v(" "),s("td",[t._v("- 栈 - 部分栈切换的寄存器")])]),t._v(" "),s("tr",[s("td",[t._v("切换代价")]),t._v(" "),s("td",[t._v("高")]),t._v(" "),s("td",[t._v("中")]),t._v(" "),s("td",[t._v("低")])]),t._v(" "),s("tr",[s("td",[t._v("通信（同步）方式")]),t._v(" "),s("td",[t._v("1. 管道/匿名管道 2. 有名管道 3. 信号 4. 消息队列 5. 共享内存 6. 信号量 7. 套接字")]),t._v(" "),s("td",[t._v("1. 锁机制 2. 信号量机制 3.信号机制")]),t._v(" "),s("td",[t._v("Future，channel, pub/sub等")])]),t._v(" "),s("tr",[s("td",[t._v("优点")]),t._v(" "),s("td",[t._v("1. 进程间相互独立，一个进程出了问题不会影响其它进程 2. 可以利用多CPU的资源")]),t._v(" "),s("td",[t._v("1. 线程之间共享内存和变量，通信比较方便 2. 程序逻辑和控制方式简单 3. 上下文切换资源消耗中等")]),t._v(" "),s("td",[t._v("1. 无须原子操作锁定及同步的开销 2. 上下文切换资源小 3. 高并发性、高扩展性、低成本")])]),t._v(" "),s("tr",[s("td",[t._v("缺点")]),t._v(" "),s("td",[t._v("1. 需要跨进程边界，当数据交流大是开销比较高 2. 创建、上下文切换开销大")]),t._v(" "),s("td",[t._v("1.线程之间的同步和加锁控制比较麻烦 2. 一个线程的崩溃可能影响到整个程序的稳定性")]),t._v(" "),s("td",[t._v("1. "),s("strong",[t._v("不能使用多核资源")])])]),t._v(" "),s("tr",[s("td",[t._v("适用场景")]),t._v(" "),s("td",[t._v("CPU密集型操作（如科学计算）")]),t._v(" "),s("td",[t._v("1. 多核CPU 2. I/O密集操作(网络I/O,磁盘I/O)")]),t._v(" "),s("td",[t._v("单核CPU "),s("strong",[t._v("I/O密集型")]),t._v("操作（网络I/O，如秒杀系统，RPC服务器，即时通讯等）")])])])]),t._v(" "),s("ul",[s("li",[t._v("参考资料：https://htmonster.xyz/blog/post/dui-bi-fen-xi-jin-cheng-xian-cheng-yu-xie-cheng/")])]),t._v(" "),s("p",[t._v("和多线程比，协程有何优势？")]),t._v(" "),s("p",[t._v("​\t最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是"),s("strong",[t._v("由程序自身控制")]),t._v("，因此，"),s("strong",[t._v("没有线程切换的开销")]),t._v("，和多线程比，线程数量越多，协程的性能优势就越明显。")]),t._v(" "),s("p",[t._v("​\t第二大优势就是"),s("strong",[t._v("不需要多线程的锁机制")]),t._v("，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。")]),t._v(" "),s("p",[t._v("​\t因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。")]),t._v(" "),s("h2",{attrs:{id:"请你说说线程和协程的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请你说说线程和协程的区别"}},[t._v("#")]),t._v(" 请你说说线程和协程的区别")]),t._v(" "),s("p",[t._v("标准回答 线程和协程的区别如下：")]),t._v(" "),s("ol",[s("li",[t._v("线程是操作系统的资源，线程的创建、切换、停止等都非常消耗资源，而创建"),s("strong",[t._v("协程")]),t._v("不需要调用操作系统的功能，编程语言自身就能完成，所以协程也被称为用户态线程，协程比线程轻量很多；")]),t._v(" "),s("li",[t._v("线程在多核环境下是能做到真正意义上的并行，而协程是为"),s("strong",[t._v("并发")]),t._v("而产生的；")]),t._v(" "),s("li",[t._v("一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要"),s("strong",[t._v("彼此协作")]),t._v("的运行；")]),t._v(" "),s("li",[t._v("线程进程都是同步机制，而协程则是异步；大多数业务场景下，"),s("strong",[t._v("线程进程可以看做是同步机制，而协程则是异步")]),t._v("。")]),t._v(" "),s("li",[t._v("线程是抢占式，而协程是"),s("strong",[t._v("非抢占式")]),t._v("的，所以需要用户自己释放使用权来切换到其他协程，因此"),s("strong",[t._v("同一时间其实只有一个协程")]),t._v("拥有运行权，相当于单线程的能力；")]),t._v(" "),s("li",[t._v("操作系统对于线程开辟数量限制在千的级别，而协程可以达到"),s("strong",[t._v("上万")]),t._v("的级别。")])]),t._v(" "),s("h2",{attrs:{id:"如何实现线程池的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何实现线程池的"}},[t._v("#")]),t._v(" 如何实现线程池的？")]),t._v(" "),s("p",[t._v("线程池的组成")]),t._v(" "),s("ol",[s("li",[t._v("线程池管理器：初始化和创建线程，启动和停止线程，调配任务；管理线程池")]),t._v(" "),s("li",[t._v("工作线程：线程池中等待并"),s("strong",[t._v("执行")]),t._v("分配的"),s("strong",[t._v("任务")])]),t._v(" "),s("li",[t._v("任务"),s("strong",[t._v("接口")]),t._v("：添加"),s("strong",[t._v("任务")]),t._v("的"),s("strong",[t._v("接口")]),t._v("，以提供工作线程调度任务的执行。")]),t._v(" "),s("li",[s("strong",[t._v("任务队列")]),t._v("：用于存放"),s("strong",[t._v("没有处理")]),t._v("的任务，提供一种缓冲机制，同时具有调度功能，高优先级的任务放在队列前面")])]),t._v(" "),s("h2",{attrs:{id:"什么叫cpu密集型和i-o密集型任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么叫cpu密集型和i-o密集型任务"}},[t._v("#")]),t._v(" 什么叫CPU密集型和I/O密集型任务？")]),t._v(" "),s("h4",{attrs:{id:"cpu密集型-cpu-bound"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cpu密集型-cpu-bound"}},[t._v("#")]),t._v(" CPU密集型（CPU-bound）")]),t._v(" "),s("div",{staticClass:"language-txt line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-txt"}},[s("code",[t._v("CPU密集型也叫计算密集型，英文为CPU-bound，直译为CPU『受限』型\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("blockquote",[s("p",[t._v("特点：")])]),t._v(" "),s("ul",[s("li",[t._v("1.是要进行大量的计算，"),s("font",{staticStyle:{background:"yellow"}},[t._v("消耗CPU资源")])],1),t._v(" "),s("li",[t._v("2.这种计算密集型任务虽然也可以用多任务完成，但是"),s("font",{staticStyle:{background:"yellow"}},[t._v("任务越多，花在『任务切换』的时间就越多，CPU执行任务的『效率』就越低")])],1),t._v(" "),s("li",[t._v("3.要最高效地利用CPU，计算密集型任务同时进行的数量应当"),s("strong",[t._v("等于")]),t._v("CPU的核心数。")])]),t._v(" "),s("h4",{attrs:{id:"i-o密集型-i-o-bound"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#i-o密集型-i-o-bound"}},[t._v("#")]),t._v(" I/O密集型（I/O-bound）")]),t._v(" "),s("ul",[s("li",[t._v("IO密集型，涉及到"),s("font",{staticStyle:{background:"yellow"}},[t._v("网络、磁盘IO")]),t._v("的任务都是IO密集型任务")],1),t._v(" "),s("li",[t._v("这类任务的特点是"),s("strong",[t._v("CPU消耗很少")]),t._v("，任务的"),s("strong",[t._v("大部分时间都在等待IO操作完成")]),t._v("（因为IO的速度远远低于CPU和内存的速度）")]),t._v(" "),s("li",[t._v("对于IO密集型任务，"),s("font",{staticStyle:{background:"yellow"}},[t._v("任务越多，CPU效率越高，但也有一个限度")]),t._v("。常见的大部分任务都是IO密集型任务，比如Web应用。")],1)]),t._v(" "),s("p",[t._v("参考资料：")]),t._v(" "),s("ul",[s("li",[t._v("维基百科："),s("a",{attrs:{href:"https://zh.wikipedia.org/wiki/CPU%E5%AF%86%E9%9B%86%E5%9E%8B",target:"_blank",rel:"noopener noreferrer"}},[t._v("CPU密集型"),s("OutboundLink")],1)]),t._v(" "),s("li",[t._v("廖雪峰描述"),s("a",{attrs:{href:"https://www.liaoxuefeng.com/wiki/897692888725344/945570591695328",target:"_blank",rel:"noopener noreferrer"}},[t._v("CPU密集型和I/O密集型"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"什么叫-零拷贝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么叫-零拷贝"}},[t._v("#")]),t._v(" 什么叫“零拷贝”？")]),t._v(" "),s("p",[t._v("​\t“零拷贝”描述了计算机操作，其中 "),s("strong",[t._v("CPU 不执行")]),t._v("将数据从"),s("strong",[t._v("一个存储区")]),t._v("复制到"),s("strong",[t._v("另一个存储区")]),t._v("的任务。通过网络传输文件时，通常用于"),s("strong",[t._v("节省CPU周期")]),t._v("和"),s("strong",[t._v("内存带宽")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("广义狭义之分")])]),t._v(" "),s("p",[t._v("​\t从上面的概念不难发现零拷贝的核心是 CPU 不执行将数据从一个存储区复制到另一个存储区的任务。可能你会说，那零拷贝是不是 0 次调用 CPU 消耗资源啊？"),s("strong",[t._v("既对也不对")]),t._v("，为什么这样说呢？实际上，零拷贝有广义和狭义之分。")]),t._v(" "),s("p",[s("strong",[t._v("1.广义零拷贝")])]),t._v(" "),s("p",[t._v("​\t能减少拷贝次数，"),s("strong",[t._v("减少不必要")]),t._v("的数据拷贝，就算作“零拷贝”。这是目前，对零拷贝"),s("strong",[t._v("最为广泛")]),t._v("的定义，我们需要知道的是，这是广义上的零拷贝，并不是操作系统意义上的零拷贝。")]),t._v(" "),s("p",[s("strong",[t._v("1.2.2 狭义零拷贝")])]),t._v(" "),s("p",[t._v("​\t"),s("strong",[t._v("Linux 2.4 内核")]),t._v("新增 "),s("strong",[t._v("sendfile")]),t._v(" 系统调用，提供了零拷贝。磁盘数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NIC Buffer(socket buffer)，无需 CPU 拷贝。这是"),s("strong",[t._v("真正操作系统意义上")]),t._v("的零拷贝(也就是狭义零拷贝)。")]),t._v(" "),s("p",[t._v("​\t比如我们常见的磁盘控制器、"),s("strong",[t._v("显卡")]),t._v("、"),s("strong",[t._v("网卡")]),t._v("、声卡都是支持 DMA 的，可以说 DMA 已经彻底融入我们的计算机世界了。")]),t._v(" "),s("ul",[s("li",[t._v("参考资料："),s("a",{attrs:{href:"https://mp.weixin.qq.com/s/GSzbiVge-aoDHxYCzCTALw",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://mp.weixin.qq.com/s/GSzbiVge-aoDHxYCzCTALw"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"区分mmap和sendfile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#区分mmap和sendfile"}},[t._v("#")]),t._v(" 区分mmap和sendfile？")]),t._v(" "),s("p",[t._v("​\t可以认为，sendfile是为了更加优化mmap来解决“零拷贝”的")]),t._v(" "),s("ul",[s("li",[t._v("sendfile，数据根本不经过用户态，直接从内核缓冲区进入到 Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换。")])]),t._v(" "),s("h2",{attrs:{id:"什么叫同步和异步、阻塞和非阻塞和轮询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么叫同步和异步、阻塞和非阻塞和轮询"}},[t._v("#")]),t._v(" 什么叫同步和异步、阻塞和非阻塞和轮询⭐️")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("同步（Synchronization）")])]),t._v(" "),s("li",[s("p",[t._v("异步（asynchronous）")])]),t._v(" "),s("li",[s("p",[t._v("阻塞（blocking）")])]),t._v(" "),s("li",[s("p",[t._v("非阻塞（ non-blocking）")])]),t._v(" "),s("li",[s("p",[t._v("轮询（polling）")])])]),t._v(" "),s("h3",{attrs:{id:"同步和异步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#同步和异步"}},[t._v("#")]),t._v(" 同步和异步")]),t._v(" "),s("p",[t._v("同步：是"),s("strong",[t._v("用户线程")]),t._v("发起IO请求需要等待或者"),s("strong",[t._v("轮询")]),t._v("内核IO操作完成后"),s("strong",[t._v("才能继续执行")]),t._v("。\n异步："),s("strong",[t._v("用户线程")]),t._v("发起IO请求后任需要"),s("strong",[t._v("继续执行")]),t._v("，当内核IO操作完成后会通知用户线程，或者调用用户注册的回调函数。")]),t._v(" "),s("h3",{attrs:{id:"阻塞和非阻塞"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#阻塞和非阻塞"}},[t._v("#")]),t._v(" 阻塞和非阻塞")]),t._v(" "),s("p",[t._v("阻塞：是指IO操作需要"),s("strong",[t._v("彻底完成后")]),t._v("才能返回用户空间。\n非阻塞：是指IO操作"),s("strong",[t._v("被调用后")]),t._v("立即返回一个状态值，无需等待IO操作完成。")]),t._v(" "),s("h3",{attrs:{id:"同步和异步-线程-间-调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#同步和异步-线程-间-调用"}},[t._v("#")]),t._v(" 同步和异步（线程==间==调用）")]),t._v(" "),s("p",[t._v("同步和异步是对应"),s("strong",[t._v("调用者")]),t._v("和"),s("strong",[t._v("被调用者")]),t._v("，他们是线程之间的关系，两个线程之间要么是同步的，要么是异步的。")]),t._v(" "),s("p",[t._v("​\t同步操作时，调用者需要"),s("strong",[t._v("等待")]),t._v("被调用者返回结果，才能进行下一步操作。")]),t._v(" "),s("p",[t._v("​\t异步操作相反，调用者不需要等待被调用者返回调用结果，即可进行下一步操作，被调用者通常依赖于"),s("strong",[t._v("事件")]),t._v("，信号，回调函数等机制来通知调用者调用结果。")]),t._v(" "),s("h3",{attrs:{id:"阻塞和非阻塞-线程-内-调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#阻塞和非阻塞-线程-内-调用"}},[t._v("#")]),t._v(" 阻塞和非阻塞（线程==内==调用）")]),t._v(" "),s("p",[t._v("阻塞和非阻塞是对于"),s("strong",[t._v("一个线程")]),t._v("来讲的，在任意时刻，线程要么是处于阻塞的，要么是处于非阻塞的。")]),t._v(" "),s("p",[t._v("​\t阻塞和非阻塞关注的程序"),s("strong",[t._v("等待调用结果（消息，返回值）==时=="),s("strong",[t._v("的状态。\n​\t"),s("strong",[t._v("阻塞调用")]),t._v("是指调用结果返回之前，"),s("strong",[t._v("当前线程")]),t._v("会被=="),s("strong",[t._v("挂起")]),t._v("==，调用线程只有在")]),t._v("得到结果之后")]),t._v("才会返回。")]),t._v(" "),s("p",[t._v("​\t"),s("strong",[t._v("非阻塞调用")]),t._v("是指不能立刻得到返回结果之前，该调用就"),s("strong",[t._v("不会阻塞")]),t._v("当前线程。")]),t._v(" "),s("ul",[s("li",[t._v("参考资料：https://blog.csdn.net/ASJBFJSB/article/details/112142339")])]),t._v(" "),s("h2",{attrs:{id:"比较一下多cpu和多核cpu"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#比较一下多cpu和多核cpu"}},[t._v("#")]),t._v(" 比较一下多CPU和多核cpu")]),t._v(" "),s("blockquote",[s("p",[s("a",{attrs:{href:"https://sunweiguo.github.io/2019/11/17/miscellany/20%E5%85%B3%E4%BA%8E%E5%A4%9ACPU%E5%92%8C%E5%A4%9A%E6%A0%B8CPU%E7%9A%84%E5%8C%BA%E5%88%AB/",target:"_blank",rel:"noopener noreferrer"}},[t._v("关于多CPU和多核CPU的区别"),s("OutboundLink")],1)])]),t._v(" "),s("div",{staticClass:"language-txt line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-txt"}},[s("code",[t._v("多进程、进程同步、进程池\n多线程、线程同步、线程池\n协程\n同步、异步、阻塞、非阻塞、轮询\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("多线程-新时代的宠儿")]),t._v(" "),s("p",[t._v("『单核CPU』时代和『多核CPU/多CPU』时代")])]),t._v(" "),s("div",{staticClass:"language-txt line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-txt"}},[s("code",[t._v("1、单CPU中进程只能是并发，多CPU计算机中进程可以并行\n2、『单CPU』『单核』中线程只能并发，『单CPU』『多核』中线程可以并行\n3、无论是并发还是并行，使用者来看，看到的是多进程，多线程\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("h2",{attrs:{id:"了解什么是线程池吗-池化的概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#了解什么是线程池吗-池化的概念"}},[t._v("#")]),t._v(" 了解什么是线程池吗？池化的概念？")]),t._v(" "),s("ul",[s("li",[t._v("进程池")]),t._v(" "),s("li",[t._v("线程池")]),t._v(" "),s("li",[t._v("数据库连接池")])]),t._v(" "),s("p",[t._v("线程池")]),t._v(" "),s("ul",[s("li",[t._v("线程池：是由服务器预先创建的一组子线程")])]),t._v(" "),s("p",[t._v("下文参考自："),s("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI1NTE3OTk4Nw==&mid=2653734974&idx=1&sn=987f9a4cfea1c830036ae20fc04866d5&chksm=f1e18582c6960c941a5e147c198d9cbc3f27e88dbb82fb62f0d23261821070bd43bdfd2fc2b2&mpshare=1&scene=23&srcid=0728Ab0PK8WsIZWsv1UoVm8L&sharer_sharetime=1595948760667&sharer_shareid=7d02bdfe8ee477ab2b773f2df63f3163#rd",target:"_blank",rel:"noopener noreferrer"}},[t._v("链接"),s("OutboundLink")],1)]),t._v(" "),s("h4",{attrs:{id:"什么是线程池"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是线程池"}},[t._v("#")]),t._v(" 什么是线程池？")]),t._v(" "),s("p",[t._v("实际开发中我们需要让程序执行某个特定任务时，就会开启一个线程，如果并发的线程数量太多，频繁地创建线程就会严重影响系统的运行效率。")]),t._v(" "),s("ul",[s("li",[t._v("如何解决上述为呢？有没有一种方式可以让线程得到复用？")]),t._v(" "),s("li",[t._v("也就是要求执行一次任务之后不被销毁，可以继续执行其他任务，这就跟“数据库连接池”的思路一样了，数据库连接池的实现逻辑是在缓冲池中预先放置一定数量的连接对象，然后进行复用，那么很显然，在缓冲池中"),s("b",[t._v("预先放置一定数量的线程对象")]),t._v("以实现复用的机制就叫做线程池。")])]),t._v(" "),s("h4",{attrs:{id:"线程池的优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程池的优点"}},[t._v("#")]),t._v(" 线程池的优点")]),t._v(" "),s("ul",[s("li",[t._v("1.使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。")]),t._v(" "),s("li",[t._v("2.可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。")])]),t._v(" "),s("h2",{attrs:{id:"cpu时间片多长-ieg"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cpu时间片多长-ieg"}},[t._v("#")]),t._v(" CPU时间片多长？ieg")]),t._v(" "),s("p",[t._v("​\tCPU时间片的长度取决于操作系统，但通常为几毫秒（ms）到几十毫秒之间。在某些操作系统中，CPU时间片可以被调整，以调整系统的性能。例如，在Linux操作系统中，可以使用"),s("code",[t._v("sched_setscheduler")]),t._v("函数来调整CPU时间片的长度。")]),t._v(" "),s("h2",{attrs:{id:"进程之间如何切换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程之间如何切换"}},[t._v("#")]),t._v(" 进程之间如何切换？")]),t._v(" "),s("p",[t._v("切换页表全局目录")]),t._v(" "),s("p",[t._v("切换内核态堆栈")]),t._v(" "),s("p",[t._v("切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）")]),t._v(" "),s("p",[t._v("ip(instruction pointer)：指向当前执行指令的下一条指令")]),t._v(" "),s("p",[t._v("bp(base pointer): 用于存放执行中的函数对应的栈帧的栈底地址")]),t._v(" "),s("p",[t._v("sp(stack poinger): 用于存放执行中的函数对应的栈帧的栈顶地址")]),t._v(" "),s("p",[t._v("cr3:页目录基址寄存器，保存页目录表的物理地址 ......")]),t._v(" "),s("p",[t._v("刷新TLB")]),t._v(" "),s("p",[t._v("系统调度器的代码执行")]),t._v(" "),s("p",[t._v("作者：流水兵\n链接：https://juejin.cn/post/7099016341805334564")]),t._v(" "),s("h2",{attrs:{id:"死锁预防-死锁避免-怎么区分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#死锁预防-死锁避免-怎么区分"}},[t._v("#")]),t._v(" 死锁预防，死锁避免，怎么区分？")]),t._v(" "),s("p",[t._v("死锁预防，是打预防针，针对4个条件破坏！")]),t._v(" "),s("p",[t._v("死锁避免是，路上有死锁的坑，我给你规划一条路线啥的，让你"),s("strong",[t._v("规避")]),t._v("死锁的可能。比如银行家算法！")]),t._v(" "),s("h2",{attrs:{id:"线程和进程对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程和进程对比"}},[t._v("#")]),t._v(" 线程和进程对比")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("进程")]),t._v("是"),s("strong",[t._v("资源管理")]),t._v("的最小单位")]),t._v(" "),s("li",[s("strong",[t._v("线程")]),t._v("是"),s("strong",[t._v("程序执行")]),t._v("的最小单位『前提是支持线程』")]),t._v(" "),s("li",[t._v("记忆方法："),s("br"),t._v(" "),s("font",{staticStyle:{background:"yellow"}},[t._v("大Boss（进程），只管拿着资源统筹兼顾。\n小兵（线程），要卖力执行命令")])],1)]),t._v(" "),s("h4",{attrs:{id:"⭐️进程和线程在两大os的特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#⭐️进程和线程在两大os的特点"}},[t._v("#")]),t._v(" ⭐️进程和线程在两大OS的特点")]),t._v(" "),s("ul",[s("li",[t._v("Windows对进程和线程的实现如同『教科书』一般标准。")])]),t._v(" "),s("blockquote",[s("ul",[s("li",[s("font",{staticStyle:{background:"yellow"}},[t._v("Windows内核中有明确的"),s("b",[t._v("进程")]),t._v("和"),s("b",[t._v("线程")]),t._v("的概念")])],1)])]),t._v(" "),s("ul",[s("li",[t._v("Linux内核中"),s("b",[t._v("并不存在真正意义上")]),t._v("的"),s("b",[t._v("线程")]),t._v("的概念")])]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" Linux将所有的执行实体（无论是进程还是线程）都称为『『任务（Task）』』\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 每个Task概念上都类似于一个单线程的进程，具有内存空间、执行实体、文件资源等。\n    \n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 不过"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("Linux下『不同的Task（任务）之间可以选择共享内存空间』，因而在实际意义上，共享了同一个内存空间的多个任务构成了一个进程， 这些任务也就成了这个进程里的线程。\n    \n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" Linux下的线程『本质』上用进程实现『牛客题目』\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("h3",{attrs:{id:"_1-1-概念-多任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-概念-多任务"}},[t._v("#")]),t._v(" 1.1.概念：多任务")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("多任务")]),t._v("可以由"),s("strong",[t._v("多进程")]),t._v("完成，也可以由一个进程内的"),s("strong",[t._v("多线程")]),t._v("完成。")])]),t._v(" "),s("h3",{attrs:{id:"_1-2-q-多进程和多线程的对比-主要优势对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-q-多进程和多线程的对比-主要优势对比"}},[t._v("#")]),t._v(" 1.2.Q：多进程和多线程的对比，主要优势对比")]),t._v(" "),s("ul",[s("li",[t._v("多进程模型，适用于：CPU密集型")]),t._v(" "),s("li",[t._v("多线程模型，"),s("strong",[t._v("主要优势")]),t._v("为：线程间切换代价较少，因此适用于I/O密集型的工作场景。\n"),s("ul",[s("li",[t._v("『因此，I/O密集型的工作场景经常会由于"),s("strong",[t._v("I/O阻塞")]),t._v("导致"),s("strong",[t._v("频繁的切换线程")]),t._v("。")])])])]),t._v(" "),s("h3",{attrs:{id:"_1-3-q-为什么需要多线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-q-为什么需要多线程"}},[t._v("#")]),t._v(" 1.3.Q：为什么需要多线程？")]),t._v(" "),s("ul",[s("li",[t._v("多线程可以提高程序的执行性能")])]),t._v(" "),s("blockquote",[s("p",[t._v("继续补充。")])]),t._v(" "),s("h3",{attrs:{id:"_1-4-q-为什么任何一个线程挂掉都可能直接造成整个进程崩溃"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-q-为什么任何一个线程挂掉都可能直接造成整个进程崩溃"}},[t._v("#")]),t._v(" 1.4.Q：为什么任何一个线程挂掉都可能直接造成整个进程崩溃？")]),t._v(" "),s("ul",[s("li",[t._v("多线程模式致命的缺点就是：因为所有线程『共享进程的内存』")])]),t._v(" "),s("h2",{attrs:{id:"图表记忆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图表记忆"}},[t._v("#")]),t._v(" 图表记忆")]),t._v(" "),s("h3",{attrs:{id:"图1-进程控制块-pcb"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图1-进程控制块-pcb"}},[t._v("#")]),t._v(" 图1.进程控制块（PCB）")]),t._v(" "),s("img",{attrs:{src:a(285)}}),t._v(" "),s("h3",{attrs:{id:"解释图1-进程控制块-pcb"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解释图1-进程控制块-pcb"}},[t._v("#")]),t._v(" 解释图1.进程控制块（PCB）")]),t._v(" "),s("p",[t._v("为了管理进程，内核必须对每个进程所做的事情进行『清楚的描述』。\n内核为每个进程分配一个"),s("code",[t._v("PCB(Processing Control Block)")]),t._v("进程控制块，维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。")]),t._v(" "),s("p",[t._v("其内部成员有很多，我们只需要掌握『"),s("strong",[t._v("以下部分")]),t._v("』即可:")]),t._v(" "),s("ul",[s("li",[t._v("进程id:系统中每个进程有唯一的id，用"),s("code",[t._v("pid_t")]),t._v("类型表示，其实就是一个非负整数")]),t._v(" "),s("li",[t._v("进程的状态:有就绪、运行、挂起、停止等状态")]),t._v(" "),s("li",[s("strong",[t._v("进程切换")]),t._v("时需要保存和恢复的一些"),s("strong",[t._v("CPU寄存器")])]),t._v(" "),s("li",[t._v("描述虚拟地址空间的信息")]),t._v(" "),s("li",[t._v("描述控制终端的信息")]),t._v(" "),s("li",[t._v("当前工作目录(Current Working Directory)")]),t._v(" "),s("li",[t._v("umask掩码")]),t._v(" "),s("li",[t._v("文件描述符表，包含很多指向"),s("code",[t._v("file结构体")]),t._v("的指针")]),t._v(" "),s("li",[t._v("和信号相关的信息")]),t._v(" "),s("li",[t._v("用户id和组id")]),t._v(" "),s("li",[t._v("会话(Session和进程组")]),t._v(" "),s("li",[t._v("进程可以使用的资源上限(Resource Limit)")])]),t._v(" "),s("h2",{attrs:{id:"进程同步『7侠传』进程间通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程同步『7侠传』进程间通信"}},[t._v("#")]),t._v(" 进程同步『7侠传』进程间通信")]),t._v(" "),s("ul",[s("li",[t._v("图片参考自：小林coding")])]),t._v(" "),s("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/3-%E6%8F%90%E7%BA%B2.jpg"}}),t._v(" "),s("ul",[s("li",[t._v("保证2点：进程同步、数据交换")])]),t._v(" "),s("h4",{attrs:{id:"⭐️2-1-管道-pipe"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#⭐️2-1-管道-pipe"}},[t._v("#")]),t._v(" ⭐️2.1.管道（PIPE）")]),t._v(" "),s("blockquote",[s("p",[t._v("(使用最简单)")])]),t._v(" "),s("ul",[s("li",[t._v("有名管道")]),t._v(" "),s("li",[t._v("无名管道\n"),s("ul",[s("li",[t._v("语法最方便，代码编写量最少。与管道对应的，另一种通信方式是"),s("strong",[t._v("fifo")]),t._v("：我们把它称之为“有名管道”，所以有书，称"),s("strong",[t._v("pipe")]),t._v("管道为：“未名管道”或者“匿名管道”,用于（"),s("strong",[t._v("非血缘关系")]),t._v("进程间通信）")])])])]),t._v(" "),s("h4",{attrs:{id:"⭐️2-2-信号量-semaphore"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#⭐️2-2-信号量-semaphore"}},[t._v("#")]),t._v(" ⭐️2.2.信号量（Semaphore）")]),t._v(" "),s("ul",[s("li",[t._v("无名线程信号量")]),t._v(" "),s("li",[t._v("命名线程信号量🔐")])]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<semaphore.h>")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//需要include这个")])]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sem_init")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sem_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("sem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" pshared"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sem_destroy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sem_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("sem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sem_wait")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sem_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("sem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sem_post")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sem_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("sem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sem_getvalue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sem_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("sem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("valp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),s("h4",{attrs:{id:"⭐️2-3-信号-signal"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#⭐️2-3-信号-signal"}},[t._v("#")]),t._v(" ⭐️2.3.信号（Signal）")]),t._v(" "),s("blockquote",[s("p",[t._v("(开销最小)")])]),t._v(" "),s("ul",[s("li",[t._v("《Unix环境高级编程》中第10章")])]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<signal.h>")]),t._v("\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//需要include这个")])]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("sighandler_t")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("sighandler_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("signal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" signum"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("sighandler_t")]),t._v(" handler"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("h4",{attrs:{id:"⭐️2-4-消息队列-message-queue-mq"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#⭐️2-4-消息队列-message-queue-mq"}},[t._v("#")]),t._v(" ⭐️2.4.消息队列（Message Queue，MQ）")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<sys/msg.h>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token expression"}},[t._v("# 消息队列相关函数及数据结构头文件")])]),t._v("\n\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("msgctl")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" msqid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" cmd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("msqid_ds")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("buf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("# 控制消息队列函数\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("msgget")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("key_t")]),t._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" msgflg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" # 创建消息队列，key值唯一标识该消息队列\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("msgrcv")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" msqid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("msg_ptr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" msg_sz"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" msgtype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" msgflg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("# 接收消息\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("msgsnd")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" msqid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("msg_ptr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" msg_sz"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" msgflg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("# 发送消息\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("h4",{attrs:{id:"⭐️2-5-共享内存-shared-memory"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#⭐️2-5-共享内存-shared-memory"}},[t._v("#")]),t._v(" ⭐️2.5.共享内存（Shared Memory）")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("相对管道，可以在"),s("strong",[t._v("没有血缘关系")]),t._v("的进程之间，完成数据传递。")])]),t._v(" "),s("li",[s("p",[t._v("共享内存有两种实现方式：1、内存映射 2、共享内存机制")])])]),t._v(" "),s("blockquote",[s("p",[t._v("1、内存映射")])]),t._v(" "),s("ul",[s("li",[t._v("内存映射"),s("code",[t._v("memory map")]),t._v("机制使进程之间通过映射同一个普通文件实现共享内存，通过"),s("code",[t._v("mmap()")]),t._v("系统调用实现。")]),t._v(" "),s("li",[t._v("普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read/write等文件操作函数。")])]),t._v(" "),s("blockquote",[s("p",[t._v("2、UNIX System V共享内存机制")])]),t._v(" "),s("ul",[s("li",[t._v("IPC的共享内存指的是把所有的共享数据放在共享内存区域（IPC shared memory region），任何想要访问该数据的进程都必须在本进程的地址空间新增一块内存区域，用来映射存放共享数据的物理内存页面。")]),t._v(" "),s("li",[t._v("和前面的mmap系统调用通过映射一个普通文件实现共享内存不同，"),s("code",[t._v("UNIX system V")]),t._v("共享内存是通过映射特殊文件系统shm中的文件实现进程间的共享内存通信。")])]),t._v(" "),s("blockquote",[s("p",[t._v("参考资料："),s("a",{attrs:{href:"https://www.cnblogs.com/LUO77/p/5816326.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("进程间通信的方式——信号、管道、消息队列、共享内存"),s("OutboundLink")],1)])]),t._v(" "),s("h4",{attrs:{id:"⭐️2-6-套接字-socket"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#⭐️2-6-套接字-socket"}},[t._v("#")]),t._v(" ⭐️2.6.套接字（Socket）")]),t._v(" "),s("ul",[s("li",[t._v("本地套接字，相较于前3种，难度最大，但是稳定性最好")])]),t._v(" "),s("h4",{attrs:{id:"⭐️2-7-比如c语言中-新建文件『已经被弃用』"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#⭐️2-7-比如c语言中-新建文件『已经被弃用』"}},[t._v("#")]),t._v(" ⭐️2.7.比如C语言中，新建文件『已经被弃用』")]),t._v(" "),s("h2",{attrs:{id:"线程同步技术『4大天王』"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程同步技术『4大天王』"}},[t._v("#")]),t._v(" 线程同步技术『4大天王』")]),t._v(" "),s("img",{attrs:{src:a(286)}}),t._v(" "),s("p",[t._v("inux下的线程创建、等待、获取线程 id")]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pthread_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("thread"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" pthread_attr_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("attr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("start_routine"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("arg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_join")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pthread_t thread"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("retval"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\npthread_t "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("ul",[s("li",[t._v("保证1点：线程同步")]),t._v(" "),s("li",[t._v("Tips：线程由于，已经共享内存空间了，所以，没有必要『数据交换』，也就不需要。")])]),t._v(" "),s("h4",{attrs:{id:"_1-锁机制-包括下面4种-lock"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-锁机制-包括下面4种-lock"}},[t._v("#")]),t._v(" 🔐1.锁机制（包括下面4种）Lock")]),t._v(" "),s("ul",[s("li",[t._v("🔐互斥量/锁（mutex）/互斥体")]),t._v(" "),s("li",[t._v("互斥锁是为实现保护共享资源而提出一种锁机制。采用互斥锁保护临界区，防止竞争条件出现。当某个线程无法获取互斥锁时，该线程会被挂起，当其他线程释放互斥锁后，操作系统会唤醒被挂起在这个锁上的线程，让其运行。")]),t._v(" "),s("li",[t._v("场景：\n"),s("ul",[s("li",[t._v("1、解决『线程安全』问题，一次只能一个线程访问被保护的资源。")]),t._v(" "),s("li",[t._v("2、被保护资源需要『睡眠』，那么可以使用互斥锁")])])]),t._v(" "),s("li",[t._v("互斥锁的优化")])]),t._v(" "),s("div",{staticClass:"language-txt line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-txt"}},[s("code",[t._v("- 在Linux下互斥锁的实现是通过『futex』这个基础组件。\n- 互斥锁加锁解锁开销很大，需要从用户态切换到内核态，上下文切换以及涉及缓存的更新等等。\n通常很多同步操作发生的时候并没有竞争的产生，此时上述开销就没有必要。\n考虑到这个因素，futex通过用户空间的共享内存以及原子操作，在共享的资源不存在竞争的时候，不会进行系统调用而是只有当竞争出现的情况下再进行系统调用陷入内核。\n进程或者线程在没有竞争的情况下可以立刻获取锁。\n具体来说，futex的优化方式如下：\nfutex将同步过程分为两个部分，一部分由内核完成，一部分由用户态完成；如果同步时没有竞争发生，那么完全在用户态处理；否则，进入内核态进行处理。\n『减少系统调用的次数，来提高系统的性能是一种合理的优化方式。』\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<pthread.h>")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//需要include的")])]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_mutex_init")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pthread_mutex_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("mutex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" pthread_mutexattr_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("mutexattr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_mutex_destroy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pthread_mutex_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("mutex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_mutex_lock")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pthread_mutex_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("mutex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_mutex_trylock")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pthread_mutex_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("mutex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_mutex_unlock")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pthread_mutex_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("mutex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("ul",[s("li",[t._v("🔐读写锁（reader-writer lock）")])]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<pthread.h>")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//需要include的")])]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_rwlock_init")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pthread_rwlock_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("restrict rwlock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pthread_rwlockattr_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("restrict attr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_rwlock_destroy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pthread_rwlock_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("rwlock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_rwlock_rdlock")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pthread_rwlock_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("rwlock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_rwlock_tryrdlock")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pthread_rwlock_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("rwlock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_rwlock_wrlock")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pthread_rwlock_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("rwlock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_rwlock_trywrlock")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pthread_rwlock_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("rwlock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_rwlock_unlock")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pthread_rwlock_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("rwlock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\n——————————————————下面是过时的——————————————————\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//这两个函数在Linux和Mac的man文档里都没有，新版的pthread.h里面也没有，旧版的能找到")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_rwlock_timedrdlock_np")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pthread_rwlock_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("rwlock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("timespec")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("deltatime"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_rwlock_timedwrlock_np")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("pthread_rwlock_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("rwlock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("timespec")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("deltatime"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br")])]),s("ul",[s("li",[t._v("🔐自旋锁（spin lock）")]),t._v(" "),s("li",[t._v("自旋锁也是为实现保护共享资源而提出一种锁机制。")]),t._v(" "),s("li",[t._v("自旋锁不会引起调用线程阻塞，如果自旋锁已经被别的线程持有，调用线程就一直循环检测是否该自旋锁已经被释放。")])]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_spin_init")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__pthread_spinlock_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("__lock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" __pshared"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_spin_destroy")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__pthread_spinlock_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("__lock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_spin_lock")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__pthread_spinlock_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("__lock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_spin_trylock")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__pthread_spinlock_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("__lock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_spin_unlock")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__pthread_spinlock_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("__lock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("ul",[s("li",[t._v("⭐️"),s("strong",[t._v("条件变量")]),t._v("（condition）")])]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<pthread.h>")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//需要include的")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_cond_init")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pthread_cond_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("restrict cond"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" pthread_condattr_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("restrict attr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_cond_destroy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pthread_cond_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("cond"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_cond_wait")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pthread_cond_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("restrict cond"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" pthread_mutex_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("restrict mutex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_cond_timedwait")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pthread_cond_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("restrict cond"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" pthread_mutex_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("restrict mutex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("timespec")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("restrict abstime"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_cond_signal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pthread_cond_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("cond"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("pthread_cond_broadcast")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pthread_cond_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("cond"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),s("h4",{attrs:{id:"⭐️2-信号量机制-semaphore"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#⭐️2-信号量机制-semaphore"}},[t._v("#")]),t._v(" ⭐️2.信号量机制（Semaphore）")]),t._v(" "),s("ul",[s("li",[t._v("无名线程信号量")]),t._v(" "),s("li",[t._v("命名线程信号量")])]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<semaphore.h>")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//需要include这个")])]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sem_init")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sem_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("sem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" pshared"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sem_destroy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sem_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("sem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sem_wait")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sem_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("sem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//（相当于加锁，表示--）")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sem_post")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sem_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("sem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//（相当于解锁，表示++）")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sem_getvalue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sem_t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("sem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("valp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nsem_trywait函数\nsem_timedwait函数\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("h4",{attrs:{id:"⭐️3-信号机制-signal"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#⭐️3-信号机制-signal"}},[t._v("#")]),t._v(" ⭐️3.信号机制（Signal）")]),t._v(" "),s("ul",[s("li",[t._v("《Unix环境高级编程》中第10章")])]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<signal.h>")]),t._v("\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//需要include这个")])]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("sighandler_t")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("sighandler_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("signal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" signum"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("sighandler_t")]),t._v(" handler"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("h4",{attrs:{id:"⭐️4-屏障-barrier"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#⭐️4-屏障-barrier"}},[t._v("#")]),t._v(" ⭐️4.屏障（barrier）")]),t._v(" "),s("blockquote",[s("p",[t._v("参考："),s("a",{attrs:{href:"https://blog.nowcoder.net/n/e26967a0bfa44ffb9836c0713412d4a7",target:"_blank",rel:"noopener noreferrer"}},[t._v("Linux C/C++ 后台开发实习生技能要求"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"程序员的自我修养-编码链接和库分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#程序员的自我修养-编码链接和库分类"}},[t._v("#")]),t._v(" 程序员的自我修养，编码链接和库分类")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("下面的说法来自《程序员的自我修养，编码链接和库》，感觉分类不正确")])]),t._v(" "),s("li",[s("p",[t._v("同步的各种锁：")])])]),t._v(" "),s("div",{staticClass:"language-txt line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-txt"}},[s("code",[t._v('（1）信号量\n（严格程度：低）二元信号量（Binary Semaphore）是最简单的一种锁，它只有两种状态:占用与非占用。\n它适合只能被唯一个线程独占访问的资源。当二元信号量处于非占用状态时，第一个试图获取该二元信号量的线程会获得该锁，并将二元信号量置为占用状态，此后其他的所有试图获取该二元信号量的线程将会等待，直到该锁被释放。\n- 对于允许多个线程并发访问的资源，<b>多元信号量简称信号量(Semaphore)</b>,它是一个很好的选择。一个初始值为N的信号量允许N个线程并发访问。线程访问资源的时候首先获取信号量，进行如下操作:\n- 将信号量的值减1。\n- 如果信号量的值小于0，则进入等待状态，否则继续执行。\n- 访问完资源之后，线程释放信号量，进行如下操作:\n- 将信号量的值加1。\n- 如果信号量的值小于1,唤醒-一个等待中的线程。\n\n\n（严格程度：中）互斥量（Mutex）和二元信号量很类似，资源仅同时允许一个线程访问，但和信号量不同的是:\n1）信号量在整个系统可以被任意线程获取并释放，也就是说，同一个信号量可以被系统中的一个线程获取之后的<font style="background: yellow">另一个线程</font>释放。\n2）互斥量则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁，其他线程越俎代庖去释放互斥量是无效的。\n\n\n\n（严格程度：高）临界区（Critical Section）是比互斥量更加严格的同步手段。\n在术语中，把临界区的锁的获取称为进入临界区,而把锁的程放称为离开临界区。\n临界区和互斥量与信号量的区别在于:\n1）<b>互斥量和信号量</b>在系统的<font style="background: yellow"><b>任何进程</b></font>里都是可见的，也就是说，一个进程创建了一个互斥量或信号量,另一个进程试图去获取该锁是合法的。\n2）<b>临界区</b>的作用范围<font style="background: yellow"><b>仅限于本进程</b></font>，其他的进程无法获取该锁。除此之外，临界区具有和互斥量相同的性质。\n\n\n\n\n（2）读写锁（Read-Write Lock）\n- 由来：对于一段数据，多个线程同时读取总是没有问题的，但假设操作都不是原子型，只要有任何一个线程试图对这个数据进行修改，就必须使用同步手段来避免出错。如果我们使用上述信号量、互斥量或临界区中的任何一种来进行同步，尽管可以保证程序正确，但<b>对于读取频繁，而仅仅偶尔写入的情况</b>，会显得非常低效。\n- 读写锁(Read-Write Lock)致力于一种更加特定的场合的同步:<b>读取频繁，偶尔写入的情况</b>\n- 读写锁可以避免这个问题。对于同一个锁，读写锁有两种获取方式，<b>共享的(Shared)</b>或<b>独占(Exclusive)</b>。\n- 当锁处于自由的状态时，试图以任何一种方式获取锁都能成功，并将锁置于对应的状态。\n- 如果锁处于共享状态，其他线程以共享的方式获取锁仍然会成功，此时这个锁分配给了多个线程。然而，如果其他线程试图以独身的方式获取已经处于共享状态的锁，那么它将必须等待锁被所有的线程释放。\n- 相应地，处于独占状态的锁将阻止任何其他线程获取该锁，不论它们试图以哪种方式获取。\n\n\n（3）条件变量（Condition Variable） 作为一种同步手段，作用类似于一个栅栏。\n- 对于条件变量，线程可以有两种操作，首先线程可以等待条件变量，一个条件变量可以被多个线程等待。\n- 其次，线程可以唤醒条件变量,此时某个或所有等待此条件变量的线程都会被唤醒并继续支持。也就是说，使用条件变量可以让许多线程-起等待某个事件的发生，当事件发生时(条件变量被唤醒)，所有的线程可以一起恢复执行。\n\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br"),s("span",{staticClass:"line-number"},[t._v("27")]),s("br"),s("span",{staticClass:"line-number"},[t._v("28")]),s("br"),s("span",{staticClass:"line-number"},[t._v("29")]),s("br"),s("span",{staticClass:"line-number"},[t._v("30")]),s("br"),s("span",{staticClass:"line-number"},[t._v("31")]),s("br"),s("span",{staticClass:"line-number"},[t._v("32")]),s("br"),s("span",{staticClass:"line-number"},[t._v("33")]),s("br"),s("span",{staticClass:"line-number"},[t._v("34")]),s("br"),s("span",{staticClass:"line-number"},[t._v("35")]),s("br"),s("span",{staticClass:"line-number"},[t._v("36")]),s("br"),s("span",{staticClass:"line-number"},[t._v("37")]),s("br"),s("span",{staticClass:"line-number"},[t._v("38")]),s("br"),s("span",{staticClass:"line-number"},[t._v("39")]),s("br")])]),s("h3",{attrs:{id:"进程-线程-协程区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程-线程-协程区别"}},[t._v("#")]),t._v(" 进程-线程-协程区别")]),t._v(" "),s("h4",{attrs:{id:"协程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协程"}},[t._v("#")]),t._v(" 协程")]),t._v(" "),s("ul",[s("li",[t._v("又称微线程，纤程。英文名"),s("strong",[t._v("Coroutine")]),t._v("。")])]),t._v(" "),s("p",[t._v("协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("参考资料："),s("a",{attrs:{href:"https://www.liaoxuefeng.com/wiki/1016959663602400/1017968846697824",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.liaoxuefeng.com/wiki/1016959663602400/1017968846697824"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[t._v("维基百科："),s("a",{attrs:{href:"https://zh.m.wikipedia.org/zh-hans/%E5%8D%8F%E7%A8%8B",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://zh.m.wikipedia.org/zh-hans/%E5%8D%8F%E7%A8%8B"),s("OutboundLink")],1)])])]),t._v(" "),s("h2",{attrs:{id:"什么是上下文切换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是上下文切换"}},[t._v("#")]),t._v(" 什么是上下文切换？")]),t._v(" "),s("ul",[s("li",[t._v("定义："),s("strong",[t._v("上下文切换")]),t._v("(英语：context switch)，又称"),s("strong",[t._v("环境切换")]),t._v("，电脑术语，是一个"),s("strong",[t._v("存储")]),t._v("和"),s("strong",[t._v("重建")]),t._v("CPU的"),s("strong",[t._v("状态")]),t._v(" ("),s("strong",[t._v("内文")]),t._v(")，因此令多个进程(process)可以分享单一CPU资源的计算过程。要切换CPU上的进程时，必需先行存储目前进程的状态，再将欲运行的进程之状态读回CPU中。")]),t._v(" "),s("li",[t._v("开销：上下文切换通常是『"),s("strong",[t._v("计算密集型")]),t._v("』的，『"),s("strong",[t._v("操作系统中的许多设计都是针对上下文切换的优化")]),t._v("』。在进程间切换需要消耗一定的时间进行相关的管理工作——包括寄存器和内存映射的保存与读取、更新各种内部的表等等。处理器或者操作系统不同，上下文切换时所涉及的内容也不尽相同。比如在Linux内核中，上下文切换需要涉及寄存器、栈指针、程序计数器的切换，但和地址空间的切换无关（虽然进程在进行上下文切换时也需要做地址空间的切换）[2][3]。用户态线程之间也会发生类似的上下文切换，但这样的切换非常轻量。")])]),t._v(" "),s("div",{staticClass:"language-txt line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-txt"}},[s("code",[t._v("『CPU 寄存器』和『程序计数器』就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，必须的依赖环境。\n\nCPU 寄存器是 CPU 内置的容量小、但速度极快的内存。『这是个比方，不是真实的』\n程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("ul",[s("li",[t._v("根据 Tsuna 的测试报告，每次上下文切换都需要『"),s("strong",[t._v("几十ns到数us")]),t._v("』的 CPU 时间。这个时间还是相当可观的，特别是在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。这也正是导致平均负载升高的一个重要因素。")]),t._v(" "),s("li",[t._v("另外，我们知道， Linux 通过 "),s("strong",[t._v("TLB（Translation Lookaside Buffer）"),s("strong",[t._v("来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，T")]),t._v("LB 也需要刷新，内存的访问也会随之变慢『因为命中的原因』")]),t._v("。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。")])]),t._v(" "),s("blockquote",[s("p",[t._v("维基百科："),s("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BA%A4%E6%8F%9B",target:"_blank",rel:"noopener noreferrer"}},[t._v("上下文切换"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("知乎："),s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/52845869",target:"_blank",rel:"noopener noreferrer"}},[t._v("上下文切换"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"什么是tlb"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是tlb"}},[t._v("#")]),t._v(" 什么是TLB？")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("TLB（Translation Lookaside Buffer，"),s("strong",[t._v("转译后备缓冲器")]),t._v("/页表缓存）")])]),t._v(" "),s("li",[s("p",[t._v("在中国大陆被翻译为"),s("strong",[t._v("页表缓存")]),t._v("、"),s("strong",[t._v("转址旁路缓存")]),t._v("，为"),s("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%A4%AE%E8%99%95%E7%90%86%E5%99%A8",target:"_blank",rel:"noopener noreferrer"}},[t._v("CPU"),s("OutboundLink")],1),t._v("的一种缓存，由"),s("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83",target:"_blank",rel:"noopener noreferrer"}},[t._v("存储器管理单元"),s("OutboundLink")],1),t._v("用于改进"),s("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E4%BD%8D%E5%9D%80",target:"_blank",rel:"noopener noreferrer"}},[t._v("虚拟地址"),s("OutboundLink")],1),t._v("到物理地址的转译速度")])]),t._v(" "),s("li",[s("p",[t._v("『进程』切换期间，TLB会被刷新，从而使内存访问在一段时间内变得更加昂贵。")])])]),t._v(" "),s("blockquote",[s("p",[t._v("知乎："),s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/108425561",target:"_blank",rel:"noopener noreferrer"}},[t._v("TLB原理"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("维基百科："),s("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E8%BD%89%E8%AD%AF%E5%BE%8C%E5%82%99%E7%B7%A9%E8%A1%9D%E5%8D%80",target:"_blank",rel:"noopener noreferrer"}},[t._v("TLB原理"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"大小端之争"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#大小端之争"}},[t._v("#")]),t._v(" 大小端之争")]),t._v(" "),s("p",[t._v("大小端（BigEndianLittleEndian）")]),t._v(" "),s("h3",{attrs:{id:"大端和小端存储-引子"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#大端和小端存储-引子"}},[t._v("#")]),t._v(" 大端和小端存储-引子")]),t._v(" "),s("ul",[s("li",[t._v("《格列夫游记》一书中讲到，格列佛在小人国中，遇到了“"),s("a",{attrs:{href:"https://blog.csdn.net/linghaidong/article/details/50242233",target:"_blank",rel:"noopener noreferrer"}},[t._v("大小端"),s("OutboundLink")],1),t._v("的事情”。在计算机界，也有一个类似的大端小端之争，随着计算机的发展，历史告诉我们，这些都是合理的，但是要在计算机间合理通信或者理解计算机底层的时候，你自己记得转换就好了。")])]),t._v(" "),s("h3",{attrs:{id:"_2-1-概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-概念"}},[t._v("#")]),t._v(" 2.1.概念")]),t._v(" "),s("p",[t._v("大端：指低字节存储在高地址。\n小端：指低字节存储在低地址。")]),t._v(" "),s("p",[s("strong",[t._v("记忆方法：")])]),t._v(" "),s("p",[s("font",{staticStyle:{background:"yellow"}},[t._v("小端说：我就是个低低（弟弟）")])],1),t._v(" "),s("p",[t._v("下图描述了——大端存储（低字节存储在内存高地址了）：\n"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/1.png",alt:"1"}})]),t._v(" "),s("p",[t._v("下图描述了——小端存储（低字节存储在内存低地址了）：："),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HACV/picture/img/2.png",alt:"2"}})]),t._v(" "),s("h3",{attrs:{id:"_2-2-具体的-大端法和小端法的应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-具体的-大端法和小端法的应用"}},[t._v("#")]),t._v(" 2.2.具体的，大端法和小端法的应用")]),t._v(" "),s("p",[t._v("有的产品用的大端法，有的产品则是小端法。\nPS:"),s("strong",[t._v("这个大端和小端并没有严格按照企业界限来区分")]),t._v("，因为有的企业，它在之前采用的处理器，可能是大端，但是后面的产品中改变了采用的处理器，可能就采用小端法了。\n前沿：许多比较新的微处理器使用双端法，也就是说可以把它们配置成作为大端或者小端的机器运行。")]),t._v(" "),s("h3",{attrs:{id:"_2-3-大端法和小端法导致的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-大端法和小端法导致的问题"}},[t._v("#")]),t._v(" 2.3.大端法和小端法导致的问题：")]),t._v(" "),s("ul",[s("li",[t._v("1）网络应用程序数据传输")])]),t._v(" "),s("p",[t._v("在采用不同大小端存储的机器之间通过网络传送二进制数据时候，会导致采用不同大小端存储方式的数据的字节变成反序。\n网络字节序\n网络上传输的数据都是字节流,对于一个多字节数值，在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题;\nUDP/TCP/IP协议规定:\n把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;")]),t._v(" "),s("p",[t._v("而在发送端发送数据时，发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);\n由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的;所以说,网络字节序是大端字节序;")]),t._v(" "),s("p",[t._v("比如,我们经过网络发送整型数值0x12345678时,在80x86平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数将其转换成大端法存放的数值;")]),t._v(" "),s("p",[t._v("常见CPU的宇节序\n大端（big Endian）: PowerPC、IBM、 Sun\n小端（little Endian）:x86、DEC\n"),s("strong",[t._v("ARM既可以工作在大端模式,也可以工作在小端模式")])]),t._v(" "),s("ul",[s("li",[t._v("2）反汇编的时候")])]),t._v(" "),s("p",[t._v("（—未完待续）")]),t._v(" "),s("h3",{attrs:{id:"_2-4-如何判别大端和小端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-如何判别大端和小端"}},[t._v("#")]),t._v(" 2.4.如何判别大端和小端")]),t._v(" "),s("p",[t._v("1）我们可以根据C语言中的，联合体来判断，该系统是大端还是小端。\n因为，联合体变量总是从低地址存储。")]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("union")]),t._v(" test\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("demo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\n\tdemo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x01ffff03")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%d"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("demo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x03")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("demo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"这个机器是小端存储！"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x00")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v("demo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"这个机器是大端存储！"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"无法判断机器类型！"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br"),s("span",{staticClass:"line-number"},[t._v("27")]),s("br")])]),s("p",[t._v("显然，\n要是小端存储，那么（低字节）0x03在低地址，\n要是大端存储，那么（高字节）0x00在低地址。\n所以，打印出3就是小端存储。打印出0那就是大端存储。\n笔者的电脑是采用的intel的X86CPU，是小端存储。")]),t._v(" "),s("div",{staticClass:"language-txt line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-txt"}},[s("code",[t._v("输出是3\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h2",{attrs:{id:"_3-概念辨析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-概念辨析"}},[t._v("#")]),t._v(" 3.概念辨析")]),t._v(" "),s("h3",{attrs:{id:"_3-1-终端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-终端"}},[t._v("#")]),t._v(" 3.1.终端")]),t._v(" "),s("p",[t._v("计算机中的终端：是所有"),s("strong",[t._v("输入输出")]),t._v("设备的『总称』。")]),t._v(" "),s("ul",[s("li",[t._v("键盘，鼠标，摄像头")]),t._v(" "),s("li",[t._v("屏幕，打印机")])]),t._v(" "),s("p",[t._v("虚拟机那个黑框框。是终端，是『"),s("strong",[t._v("虚拟终端")]),t._v("』，不是真实存在的"),s("br"),t._v("\n输入可以在这，输出也在这出，又输入有输出")]),t._v(" "),s("ul",[s("li",[t._v("终端在我们系统的级别分，大致如下：")]),t._v(" "),s("li",[t._v("1、Alt + Ctrl + F1、F2、F3、F4、F5、F6\t"),s("strong",[t._v("字符终端")]),t._v("   pts (pseudo terminal slave) 指伪终端。")]),t._v(" "),s("li",[t._v("2、Alt + F7\t\t"),s("strong",[t._v("图形终端")])]),t._v(" "),s("li",[t._v("3、ssh、telnet...\t\t"),s("strong",[t._v("网络终端")]),t._v("（比如用Xshell啥的，通过网络传输到主机上）")])]),t._v(" "),s("h3",{attrs:{id:"_3-2-僵尸进程-zombie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-僵尸进程-zombie"}},[t._v("#")]),t._v(" 3.2.僵尸进程（Zombie）")]),t._v(" "),s("ul",[s("li",[t._v("参考"),s("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B",target:"_blank",rel:"noopener noreferrer"}},[t._v("wiki"),s("OutboundLink")],1)])]),t._v(" "),s("div",{staticClass:"language-txt line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-txt"}},[s("code",[t._v("僵尸进程（僵死进程）: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。\n\n注意:僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止。\n\n思考！用什么办法可清除掉僵尸进程呢？\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("ul",[s("li",[s("p",[s("strong",[t._v("僵尸进程")]),t._v(": （死亡的子进程，但不回收）进程终止，父进程尚未回收，子进程残留资源（PCB）存放于"),s("strong",[t._v("内核")]),t._v("中，变成僵尸（Zombie）进程\n（父进程有义务将子进程回收。如果子进程死完之后，要是父进程不给子进程收尸，子进程就成僵尸了）")])]),t._v(" "),s("li",[s("p",[t._v("变成僵尸进程的危害?")])]),t._v(" "),s("li",[s("div",{staticClass:"language-txt line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-txt"}},[s("code",[t._v("1、正常进程结束之后，0-3G的进程（用户空间）地址空间，都会被释放。子进程整个0-3G的地址空间都被释放。\n2、但是，唯独PCB残留到内核当中，残留的目的是，为了让父进程给他报仇。因为，子进程死了，不留下点什么痕迹，父进程怎么知道你子进程是怎么死的？？他杀，还是自杀『自行结束』\n3、父进程可以通过PCB来获取它的死亡状态，如果你是自杀，还算了\n4、如果你是他杀，父进程需要采取措施，给你报仇？？？PCB存在的意义是为了，方便父进程收尸，如果父进程比较粗心大意，不管，那么那个PCB就一直存在内核当中。 这样会造成溢出，所以编程的时候，记得要回收僵尸进程\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])])])]),t._v(" "),s("h3",{attrs:{id:"_3-3-孤儿进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-孤儿进程"}},[t._v("#")]),t._v(" 3.3.孤儿进程")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("孤儿进程")]),t._v(": "),s("strong",[t._v("父进程先于子进程结束")]),t._v("，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。（操作系统让孤儿进程进入“进程孤儿院”（不对吧）。也就是被init进程收养）（有人叫init进程叫进程孤儿院）")])]),t._v(" "),s("h3",{attrs:{id:"_3-4-init-进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-init-进程"}},[t._v("#")]),t._v(" 3.4.init 进程")]),t._v(" "),s("ul",[s("li",[t._v("init进程："),s("strong",[t._v("系统初始化进程")]),t._v("，是所有用户进程和非调度进程的祖先")]),t._v(" "),s("li",[t._v("init进程是『1号进程』，所有进程原先的祖先")]),t._v(" "),s("li",[t._v("0号进程是『不会』在操作系统中实际存在的")])]),t._v(" "),s("h3",{attrs:{id:"_2-5-内核"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-内核"}},[t._v("#")]),t._v(" 2.5.内核")]),t._v(" "),s("h3",{attrs:{id:"_2-6-进程组-作业"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-进程组-作业"}},[t._v("#")]),t._v(" 2.6.进程组（作业）")]),t._v(" "),s("p",[t._v("一个作业通常包括程序、数据和『操作说明书』3部分。\n每一个进程由PCB、程序和数据集合组成。这说明程序是进程的一部分，是进程的实体。\n因此，一个作业可划分为若干个进程来完成，而每一个进程有其实体————程序和数据集合。")]),t._v(" "),s("p",[t._v("1、『"),s("strong",[t._v("有的书上叫“作业”")]),t._v("，重要！』只不过"),s("font",{staticStyle:{background:"yellow"}},[t._v("在不同操作系统下，叫法不同而已。")]),s("br"),t._v("\n2、作业这个概念，早先的时候，来源于BSD操作系统")],1),t._v(" "),s("ul",[s("li",[t._v("BSD于1980年前后向Unix中增加的一个新特性。")]),t._v(" "),s("li",[t._v("代表一个或多个进程的集合。"),s("strong",[t._v("每个进程都属于一个进程组")]),t._v("。")])]),t._v(" "),s("p",[t._v("可以用kill，进行进程组ID取负号的方式，来杀死整个组内的进程。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("组长进程")]),t._v("可以创建一个进程组")])]),t._v(" "),s("h3",{attrs:{id:"_2-7-会话-session"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-会话-session"}},[t._v("#")]),t._v(" 2.7.会话（session）")]),t._v(" "),s("ul",[s("li",[t._v("会话（session）：把"),s("font",{staticStyle:{background:"yellow"}},[t._v("一组『"),s("strong",[t._v("进程组")]),t._v("』再重新编号")]),t._v("，就变成了会话。（圈圈圆圆圈圈，禁止套娃2333）")],1)]),t._v(" "),s("p",[t._v("创建一个会话需要注意以下6点"),s("strong",[t._v("注意事项")]),t._v("：")]),t._v(" "),s("ol",[s("li",[t._v("调用进程"),s("strong",[t._v("不能")]),t._v("是进程组组长，该进程变成新会话"),s("strong",[t._v("首进程")]),t._v("(session Leader)（简称，“会长”，滑稽）")]),t._v(" "),s("li",[t._v("该进程成为一个新进程组的组长进程。")]),t._v(" "),s("li",[t._v("需有root权限(ubuntu不需要)")]),t._v(" "),s("li",[t._v("新会话丢弃原有的控制终端，该会话没有控制终端（只在后台执行）")]),t._v(" "),s("li",[t._v("该调用进程是组长进程，则出错返回")]),t._v(" "),s("li",[t._v("建立新会话时，先调用fork, 父进程终止，子进程调用setsid")])]),t._v(" "),s("p",[t._v("Q：要"),s("strong",[t._v("会话ID")]),t._v("干啥？")]),t._v(" "),s("p",[t._v("A：主要是为了，守护进程用")]),t._v(" "),s("h3",{attrs:{id:"_2-8-守护进程-daemon-『后台开发核心』"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-守护进程-daemon-『后台开发核心』"}},[t._v("#")]),t._v(" 2.8.守护进程（daemon）『后台开发核心』")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("守护进程（daemon进程/精灵进程）")]),t._v("：“系统进程”与终端无关，不由用户启动，通常也叫做守护进程，是Linux/Unix『"),s("strong",[t._v("内核")]),t._v("』专用的特殊进程，是Linux中的"),s("strong",[t._v("后台服务进程")]),t._v("，通常独立于『控制终端』并且周"),s("strong",[t._v("期性地")]),t._v("执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。")]),t._v(" "),s("li",[t._v("守护进程，说白了，就是一个后台系统服务器。")])]),t._v(" "),s("blockquote",[s("ul",[s("li",[t._v("比如，Linux中的vsftpd，搭建ftp服务器的，安装+启动，httpd，sshd,xinetd")])])]),t._v(" "),s("ul",[s("li",[t._v("FAQ：只要是后台的，有没有终端？？没有！")]),t._v(" "),s("li",[s("b",[t._v("注意：")]),t._v("守护进程不受用户登录、注销的影响，当然，机器重启就另说了,但是厉害的守护进程，比如vsftpd和mysql等，你关机再开机，它也跟着启动")])]),t._v(" "),s("h4",{attrs:{id:"创建守护进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建守护进程"}},[t._v("#")]),t._v(" 创建守护进程")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("创建守护进程，最关键的一步是调用setsid函数"),s("strong",[t._v("创建一个新的会话（Session）")]),t._v("，并成为Session Leader。")])]),t._v(" "),s("li",[s("p",[t._v("当然，你也可以写这样的守护进程，比")]),t._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("vim")]),t._v(" .bashrc\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("ul",[s("li",[t._v("这是bash解析器的配置文件，每次加载bash的时候都是按照这个去走。\n显然设置这个，就可以让完成那样的守护进程。启动放这个里面。")]),t._v(" "),s("li",[t._v("为什么，要用会话呢？")]),t._v(" "),s("li",[s("font",{staticStyle:{background:"yellow"}},[t._v("因为守护进程都不需要控制终端")])],1)])])]),t._v(" "),s("h4",{attrs:{id:"_2-创建守护进程模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-创建守护进程模型"}},[t._v("#")]),t._v(" 2.创建守护进程模型")]),t._v(" "),s("ol",[s("li",[t._v("创建子进程，父进程退出\n所有工作在子进程中进行形式上脱离了控制终端")]),t._v(" "),s("li",[t._v("在子进程中创建新会话（主要，为了丢弃终端）\n　　\tsetsid()函数\n　　\t使子进程完全独立出来，脱离控制")]),t._v(" "),s("li",[t._v("改变当前目录为根目录\n　　\tchdir()函数\n　　\t防止占用可卸载的文件系统（比如，U盘）\n　　\t也可以换成其它路径")]),t._v(" "),s("li",[t._v("重设文件权限掩码\n　　\tumask()函数\n　　\t防止继承的文件创建屏蔽字拒绝某些权限\n　　\t增加守护进程灵活性")]),t._v(" "),s("li",[t._v("关闭文件描述符\n　　\t继承的打开文件不会用到，浪费系统资源，无法卸载")]),t._v(" "),s("li",[t._v("开始执行守护进程核心工作（守护进程主逻辑）")]),t._v(" "),s("li",[t._v("守护进程退出处理程序模型（几乎不会用，毕竟守护进程一般不退出）")])]),t._v(" "),s("ul",[s("li",[t._v("轮询（polling）")])]),t._v(" "),s("h2",{attrs:{id:"select-poll和epoll的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#select-poll和epoll的区别"}},[t._v("#")]),t._v(" select，poll和epoll的区别？")]),t._v(" "),s("p",[t._v("​\t多路复⽤接⼝ select/poll/epoll ，内核提供给⽤户态的多路复⽤系统调⽤，进程可以通过⼀个"),s("strong",[t._v("系统调⽤函数")]),t._v("从内核 中获取多个事件：")]),t._v(" "),s("p",[t._v("（1）select--\x3e两次遍历+两次拷⻉")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("把已连接的socket放在⼀个⽂件描述符集合，调⽤ select 函数将⽂件描述符集合拷⻉到内核⾥，让内核来检 查是否有⽹络事件产⽣；")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[t._v("通过遍历，有事件产⽣就把此socket标记为可读/可写，然后再"),s("strong",[t._v("整个")]),t._v("拷⻉回⽤户态；")])]),t._v(" "),s("li",[s("p",[t._v("⽤户态还需要遍历找到刚刚标记的socket。")])])])])]),t._v(" "),s("h3",{attrs:{id:"select"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#select"}},[t._v("#")]),t._v(" select")]),t._v(" "),s("p",[t._v("本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：")]),t._v(" "),s("p",[s("strong",[t._v("1、 单个进程可监视的fd数量被限制，即能监听端口的大小有限。")])]),t._v(" "),s("p",[t._v("一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.")]),t._v(" "),s("p",[s("strong",[t._v("2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：")])]),t._v(" "),s("p",[t._v("当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。")]),t._v(" "),s("p",[t._v("「因而，我们认为select也是"),s("strong",[t._v("水平触发")]),t._v("的」")]),t._v(" "),s("p",[s("strong",[t._v("3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大")])]),t._v(" "),s("h3",{attrs:{id:"poll"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#poll"}},[t._v("#")]),t._v(" poll")]),t._v(" "),s("p",[t._v("​\tpoll本质上和select没有区别，它将用户"),s("strong",[t._v("传入的数组")]),t._v("拷贝到内核空间，然后"),s("strong",[t._v("内核空间内部")]),t._v("用"),s("strong",[t._v("链表")]),t._v("组织他们，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。")]),t._v(" "),s("p",[t._v("​\t它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：")]),t._v(" "),s("ul",[s("li",[t._v("大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。")]),t._v(" "),s("li",[t._v("poll还有一个特点是“"),s("strong",[t._v("水平触发")]),t._v("”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。")])]),t._v(" "),s("p",[t._v("动态数组，以链表形式来组织，相⽐于select，没有⽂件描述符个数限制，当然还会受到系统⽂件描述符限制。")]),t._v(" "),s("h3",{attrs:{id:"epoll-event-poll"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#epoll-event-poll"}},[t._v("#")]),t._v(" epoll(event poll)")]),t._v(" "),s("ol",[s("li",[t._v("在"),s("strong",[t._v("内核⾥")]),t._v("使⽤"),s("strong",[t._v("红⿊树")]),t._v("来跟踪进程所有待检测的⽂件描述字。")]),t._v(" "),s("li",[t._v("调⽤epoll_ctl() 函数，把需要监控的 socket 加⼊内核中的红⿊树⾥：（红⿊树的增删查时间复杂度是\nO(logn)，不需要每次操作都传⼊整个集合，只需要"),s("strong",[t._v("传⼊⼀个待检测的socket")]),t._v("，减少了内核和⽤户空间的⼤ᰁ\n数据拷⻉和内存分配）")]),t._v(" "),s("li",[t._v("epoll 使⽤"),s("strong",[t._v("事件驱动")]),t._v("的机制，内核⾥维护了⼀个"),s("strong",[t._v("链表")]),t._v("来记录就绪事件（当某个 socket 有事件发⽣时，通过回\n调函数，内核会将其加⼊到这个"),s("strong",[t._v("就绪事件列表")]),t._v("中）")]),t._v(" "),s("li",[t._v("当⽤户调⽤ epoll_wait() 函数时，"),s("strong",[t._v("只会返回有事件")]),t._v("发⽣的⽂件描述符的个数，不需要像 select/poll 那样轮询\n"),s("strong",[t._v("扫描整个 socket 集合")]),t._v("，⼤⼤提⾼了检测的效率。")]),t._v(" "),s("li",[t._v("epoll⽀持的事件触发模式：(1)边缘触发ET (2)⽔平触发LT。")]),t._v(" "),s("li",[t._v("边缘触发模式ET\n当被监控的 Socket 描述符上有可读事件发⽣时，服务器只会从 epoll_wait中苏醒⼀次，即使进程没有调⽤\nread 函数从内核读取数据，也依然只苏醒⼀次，因此我们程序要保证⼀次性将内核缓冲区的数据读取完，只\n有第⼀次满⾜条件的时候才触发，之后就不会再传递同样的事件了。")]),t._v(" "),s("li",[t._v("⽔平触发模式LT\n当被监控的 Socket 上有可读事件发⽣时，服务器不断地从 epoll_wait中苏醒，直到内核缓冲区数据被 read\n函数读完才结束，⽬的是告诉我们有数据，只要满⾜事件的条件，⽐如内核中有数据需要读，就⼀直不断地把\n这个事件传递给⽤户。")])]),t._v(" "),s("h2",{attrs:{id:"select和epoll的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#select和epoll的区别"}},[t._v("#")]),t._v(" select和epoll的区别")]),t._v(" "),s("ol",[s("li",[t._v("select 和 poll 采⽤"),s("strong",[t._v("轮询")]),t._v("的⽅式检查就绪事件，每次都要扫描整个⽂件描述符，复杂度"),s("strong",[t._v("O(N)")]),t._v(";")]),t._v(" "),s("li",[t._v("epoll 采⽤"),s("strong",[t._v("回调⽅式")]),t._v("检查就绪事件，只会返回有事件发⽣的⽂件描述符的个数，复杂度O(1);")]),t._v(" "),s("li",[t._v("select 只⼯作在低效的LT模式，epoll 可以在 ET ⾼效模式⼯作;")]),t._v(" "),s("li",[t._v("epoll 是 Linux 所特有，⽽ select 则应该是 POSIX 所规定，⼀般操作系统均有实现;")]),t._v(" "),s("li",[t._v("select 单个进程可监视的fd数ᰁ有限，即能监听端⼝的⼤⼩有限，64位是2048；epoll 没有最⼤并发连接的限\n制，能打开的 fd 的上限"),s("strong",[t._v("远⼤于2048")]),t._v("（1G的内存上能监听约"),s("strong",[t._v("10万")]),t._v("个端⼝）;")]),t._v(" "),s("li",[t._v("select：内核需要将消息传递到⽤户空间，都需要内核拷⻉动作；epoll通过内核和⽤户空间"),s("strong",[t._v("共享⼀块内存")]),t._v("来实\n现的。")])]),t._v(" "),s("h2",{attrs:{id:"阻塞-忙等待-睡眠-挂起的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#阻塞-忙等待-睡眠-挂起的理解"}},[t._v("#")]),t._v(" 阻塞，忙等待，睡眠，挂起的理解？")]),t._v(" "),s("p",[s("strong",[t._v("阻塞")]),t._v("是线程自己发现没资源，获取不到资源，它自己先去休息了，有资源它"),s("strong",[t._v("会自己回来")]),t._v("，而且不占用CPU。")]),t._v(" "),s("p",[s("strong",[t._v("忙等待")]),t._v("是指线程找不到资源就"),s("strong",[t._v("一直等")]),t._v("，并且"),s("strong",[t._v("将CPU占据")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("睡眠")]),t._v("是指CPU告诉线程，你先去休息，过规定时间，你"),s("strong",[t._v("自己回来")]),t._v("。「线程主动睡眠的」")]),t._v(" "),s("p",[s("strong",[t._v("挂起")]),t._v("是指CPU告诉线程你先去休息，有资源"),s("strong",[t._v("我告诉你")]),t._v("。它会"),s("strong",[t._v("释放CPU")]),t._v("。「线程主动挂起的」")]),t._v(" "),s("h2",{attrs:{id:"linux工程时间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux工程时间"}},[t._v("#")]),t._v(" Linux工程时间")]),t._v(" "),s("h3",{attrs:{id:"查找大的日志文件的命令-美团"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#查找大的日志文件的命令-美团"}},[t._v("#")]),t._v(" 查找大的日志文件的命令，美团")]),t._v(" "),s("h4",{attrs:{id:"_1如果想要查看正在滚动的日志文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1如果想要查看正在滚动的日志文件"}},[t._v("#")]),t._v(" 1如果想要查看正在滚动的日志文件")]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("tail "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("f "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("filename"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("Ctrl + c 终止 tail 命令\nCtrl + s 暂停("),s("strong",[t._v("stop")]),t._v(") tail 命令\nCtrl + q 继续 tail 命令")]),t._v(" "),s("h4",{attrs:{id:"_2如果文件比较大的话-也可以使用-less-命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2如果文件比较大的话-也可以使用-less-命令"}},[t._v("#")]),t._v(" 2如果文件比较大的话，也可以使用 less 命令")]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("tail "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10000")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" less "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 从第 10000 开始,使用 less 查看。")]),t._v("\ntail  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("n "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10000")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" less "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 查看倒数第 1000 行到文件最后的数据。 ")]),t._v("\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("与其说是查看大日志文件的方法，不如说是将 grep/awk/sed/head/less/tail "),s("strong",[t._v("多个命令结合")]),t._v("起来的方法。")]),t._v(" "),s("p",[t._v("其实最重要的不是怎么看大文件，还是在程序运行时候，就要对日志文件进行归档整理，例如，每天一次归档，或者每满 500M 就归档。\n当然大公司会用例如 ELK 之类的日志处理系统。")]),t._v(" "),s("ul",[s("li",[t._v("参考"),s("a",{attrs:{href:"https://blog.csdn.net/stupid56862/article/details/93330203",target:"_blank",rel:"noopener noreferrer"}},[t._v("资料"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=r.exports}}]);