<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++面试题 | whoway</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/images/photo.jpg">
    <link rel="manifest" href="/images/photo.jpg">
    <link rel="apple-touch-icon" href="/images/photo.jpg">
    <meta name="description" content="Personal Blog Website">
    <meta http-quiv="pragma" cotent="no-cache">
    <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
    <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.a88dafb3.css" as="style"><link rel="preload" href="/assets/js/app.096c6153.js" as="script"><link rel="preload" href="/assets/js/2.82e96f38.js" as="script"><link rel="preload" href="/assets/js/1.6e29662b.js" as="script"><link rel="preload" href="/assets/js/18.3c3b6709.js" as="script"><link rel="prefetch" href="/assets/js/10.4125d26f.js"><link rel="prefetch" href="/assets/js/100.442e699b.js"><link rel="prefetch" href="/assets/js/101.e8477ad2.js"><link rel="prefetch" href="/assets/js/102.cd57d924.js"><link rel="prefetch" href="/assets/js/103.85a37cdf.js"><link rel="prefetch" href="/assets/js/104.4a4d1084.js"><link rel="prefetch" href="/assets/js/105.dc280445.js"><link rel="prefetch" href="/assets/js/106.b4a2a375.js"><link rel="prefetch" href="/assets/js/107.b19df920.js"><link rel="prefetch" href="/assets/js/108.6139b76c.js"><link rel="prefetch" href="/assets/js/109.9296b402.js"><link rel="prefetch" href="/assets/js/11.72ae73cf.js"><link rel="prefetch" href="/assets/js/110.10871dfc.js"><link rel="prefetch" href="/assets/js/111.58f94c4e.js"><link rel="prefetch" href="/assets/js/112.ded82414.js"><link rel="prefetch" href="/assets/js/113.11c96811.js"><link rel="prefetch" href="/assets/js/114.1c7d45b0.js"><link rel="prefetch" href="/assets/js/115.0545b224.js"><link rel="prefetch" href="/assets/js/116.46a6be05.js"><link rel="prefetch" href="/assets/js/117.7b143c89.js"><link rel="prefetch" href="/assets/js/118.7a8ec9a4.js"><link rel="prefetch" href="/assets/js/119.525cef5e.js"><link rel="prefetch" href="/assets/js/12.e97e2b38.js"><link rel="prefetch" href="/assets/js/120.e0b5d3bf.js"><link rel="prefetch" href="/assets/js/121.fe2dad47.js"><link rel="prefetch" href="/assets/js/122.d723b62c.js"><link rel="prefetch" href="/assets/js/123.83a57ee4.js"><link rel="prefetch" href="/assets/js/124.593594a6.js"><link rel="prefetch" href="/assets/js/125.d9b41b27.js"><link rel="prefetch" href="/assets/js/126.252a10fc.js"><link rel="prefetch" href="/assets/js/127.3be2f500.js"><link rel="prefetch" href="/assets/js/128.93447629.js"><link rel="prefetch" href="/assets/js/129.ebeccb40.js"><link rel="prefetch" href="/assets/js/13.a837e57b.js"><link rel="prefetch" href="/assets/js/130.a974dd12.js"><link rel="prefetch" href="/assets/js/131.3394103b.js"><link rel="prefetch" href="/assets/js/132.26e0df2e.js"><link rel="prefetch" href="/assets/js/133.0b85914a.js"><link rel="prefetch" href="/assets/js/134.d6685713.js"><link rel="prefetch" href="/assets/js/135.cc161ed5.js"><link rel="prefetch" href="/assets/js/136.766ac744.js"><link rel="prefetch" href="/assets/js/137.66660d03.js"><link rel="prefetch" href="/assets/js/138.9679de34.js"><link rel="prefetch" href="/assets/js/139.275fc698.js"><link rel="prefetch" href="/assets/js/14.db05e204.js"><link rel="prefetch" href="/assets/js/140.38a18f4b.js"><link rel="prefetch" href="/assets/js/141.ce58f2a3.js"><link rel="prefetch" href="/assets/js/142.579c0772.js"><link rel="prefetch" href="/assets/js/143.625d23e6.js"><link rel="prefetch" href="/assets/js/144.5e10409f.js"><link rel="prefetch" href="/assets/js/145.493291b1.js"><link rel="prefetch" href="/assets/js/146.17c89392.js"><link rel="prefetch" href="/assets/js/147.b57e9c52.js"><link rel="prefetch" href="/assets/js/148.78cde617.js"><link rel="prefetch" href="/assets/js/149.a502af70.js"><link rel="prefetch" href="/assets/js/15.df39777f.js"><link rel="prefetch" href="/assets/js/150.63db8346.js"><link rel="prefetch" href="/assets/js/151.2173e2e7.js"><link rel="prefetch" href="/assets/js/152.2d629cc4.js"><link rel="prefetch" href="/assets/js/153.502a328d.js"><link rel="prefetch" href="/assets/js/154.3e1926aa.js"><link rel="prefetch" href="/assets/js/155.0636a681.js"><link rel="prefetch" href="/assets/js/156.8a6f1ebe.js"><link rel="prefetch" href="/assets/js/157.d2a8a965.js"><link rel="prefetch" href="/assets/js/158.8ac3306e.js"><link rel="prefetch" href="/assets/js/159.e055a8d0.js"><link rel="prefetch" href="/assets/js/16.3e7c2e4a.js"><link rel="prefetch" href="/assets/js/160.371a361f.js"><link rel="prefetch" href="/assets/js/161.2efe17fc.js"><link rel="prefetch" href="/assets/js/162.6bbcbbff.js"><link rel="prefetch" href="/assets/js/163.37a48200.js"><link rel="prefetch" href="/assets/js/164.2d838bfb.js"><link rel="prefetch" href="/assets/js/165.c1b4d204.js"><link rel="prefetch" href="/assets/js/166.37d7a5da.js"><link rel="prefetch" href="/assets/js/167.780f4e8a.js"><link rel="prefetch" href="/assets/js/168.13d6b083.js"><link rel="prefetch" href="/assets/js/169.4b1aa290.js"><link rel="prefetch" href="/assets/js/17.13f9f737.js"><link rel="prefetch" href="/assets/js/170.4cd0184a.js"><link rel="prefetch" href="/assets/js/171.6b07c9a4.js"><link rel="prefetch" href="/assets/js/172.6c697ba1.js"><link rel="prefetch" href="/assets/js/173.bdce2864.js"><link rel="prefetch" href="/assets/js/174.8032634d.js"><link rel="prefetch" href="/assets/js/175.d33b6240.js"><link rel="prefetch" href="/assets/js/176.0c208a2f.js"><link rel="prefetch" href="/assets/js/177.9de67074.js"><link rel="prefetch" href="/assets/js/178.4080814d.js"><link rel="prefetch" href="/assets/js/179.f6e967b4.js"><link rel="prefetch" href="/assets/js/180.c5eddd0b.js"><link rel="prefetch" href="/assets/js/181.92ff4fe2.js"><link rel="prefetch" href="/assets/js/182.b70eb286.js"><link rel="prefetch" href="/assets/js/183.e1defe6b.js"><link rel="prefetch" href="/assets/js/184.36d9dd36.js"><link rel="prefetch" href="/assets/js/185.019af986.js"><link rel="prefetch" href="/assets/js/186.fcab1fa6.js"><link rel="prefetch" href="/assets/js/187.73b1acc5.js"><link rel="prefetch" href="/assets/js/188.4687ba55.js"><link rel="prefetch" href="/assets/js/189.11969005.js"><link rel="prefetch" href="/assets/js/19.2299b1be.js"><link rel="prefetch" href="/assets/js/190.36070d74.js"><link rel="prefetch" href="/assets/js/191.68aff6a7.js"><link rel="prefetch" href="/assets/js/192.b095a041.js"><link rel="prefetch" href="/assets/js/193.748e4741.js"><link rel="prefetch" href="/assets/js/194.15f17e59.js"><link rel="prefetch" href="/assets/js/195.3c783c3f.js"><link rel="prefetch" href="/assets/js/196.0794f81d.js"><link rel="prefetch" href="/assets/js/197.2ed93d9e.js"><link rel="prefetch" href="/assets/js/198.96fecbb8.js"><link rel="prefetch" href="/assets/js/199.6730c3ef.js"><link rel="prefetch" href="/assets/js/20.f9542a81.js"><link rel="prefetch" href="/assets/js/200.77513dbb.js"><link rel="prefetch" href="/assets/js/201.7b3a2883.js"><link rel="prefetch" href="/assets/js/202.fa63bc61.js"><link rel="prefetch" href="/assets/js/203.3d75280f.js"><link rel="prefetch" href="/assets/js/204.5256956c.js"><link rel="prefetch" href="/assets/js/205.55fbd2b0.js"><link rel="prefetch" href="/assets/js/206.3dcbd0db.js"><link rel="prefetch" href="/assets/js/207.0279f524.js"><link rel="prefetch" href="/assets/js/208.76a1b1e4.js"><link rel="prefetch" href="/assets/js/209.0d34367b.js"><link rel="prefetch" href="/assets/js/21.3aeaccd0.js"><link rel="prefetch" href="/assets/js/210.34ae4ebf.js"><link rel="prefetch" href="/assets/js/211.927b9a9a.js"><link rel="prefetch" href="/assets/js/212.04674f6d.js"><link rel="prefetch" href="/assets/js/213.af5c8a97.js"><link rel="prefetch" href="/assets/js/214.9eb288c9.js"><link rel="prefetch" href="/assets/js/215.35540374.js"><link rel="prefetch" href="/assets/js/216.7aa3f39a.js"><link rel="prefetch" href="/assets/js/217.9f03eb88.js"><link rel="prefetch" href="/assets/js/218.3202edd3.js"><link rel="prefetch" href="/assets/js/219.0e1b57a4.js"><link rel="prefetch" href="/assets/js/22.d3c40f77.js"><link rel="prefetch" href="/assets/js/220.a4ff506d.js"><link rel="prefetch" href="/assets/js/221.ce788053.js"><link rel="prefetch" href="/assets/js/222.03492588.js"><link rel="prefetch" href="/assets/js/223.ddb53555.js"><link rel="prefetch" href="/assets/js/224.8a2983dc.js"><link rel="prefetch" href="/assets/js/225.264b8d29.js"><link rel="prefetch" href="/assets/js/226.5ac964a0.js"><link rel="prefetch" href="/assets/js/227.dc1e85d1.js"><link rel="prefetch" href="/assets/js/228.96f0b395.js"><link rel="prefetch" href="/assets/js/229.f4283581.js"><link rel="prefetch" href="/assets/js/23.cb26fc0f.js"><link rel="prefetch" href="/assets/js/230.ff93981b.js"><link rel="prefetch" href="/assets/js/231.ae27a7a8.js"><link rel="prefetch" href="/assets/js/232.e32b9f90.js"><link rel="prefetch" href="/assets/js/233.fdb2c42f.js"><link rel="prefetch" href="/assets/js/234.ce4f9957.js"><link rel="prefetch" href="/assets/js/235.b4675bb3.js"><link rel="prefetch" href="/assets/js/236.2cce5658.js"><link rel="prefetch" href="/assets/js/237.0a4d13ae.js"><link rel="prefetch" href="/assets/js/238.0ff3aed6.js"><link rel="prefetch" href="/assets/js/239.264b97af.js"><link rel="prefetch" href="/assets/js/24.ad4a09fe.js"><link rel="prefetch" href="/assets/js/240.c24807d4.js"><link rel="prefetch" href="/assets/js/241.17758192.js"><link rel="prefetch" href="/assets/js/242.d03f4f96.js"><link rel="prefetch" href="/assets/js/243.a7dd7ff1.js"><link rel="prefetch" href="/assets/js/244.1b0a261c.js"><link rel="prefetch" href="/assets/js/245.50dedbe7.js"><link rel="prefetch" href="/assets/js/246.89acce1d.js"><link rel="prefetch" href="/assets/js/247.73c8a853.js"><link rel="prefetch" href="/assets/js/25.5570ebb6.js"><link rel="prefetch" href="/assets/js/26.a95f7f8b.js"><link rel="prefetch" href="/assets/js/27.f7494f1f.js"><link rel="prefetch" href="/assets/js/28.e162e0ed.js"><link rel="prefetch" href="/assets/js/29.c58cfc51.js"><link rel="prefetch" href="/assets/js/3.21405e5e.js"><link rel="prefetch" href="/assets/js/30.211d4847.js"><link rel="prefetch" href="/assets/js/31.2d1e7ba7.js"><link rel="prefetch" href="/assets/js/32.add4b5b0.js"><link rel="prefetch" href="/assets/js/33.14f76adb.js"><link rel="prefetch" href="/assets/js/34.6bd9d647.js"><link rel="prefetch" href="/assets/js/35.c9e2d3b8.js"><link rel="prefetch" href="/assets/js/36.298abfc6.js"><link rel="prefetch" href="/assets/js/37.27b5bd91.js"><link rel="prefetch" href="/assets/js/38.b557122e.js"><link rel="prefetch" href="/assets/js/39.5df6f441.js"><link rel="prefetch" href="/assets/js/4.0c822be5.js"><link rel="prefetch" href="/assets/js/40.94e5fd0a.js"><link rel="prefetch" href="/assets/js/41.84557a0b.js"><link rel="prefetch" href="/assets/js/42.59206b92.js"><link rel="prefetch" href="/assets/js/43.a3c01942.js"><link rel="prefetch" href="/assets/js/44.da5d7fba.js"><link rel="prefetch" href="/assets/js/45.d1f42d3c.js"><link rel="prefetch" href="/assets/js/46.9c2d814b.js"><link rel="prefetch" href="/assets/js/47.420ad5a7.js"><link rel="prefetch" href="/assets/js/48.89a9add5.js"><link rel="prefetch" href="/assets/js/49.3a140b3a.js"><link rel="prefetch" href="/assets/js/5.dabc057c.js"><link rel="prefetch" href="/assets/js/50.abf53b06.js"><link rel="prefetch" href="/assets/js/51.550faa15.js"><link rel="prefetch" href="/assets/js/52.4c02b872.js"><link rel="prefetch" href="/assets/js/53.5f129ed6.js"><link rel="prefetch" href="/assets/js/54.0c94f990.js"><link rel="prefetch" href="/assets/js/55.6545b6b6.js"><link rel="prefetch" href="/assets/js/56.2a7ad851.js"><link rel="prefetch" href="/assets/js/57.094e449c.js"><link rel="prefetch" href="/assets/js/58.445238dd.js"><link rel="prefetch" href="/assets/js/59.b17bca8b.js"><link rel="prefetch" href="/assets/js/6.9c63f7c1.js"><link rel="prefetch" href="/assets/js/60.7fc004f8.js"><link rel="prefetch" href="/assets/js/61.9fb2478f.js"><link rel="prefetch" href="/assets/js/62.2debfb43.js"><link rel="prefetch" href="/assets/js/63.58fdf77c.js"><link rel="prefetch" href="/assets/js/64.8217a7d2.js"><link rel="prefetch" href="/assets/js/65.9dc85131.js"><link rel="prefetch" href="/assets/js/66.59484eda.js"><link rel="prefetch" href="/assets/js/67.f07c80d0.js"><link rel="prefetch" href="/assets/js/68.80cf9893.js"><link rel="prefetch" href="/assets/js/69.3373b3fe.js"><link rel="prefetch" href="/assets/js/7.f0f3f996.js"><link rel="prefetch" href="/assets/js/70.7e6b8764.js"><link rel="prefetch" href="/assets/js/71.4a331c2e.js"><link rel="prefetch" href="/assets/js/72.9a62b8a8.js"><link rel="prefetch" href="/assets/js/73.af14b76f.js"><link rel="prefetch" href="/assets/js/74.e544cbd5.js"><link rel="prefetch" href="/assets/js/75.a738e3ab.js"><link rel="prefetch" href="/assets/js/76.10685154.js"><link rel="prefetch" href="/assets/js/77.e22947af.js"><link rel="prefetch" href="/assets/js/78.870cb46a.js"><link rel="prefetch" href="/assets/js/79.cf6e348f.js"><link rel="prefetch" href="/assets/js/80.2a21e5a4.js"><link rel="prefetch" href="/assets/js/81.03872ae2.js"><link rel="prefetch" href="/assets/js/82.c4c97962.js"><link rel="prefetch" href="/assets/js/83.41c6d463.js"><link rel="prefetch" href="/assets/js/84.d1b60af2.js"><link rel="prefetch" href="/assets/js/85.50a21654.js"><link rel="prefetch" href="/assets/js/86.fed3d86f.js"><link rel="prefetch" href="/assets/js/87.0b8526ca.js"><link rel="prefetch" href="/assets/js/88.3c9947a1.js"><link rel="prefetch" href="/assets/js/89.78802633.js"><link rel="prefetch" href="/assets/js/90.df50cd93.js"><link rel="prefetch" href="/assets/js/91.84df794e.js"><link rel="prefetch" href="/assets/js/92.c78b9106.js"><link rel="prefetch" href="/assets/js/93.881884a8.js"><link rel="prefetch" href="/assets/js/94.73e6568d.js"><link rel="prefetch" href="/assets/js/95.1dff6783.js"><link rel="prefetch" href="/assets/js/96.8cb67535.js"><link rel="prefetch" href="/assets/js/97.7fcc0840.js"><link rel="prefetch" href="/assets/js/98.5df2c457.js"><link rel="prefetch" href="/assets/js/99.94a157f6.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.857e8e87.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a88dafb3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">whoway</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/1Db/" class="nav-link">
  💾数据库
</a></div><div class="nav-item"><a href="/2Net/" class="nav-link">
  🔗网络
</a></div><div class="nav-item"><a href="/3Language/" class="nav-link router-link-active">
  语言
</a></div><div class="nav-item"><a href="/4Linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/5Coding/" class="nav-link">
  Coding
</a></div><div class="nav-item"><a href="/6MacOS/" class="nav-link">
  MacOS
</a></div><div class="nav-item"><a href="/7Windows/" class="nav-link">
  Windows
</a></div><div class="nav-item"><a href="/8Engineer/" class="nav-link">
  🔖基础软件
</a></div><div class="nav-item"><a href="/9Status/" class="nav-link">
  网站动态
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/1Db/" class="nav-link">
  💾数据库
</a></div><div class="nav-item"><a href="/2Net/" class="nav-link">
  🔗网络
</a></div><div class="nav-item"><a href="/3Language/" class="nav-link router-link-active">
  语言
</a></div><div class="nav-item"><a href="/4Linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/5Coding/" class="nav-link">
  Coding
</a></div><div class="nav-item"><a href="/6MacOS/" class="nav-link">
  MacOS
</a></div><div class="nav-item"><a href="/7Windows/" class="nav-link">
  Windows
</a></div><div class="nav-item"><a href="/8Engineer/" class="nav-link">
  🔖基础软件
</a></div><div class="nav-item"><a href="/9Status/" class="nav-link">
  网站动态
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++面试题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#📑-目录" class="sidebar-link">📑 目录</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#✅虚函数" class="sidebar-link">✅虚函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-虚函数表vtbl" class="sidebar-link">1.虚函数表vtbl</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-构造一个「派生类」对象的过程" class="sidebar-link">2.构造一个「派生类」对象的过程</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-1-是先构造父类的「虚表指针」还是先构造父类的「成员」" class="sidebar-link">2.1.是先构造父类的「虚表指针」还是先构造父类的「成员」？</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-2-「虚表指针」和「构造函数体」那个先被构造" class="sidebar-link">2.2.「虚表指针」和「构造函数体」那个先被构造？</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-c-「运行构造函数」的时候「虚函数表」被构造出来了么" class="sidebar-link">3.c++「运行构造函数」的时候「虚函数表」被构造出来了么？</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_4-析构一个「派生类」object的过程" class="sidebar-link">4.析构一个「派生类」object的过程</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#✅基础" class="sidebar-link">✅基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-vector是线程安全的吗" class="sidebar-link">1.vector是线程安全的吗？</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-c-是不是类型安全的呢" class="sidebar-link">2.C++是不是类型安全的呢？</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-sizeof只有1个虚析构函数的空类呢" class="sidebar-link">3.sizeof只有1个虚析构函数的空类呢？</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_4-构造函数为什么不能是虚函数" class="sidebar-link">4.构造函数为什么不能是虚函数？</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_5-为何空类的大小不是零" class="sidebar-link">5.为何空类的大小不是零？</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_6-我能从构造函数调用虚函数吗" class="sidebar-link">6.我能从构造函数调用虚函数吗？</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_7-内存泄露及解决办法" class="sidebar-link">7.内存泄露及解决办法：</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_8-怎么检测内存泄漏" class="sidebar-link">8.怎么检测内存泄漏？</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_9-初始化顺序" class="sidebar-link">9.初始化顺序</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#✅平常做题错题" class="sidebar-link">✅平常做题错题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-测试" class="sidebar-link">1.测试</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-在-c-语言中-对函数参数默认值描述正确的是" class="sidebar-link">2.在 c++ 语言中，对函数参数默认值描述正确的是？</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#✅c-输入输出io" class="sidebar-link">✅C++输入输出IO</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-iostream的设计初衷" class="sidebar-link">1.iostream的设计初衷</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-iostream的特点" class="sidebar-link">2.iostream的特点</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-c-惯用法" class="sidebar-link">1.C++惯用法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-1-raii-资源获取即初始化" class="sidebar-link">1.1.RAII(资源获取即初始化)</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-2-pimpl" class="sidebar-link">1.2.pImpl</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-3-copy-and-swap" class="sidebar-link">1.3.copy and swap</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-value-semantics和object-semantics" class="sidebar-link">2.value semantics和object semantics</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-1-值语义-value-semantics" class="sidebar-link">2.1.值语义（value semantics）</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-2-对象语义-object-semantics" class="sidebar-link">2.2.对象语义（object semantics）</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-3-优点缺点对比" class="sidebar-link">2.3.优点缺点对比</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-c-惯用法和value-semantics组合拳" class="sidebar-link">3.C++惯用法和value semantics组合拳</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-1-c-的值语义是『双刃剑』" class="sidebar-link">3.1.C++的值语义是『双刃剑』</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-3-问题-智能指针" class="sidebar-link">3.3.问题：智能指针？</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_4-c-语言层面高度探讨" class="sidebar-link">4.C++语言层面高度探讨</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_5-c-的编程范式" class="sidebar-link">5.C++的编程范式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_6-c-11、c-14、c-17以及c-20有什么区别呢" class="sidebar-link">6.c++11、c++14、C++17以及C++20有什么区别呢?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_7-c和c-在编译时-函数名会怎么变化-那如果是匿名空间呢" class="sidebar-link">7.C和C++在编译时,函数名会怎么变化,那如果是匿名空间呢?</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_8-萃取-traits-技巧「模版的应用」" class="sidebar-link">8.萃取 traits 技巧「模版的应用」</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_9-菱形继承「虚基础」" class="sidebar-link">9.菱形继承「虚基础」</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#c-核心详解" class="sidebar-link">C++核心详解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#✅『oob』基于对象的程序设计" class="sidebar-link">✅『OOB』基于对象的程序设计</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-对比class-struct-union和enum" class="sidebar-link">1.对比class/struct/union和enum</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-1-class" class="sidebar-link">1.1.class</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-2-struct『c-中』" class="sidebar-link">1.2.struct『C++中』</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-3-union『c-中』" class="sidebar-link">1.3.union『C++中』</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-4-enum『只有它不是特殊的类』" class="sidebar-link">1.4.enum『只有它不是特殊的类』</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-类的『成员变量』和『非成员变量』⭐️" class="sidebar-link">2.类的『成员变量』和『非成员变量』⭐️</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-1-成员变量" class="sidebar-link">2.1.成员变量</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-2-非成员变量" class="sidebar-link">2.2.非成员变量</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-类的『成员函数』和『非成员函数』⭐️" class="sidebar-link">3.类的『成员函数』和『非成员函数』⭐️</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-1-成员函数" class="sidebar-link">3.1.成员函数</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-2-非成员函数" class="sidebar-link">3.2.非成员函数</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_4-big-three讲解" class="sidebar-link">4.Big Three讲解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_4-1-构造函数详解" class="sidebar-link">4.1.构造函数详解</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_4-2-析构函数详解" class="sidebar-link">4.2.析构函数详解</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_5-访问属性" class="sidebar-link">5.访问属性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_5-1-内部访问和对象访问" class="sidebar-link">5.1.内部访问和对象访问</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_6-namespace命名空间" class="sidebar-link">6.namespace命名空间</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_7-其余" class="sidebar-link">7.其余</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#✅『oop』面向对象的程序设计" class="sidebar-link">✅『OOP』面向对象的程序设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-1-类型转换函数-类型转换函数-不等于-类型转换构造函数" class="sidebar-link">1.1.类型转换函数(类型转换函数-不等于-类型转换构造函数)</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-辨析overload、override、overwrite⭐️『已解决』" class="sidebar-link">1.辨析Overload、Override、Overwrite⭐️『已解决』</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#✅区分overload、overwrite和override" class="sidebar-link">✅区分Overload、Overwrite和Override</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#同一个class里面的成员函数加-不加virtual算不算重载" class="sidebar-link">同一个class里面的成员函数加/不加virtual算不算重载？</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#那下面这样的叫什么" class="sidebar-link">那下面这样的叫什么？</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-多态与虚函数" class="sidebar-link">2.多态与虚函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-1-static变量的说明" class="sidebar-link">2.1.static变量的说明</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-2-虚函数相关" class="sidebar-link">2.2.虚函数相关</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-2-虚函数能不能inline" class="sidebar-link">2.2.虚函数能不能inline</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-『多态神器』-多态3条件" class="sidebar-link">3.『多态神器』-多态3条件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-1-条件1和条件2❎『非多态』" class="sidebar-link">3.1.条件1和条件2❎『非多态』</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-2-条件3❎『非多态』" class="sidebar-link">3.2.条件3❎『非多态』</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-3-虚析构函数" class="sidebar-link">3.3.虚析构函数</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-4-『添加作用域的调用』" class="sidebar-link">3.4.『添加作用域的调用』</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-5-静态绑定的核心理解『易错难点』⭐️" class="sidebar-link">3.5.静态绑定的核心理解『易错难点』⭐️</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#✅上面是难点" class="sidebar-link">✅上面是难点</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-6-const对象" class="sidebar-link">3.6.const对象</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#谈一谈null-0-nullptr" class="sidebar-link">谈一谈NULL，0，nullptr</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#✅杂谈" class="sidebar-link">✅杂谈</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-常量表达式" class="sidebar-link">1.常量表达式</a></li><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-c-98关键字" class="sidebar-link">2.C++98关键字</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#✅常识-非面试" class="sidebar-link">✅常识-非面试</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-区分c-和c" class="sidebar-link">1.区分C++和C</a></li></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#静态函数可以加virtual吗" class="sidebar-link">静态函数可以加virtual吗？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#new是线程安全的吗" class="sidebar-link">new是线程安全的吗？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#gdb如何调试多线程" class="sidebar-link">gdb如何调试多线程？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/3Language/Cpp/01.%E7%BB%8F%E5%85%B8C++%E9%9D%A2%E8%AF%95%E9%A2%98.html#🔋-参考资料" class="sidebar-link">🔋 参考资料</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="c-面试题"><a href="#c-面试题" class="header-anchor">#</a> C++面试题</h1> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>&lt;font style=&quot;background:yellow&quot;&gt;
&lt;font style=&quot;background:pink&quot;&gt;
&lt;font style=&quot;background: MediumSpringGreen&quot;&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li><font style="background:yellow;">当一个程序员足够老，他就从工程师变成了历史学家</font></li></ul> <h2 id="📑-目录"><a href="#📑-目录" class="header-anchor">#</a> 📑 目录</h2> <p></p><div class="table-of-contents"><ul><li><a href="#📑-目录">📑 目录</a></li><li><a href="#✅虚函数">✅虚函数</a><ul><li><a href="#_1-虚函数表-vtbl">1.虚函数表vtbl</a></li><li><a href="#_2-构造一个「派生类」对象的过程">2.构造一个「派生类」对象的过程</a></li><li><a href="#_2-1-是先构造父类的「虚表指针」还是先构造父类的「成员」">2.1.是先构造父类的「虚表指针」还是先构造父类的「成员」？</a></li><li><a href="#_2-2-「虚表指针」和「构造函数体」那个先被构造">2.2.「虚表指针」和「构造函数体」那个先被构造？</a></li><li><a href="#_3-c-「运行构造函数」的时候「虚函数表」被构造出来了么">3.c++「运行构造函数」的时候「虚函数表」被构造出来了么？</a></li><li><a href="#_4-析构一个「派生类」object的过程">4.析构一个「派生类」object的过程</a></li></ul></li><li><a href="#✅基础">✅基础</a><ul><li><a href="#_1-vector是线程安全的吗">1.vector是线程安全的吗？</a></li><li><a href="#_2-c-是不是类型安全的呢">2.C++是不是类型安全的呢？</a></li><li><a href="#_3-sizeof-只有1个虚析构函数的空类呢">3.sizeof只有1个虚析构函数的空类呢？</a></li><li><a href="#_4-构造函数为什么不能是虚函数">4.构造函数为什么不能是虚函数？</a></li><li><a href="#_5-为何空类的大小不是零">5.为何空类的大小不是零？</a></li><li><a href="#_6-我能从构造函数调用虚函数吗">6.我能从构造函数调用虚函数吗？</a></li><li><a href="#_7-内存泄露及解决办法">7.内存泄露及解决办法：</a></li><li><a href="#_8-怎么检测内存泄漏">8.怎么检测内存泄漏？</a></li><li><a href="#_9-初始化顺序">9.初始化顺序</a></li></ul></li><li><a href="#✅平常做题错题">✅平常做题错题</a><ul><li><a href="#_1-测试">1.测试</a></li><li><a href="#_2-在-c-语言中-对函数参数默认值描述正确的是">2.在 c++ 语言中，对函数参数默认值描述正确的是？</a></li></ul></li><li><a href="#✅c-输入输出io">✅C++输入输出IO</a></li><li><a href="#_1-iostream-的设计初衷">1.iostream的设计初衷</a></li><li><a href="#_2-iostream-的特点">2.iostream的特点</a></li><li><a href="#_1-c-惯用法">1.C++惯用法</a><ul><li><a href="#_1-1-raii-资源获取即初始化">1.1.RAII(资源获取即初始化)</a></li><li><a href="#_1-2-pimpl">1.2.pImpl</a></li><li><a href="#_1-3-copy-and-swap">1.3.copy and swap</a></li></ul></li><li><a href="#_2-value-semantics-和-object-semantics">2.value semantics和object semantics</a><ul><li><a href="#_2-1-值语义-value-semantics">2.1.值语义（value semantics）</a></li><li><a href="#_2-2-对象语义-object-semantics">2.2.对象语义（object semantics）</a></li><li><a href="#_2-3-优点缺点对比">2.3.优点缺点对比</a></li></ul></li><li><a href="#_3-c-惯用法和-value-semantics-组合拳">3.C++惯用法和value semantics组合拳</a><ul><li><a href="#_3-1-c-的值语义是『双刃剑』">3.1.C++的值语义是『双刃剑』</a></li><li><a href="#_3-3-问题-智能指针">3.3.问题：智能指针？</a></li></ul></li><li><a href="#_4-c-语言层面高度探讨">4.C++语言层面高度探讨</a></li><li><a href="#_5-c-的编程范式">5.C++的编程范式</a></li><li><a href="#_6-c-11、c-14、c-17以及c-20有什么区别呢">6.c++11、c++14、C++17以及C++20有什么区别呢?</a></li><li><a href="#_7-c和c-在编译时-函数名会怎么变化-那如果是匿名空间呢">7.C和C++在编译时,函数名会怎么变化,那如果是匿名空间呢?</a></li><li><a href="#_8-萃取-traits-技巧「模版的应用」">8.萃取 traits 技巧「模版的应用」</a></li><li><a href="#_9-菱形继承「虚基础」">9.菱形继承「虚基础」</a></li><li><a href="#c-核心详解">C++核心详解</a></li><li><a href="#✅『oob』基于对象的程序设计">✅『OOB』基于对象的程序设计</a></li><li><a href="#_1-对比-class-struct-union-和-enum">1.对比class/struct/union和enum</a><ul><li><a href="#_1-1-class">1.1.class</a></li><li><a href="#_1-2-struct-『c-中』">1.2.struct『C++中』</a></li><li><a href="#_1-3-union-『c-中』">1.3.union『C++中』</a></li><li><a href="#_1-4-enum-『只有它不是特殊的类』">1.4.enum『只有它不是特殊的类』</a></li></ul></li><li><a href="#_2-类的『成员变量』和『非成员变量』⭐️">2.类的『成员变量』和『非成员变量』⭐️</a><ul><li><a href="#_2-1-成员变量">2.1.成员变量</a></li><li><a href="#_2-2-非成员变量">2.2.非成员变量</a></li></ul></li><li><a href="#_3-类的『成员函数』和『非成员函数』⭐️">3.类的『成员函数』和『非成员函数』⭐️</a><ul><li><a href="#_3-1-成员函数">3.1.成员函数</a></li><li><a href="#_3-2-非成员函数">3.2.非成员函数</a></li></ul></li><li><a href="#_4-big-three-讲解">4.Big Three讲解</a><ul><li><a href="#_4-1-构造函数详解">4.1.构造函数详解</a></li><li><a href="#_4-2-析构函数详解">4.2.析构函数详解</a></li></ul></li><li><a href="#_5-访问属性">5.访问属性</a><ul><li><a href="#_5-1-内部访问和对象访问">5.1.内部访问和对象访问</a></li></ul></li><li><a href="#_6-namespace-命名空间">6.namespace命名空间</a></li><li><a href="#_7-其余">7.其余</a></li><li><a href="#✅『oop』面向对象的程序设计">✅『OOP』面向对象的程序设计</a><ul><li><a href="#_1-1-类型转换函数-类型转换函数-不等于-类型转换构造函数">1.1.类型转换函数(类型转换函数-不等于-类型转换构造函数)</a></li></ul></li><li><a href="#_1-辨析overload、override、overwrite⭐️『已解决』">1.辨析Overload、Override、Overwrite⭐️『已解决』</a><ul><li><a href="#✅区分overload、overwrite和override">✅区分Overload、Overwrite和Override</a></li><li><a href="#同一个class里面的成员函数加-不加virtual算不算重载">同一个class里面的成员函数加/不加virtual算不算重载？</a></li><li><a href="#那下面这样的叫什么">那下面这样的叫什么？</a></li></ul></li><li><a href="#_2-多态与虚函数">2.多态与虚函数</a><ul><li><a href="#_2-1-static-变量的说明">2.1.static变量的说明</a></li><li><a href="#_2-2-虚函数相关">2.2.虚函数相关</a></li><li><a href="#_2-2-虚函数能不能inline">2.2.虚函数能不能inline</a></li></ul></li><li><a href="#_3-『多态神器』-多态3条件">3.『多态神器』-多态3条件</a><ul><li><a href="#_3-1-条件1和条件2❎『非多态』">3.1.条件1和条件2❎『非多态』</a></li><li><a href="#_3-2-条件3❎『非多态』">3.2.条件3❎『非多态』</a></li><li><a href="#_3-3-虚析构函数">3.3.虚析构函数</a></li><li><a href="#_3-4-『添加作用域的调用』">3.4.『添加作用域的调用』</a></li><li><a href="#_3-5-静态绑定的核心理解『易错难点』⭐️">3.5.静态绑定的核心理解『易错难点』⭐️</a></li><li><a href="#✅上面是难点">✅上面是难点</a></li><li><a href="#_3-6-const对象">3.6.const对象</a></li></ul></li><li><a href="#谈一谈null-0-nullptr">谈一谈NULL，0，nullptr</a></li><li><a href="#✅杂谈">✅杂谈</a><ul><li><a href="#_1-常量表达式">1.常量表达式</a></li><li><a href="#_2-c-98关键字">2.C++98关键字</a></li></ul></li><li><a href="#✅常识-非面试">✅常识-非面试</a><ul><li><a href="#_1-区分c-和c">1.区分C++和C</a></li></ul></li><li><a href="#静态函数可以加virtual吗">静态函数可以加virtual吗？</a></li><li><a href="#new是线程安全的吗">new是线程安全的吗？</a></li><li><a href="#gdb如何调试多线程">gdb如何调试多线程？</a></li><li><a href="#🔋-参考资料">🔋 参考资料</a></li></ul></div><p></p> <p>[TOC]</p> <h2 id="✅虚函数"><a href="#✅虚函数" class="header-anchor">#</a> ✅虚函数</h2> <p>本部分，特别是下面5个概念的顺序，不仅仅影响基础概念，而且还会影响，我们对线程安全的理解！！</p> <ul><li>虚函数表</li> <li>虚函数指针</li> <li>成员变量</li> <li>构造函数</li> <li>虚构函数</li></ul> <h3 id="_1-虚函数表vtbl"><a href="#_1-虚函数表vtbl" class="header-anchor">#</a> 1.虚函数表<code>vtbl</code></h3> <ol><li><p><font style="background:yellow;">编译器在<strong>编译时期</strong>为每个带虚函数的「类」创建一份<strong>虚函数表</strong></font></p></li> <li><p><strong>实例化</strong>对象时, 编译器自动将<strong>类对象（object）<strong>的</strong>虚表指针</strong>指向这个虚函数表</p></li></ol> <ul><li>参考自：《收割BAT：<a href="https://www.nowcoder.com/tutorial/10018/index" target="_blank" rel="noopener noreferrer">C++校招学习路线总结<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>》，特立独行MVP</li></ul> <p>意思：</p> <p>虚函数表，是属于class的。</p> <p>每个object有属于各自的虚表指针。</p> <h3 id="_2-构造一个「派生类」对象的过程"><a href="#_2-构造一个「派生类」对象的过程" class="header-anchor">#</a> 2.构造一个「派生类」对象的过程</h3> <ul><li>1.构造<strong>基类</strong>部分：
<ul><li>1.将object实例的<strong>虚表指针</strong>指向<strong>基类的vtbl</strong></li> <li>2.构造基类的**「成员变量」**</li> <li>3.<font style="background:yellow;">执行基类的「<strong>构造函数函数体」</strong></font></li></ul></li> <li>2.<strong>递归</strong>构造派生类部分：
<ul><li>1.将实例的虚表指针指向<strong>派生类vtbl</strong></li> <li>2.构造派生类的成员变量</li> <li>3.执行派生类的构造函数体</li></ul></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> ss<span class="token punctuation">)</span> <span class="token punctuation">{</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B constructor\n&quot;</span><span class="token punctuation">;</span> 
                       <span class="token function">f</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span> 
                       <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B::f\n&quot;</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;a=&quot;</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
  <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">D</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span> ss<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;D constructor\n&quot;</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> ss<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;D::f\n&quot;</span><span class="token punctuation">;</span> s <span class="token operator">=</span> ss<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">private</span><span class="token operator">:</span>
  string s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  D <span class="token function">d</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//output</span>
h@dell<span class="token operator">:</span><span class="token operator">~</span>$ <span class="token punctuation">.</span><span class="token operator">/</span>a<span class="token punctuation">.</span>out
B constructor
B<span class="token double-colon punctuation">::</span>f
a<span class="token operator">=</span><span class="token number">496370680</span>
D constructor
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><h3 id="_2-1-是先构造父类的「虚表指针」还是先构造父类的「成员」"><a href="#_2-1-是先构造父类的「虚表指针」还是先构造父类的「成员」" class="header-anchor">#</a> 2.1.是先构造父类的「虚表指针」还是先构造父类的「成员」？</h3> <ul><li>虚表指针</li></ul> <h3 id="_2-2-「虚表指针」和「构造函数体」那个先被构造"><a href="#_2-2-「虚表指针」和「构造函数体」那个先被构造" class="header-anchor">#</a> 2.2.「虚表指针」和「构造函数体」那个先被构造？</h3> <ul><li>虚表指针先构造</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
	<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

	<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> ss<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B constructor\n&quot;</span><span class="token punctuation">;</span> <span class="token function">f</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
		<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B::f\n&quot;</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span></span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">D</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span> ss<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;D constructor\n&quot;</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
		<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> ss<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;D::f\n&quot;</span><span class="token punctuation">;</span> s <span class="token operator">=</span> ss<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		string s<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		D <span class="token function">d</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token comment">//输出</span>
B constructor
B<span class="token double-colon punctuation">::</span>f
D constructor
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h3 id="_3-c-「运行构造函数」的时候「虚函数表」被构造出来了么"><a href="#_3-c-「运行构造函数」的时候「虚函数表」被构造出来了么" class="header-anchor">#</a> 3.c++「运行构造函数」的时候「虚函数表」被构造出来了么？</h3> <p>​	构造出来了。</p> <p>​	因为「虚函数表」是在<strong>编译时</strong>由编译器创建，在<strong>运行</strong>时肯定已经创建完成。</p> <h3 id="_4-析构一个「派生类」object的过程"><a href="#_4-析构一个「派生类」object的过程" class="header-anchor">#</a> 4.析构一个「派生类」object的过程</h3> <ul><li><p>1.<strong>递归</strong>析构派生类部分：</p> <ul><li>1.将实例的<strong>虚表指针</strong>指向<strong>派生类vtbl</strong></li> <li>2.执行派生类的<strong>析构函数体</strong></li> <li>3.析构派生类的<strong>成员变量</strong></li></ul></li> <li><p>2.析构基类部分：</p> <ul><li>1.将实例的<strong>虚表指针</strong>指向基类的vtbl</li> <li>2.执行基类的析构函数函数体</li> <li>3.析构基类的成员变量</li></ul></li></ul> <h2 id="✅基础"><a href="#✅基础" class="header-anchor">#</a> ✅基础</h2> <h3 id="_1-vector是线程安全的吗"><a href="#_1-vector是线程安全的吗" class="header-anchor">#</a> 1.vector是线程安全的吗？</h3> <ul><li>不是线程安全的！</li></ul> <p>比如，一个线程是生产者，不断push_back，然后多个线程并发读</p> <p>​	由于push_back潜在的内存重新申请和对象复制问题，会导致读方（消费者）的迭代器失效。不一定会产生正确的行为。</p> <p>解决方式，进行额外的同步。</p> <ul><li>参考：《Linux多线程服务器端编程》P4</li> <li>巨人网络</li></ul> <p>STL里面还有哪些class不是线程安全的呢？</p> <p>string、map、vector</p> <p>map不是线程安全的原因：</p> <p>比如这样的场景</p> <p><strong>当有多个写线程对情况下</strong>，并发地插入 map/unordered_map都会引发core dump。</p> <h3 id="_2-c-是不是类型安全的呢"><a href="#_2-c-是不是类型安全的呢" class="header-anchor">#</a> 2.C++是不是类型安全的呢？</h3> <p>1、C++<strong>不是</strong>类型安全的</p> <p>2、因为在C++中允许不同类型指针之间进行<strong>强制转换</strong>（<code>C#</code>是类型安全的）</p> <h3 id="_3-sizeof只有1个虚析构函数的空类呢"><a href="#_3-sizeof只有1个虚析构函数的空类呢" class="header-anchor">#</a> 3.<code>sizeof</code>只有1个虚析构函数的空类呢？</h3> <p>1、64位的机器的话，那么就是8Byte，虚函数指针</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">sss</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">sss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">sss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>

    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span> sss <span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h3 id="_4-构造函数为什么不能是虚函数"><a href="#_4-构造函数为什么不能是虚函数" class="header-anchor">#</a> 4.构造函数为什么不能是虚函数？</h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">sss</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token function">sss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token operator">~</span><span class="token function">sss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    sss a<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span> sss <span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><ul><li>64位机器，64位<code>g++</code> <ul><li>运行报错：<code>error: constructors cannot be declared virtual [-fpermissive]</code></li></ul></li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>constructors cannot be declared virtual [-fpermissive]
构造函数不能声明为virtual [-fpermissive]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>参考：『Bjarne Stroustrup's C++ Style and Technique FAQ』</li> <li>参考：<a href="https://www.stroustrup.com/index.html" target="_blank" rel="noopener noreferrer">https://www.stroustrup.com/index.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Why don<span class="token number">'</span>t we have <span class="token keyword">virtual</span> constructors<span class="token operator">?</span>
A <span class="token keyword">virtual</span> call is a mechanism to get work done given partial information<span class="token punctuation">.</span> In particular<span class="token punctuation">,</span> <span class="token string">&quot;virtual&quot;</span> allows us to call a function knowing only an interfaces <span class="token operator">and</span> <span class="token operator">not</span> the exact type of the object<span class="token punctuation">.</span> To create an object you need complete information<span class="token punctuation">.</span> In particular<span class="token punctuation">,</span> you need to know the exact type of what you want to create<span class="token punctuation">.</span> Consequently<span class="token punctuation">,</span> a <span class="token string">&quot;call to a constructor&quot;</span> cannot be <span class="token keyword">virtual</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>为什么我们没有虚拟构造函数？
1、虚拟调用是在<strong>给定部分信息</strong>的情况下完成工作的机制。特别是，“虚拟”允许我们调用一个只知道接口而不知道对象确切类型的函数。
2、要<strong>创建对象</strong>，您需要<strong>完整的信息</strong>。特别是，您需要知道您想要创建的内容的确切类型。因此，“对构造函数的调用”不能是虚拟的。</p> <h3 id="_5-为何空类的大小不是零"><a href="#_5-为何空类的大小不是零" class="header-anchor">#</a> 5.为何空类的大小不是零？</h3> <ul><li>为了<strong>确保两个不同对象的地址不同</strong>，必须如此。也正因为如此，new返回的指针总是指向不同的单个对象。我们还是来看代码吧：</li> <li>参考文献<a href="https://www.stroustrup.com/bstechfaq.htm" target="_blank" rel="noopener noreferrer">传送门<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Empty</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Empty a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;impossible: report error to compiler supplier\n&quot;</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;不可能:向编译器供应商报告错误\n&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    Empty<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> Empty<span class="token punctuation">;</span>
    Empty<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> Empty<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;impossible: report error to compiler supplier\n&quot;</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;不可能:向编译器供应商报告错误\n&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>    
<span class="token comment">//我在64位机器，64位g++上，运行了，发现什么都没输出</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><ul><li>另外，C++中有一条有趣的规则——空基类并不需要另外一个字节来表示：</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Empty</span></span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> a<span class="token punctuation">;</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>X<span class="token operator">*</span> p<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">void</span><span class="token operator">*</span> p1 <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token keyword">void</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>a<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;nice: good optimizer&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
            cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;nice：很好的优化器&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token comment">//我在64位机器，64位g++上，运行了，输出了上面的</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li>如果上述代码中p1和p2相等，那么<strong>说明编译器作了优化</strong>。</li> <li>这样的优化是安全的，而且非常有用。它允许程序员用空类来表示非常简单的概念，而不需为此付出额外的（空间）代价。一些现代编译器提供了这种“虚基类优化”功能。</li></ul> <h3 id="_6-我能从构造函数调用虚函数吗"><a href="#_6-我能从构造函数调用虚函数吗" class="header-anchor">#</a> 6.我能从构造函数调用虚函数吗？</h3> <ul><li><p><strong>可以。不过你得悠着点</strong>。</p></li> <li><p>当你这样做时，也许你自己都不知道自己在干什么！在构造函数中，虚拟机制尚未发生作用，因为此时overriding尚未发生。万丈高楼平地起，总得先打地基吧？对象的建立也是这样——先把基类构造完毕，然后在此基础上构造派生类。</p></li> <li><p>参考自<a href="https://www.stroustrup.com/bstechfaq.htm" target="_blank" rel="noopener noreferrer">文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul> <h3 id="_7-内存泄露及解决办法"><a href="#_7-内存泄露及解决办法" class="header-anchor">#</a> 7.内存泄露及解决办法：</h3> <p>什么是内存泄露？   简单地说就是申请了一块内存空间，<strong>使用完毕后没有释放掉</strong></p> <p>1、new和malloc申请资源使用 后，没有用delete和free释放；</p> <p>2、子类继承父类时，父类析构函数不是虚函数。</p> <h3 id="_8-怎么检测内存泄漏"><a href="#_8-怎么检测内存泄漏" class="header-anchor">#</a> 8.怎么检测内存泄漏？</h3> <ul><li>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉</li> <li>第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改这个链表</li> <li>第三：使用智能指针</li> <li>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、<font style="background:yellow;">Valgrind</font>等等</li></ul> <h3 id="_9-初始化顺序"><a href="#_9-初始化顺序" class="header-anchor">#</a> 9.初始化顺序</h3> <p>​	在C++中，初始化顺序是按照<strong>定义</strong>的顺序来进行的。比如，如果一个类有三个成员变量，那么它们将<strong>按照定义的顺序</strong>进行初始化。构造函数只是用来<strong>指定初始化值</strong>的，而<strong>不是</strong>指定初始化<strong>顺序</strong>的。</p> <h2 id="✅平常做题错题"><a href="#✅平常做题错题" class="header-anchor">#</a> ✅平常做题错题</h2> <h3 id="_1-测试"><a href="#_1-测试" class="header-anchor">#</a> 1.测试</h3> <ul><li>题目参考<a href="https://www.nowcoder.com/test/question/done?tid=44295104&amp;qid=112041" target="_blank" rel="noopener noreferrer">传送门<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span> 
    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">;</span>
    p<span class="token operator">=</span>s<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%c%c%c\n&quot;</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token operator">++</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token operator">++</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//以下程序的输出结果是（）。</span>
<span class="token comment">//321</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>牛油的回答</p> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>2. 运算对象求值顺序不明：
C++中只有'&amp;&amp;', '||', ',', '?:' 这四个运算符明确了其所属运算对象的求值顺序。

函数调用也是一种运算符
而实参压栈顺序完全依赖于编译器实现，三个*p++求值顺序不明。
那么结合第一个问题，假如从左向右压栈结果就是123
如果换个编译器可能顺序又不同了
所有选项可能都能有幸成为正确答案

所以，这种表达式是错误的，会产生未定义的行为。
这种题目真的不该再出。


大家看的所谓语言书籍的作者当年基本都是i386的使用者
这就是大家看到“压栈顺序从右至左”这一说法的原因
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ul><li>我的测试环境64位机器的<code>g++</code>下</li> <li>实参压栈顺序是『从右到左』</li></ul> <h3 id="_2-在-c-语言中-对函数参数默认值描述正确的是"><a href="#_2-在-c-语言中-对函数参数默认值描述正确的是" class="header-anchor">#</a> 2.在 c++ 语言中，对函数参数默认值描述正确的是？</h3> <ul><li>题目<a href="https://www.nowcoder.com/test/question/done?tid=44202421&amp;qid=143523#summary" target="_blank" rel="noopener noreferrer">来源<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>A 函数参数的默认值只能设定一个
B 一个函数的参数若有多个，则参数默认值的设定可以不连续
C 函数参数必须设定默认值
D 在设定了参数的默认值后，该参数后面定义的所有参数都必须设定默认值
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>我选择的是D</li> <li>2020-10.2
<ul><li>我当时的解释：C++语言中，允许在函数的说明或定义时给一个或多个参数指定默认值。<strong>参数默认值必须从右向左定义</strong>（入栈的顺序，汇编），即在一个指定了默认值的参数的右边，不能出现没有指定默认值的参数。</li></ul></li> <li>2021.7月
<ul><li>我对上面的解释：关于汇编的那个事情，我突然记得那时候我学的是X86的汇编</li></ul></li></ul> <h2 id="✅c-输入输出io"><a href="#✅c-输入输出io" class="header-anchor">#</a> ✅C++输入输出IO</h2> <h2 id="_1-iostream的设计初衷"><a href="#_1-iostream的设计初衷" class="header-anchor">#</a> 1.<code>iostream</code>的设计初衷</h2> <ul><li>对初学者友好</li> <li>提供一个高效的可扩展的类型安全的IO机制</li></ul> <blockquote><p><code>iostream</code>的现状</p></blockquote> <ul><li>在真实的项目中很少用到<code>iostream</code> <ul><li>参考自“陈硕”</li></ul></li></ul> <h2 id="_2-iostream的特点"><a href="#_2-iostream的特点" class="header-anchor">#</a> 2.<code>iostream</code>的特点</h2> <ul><li>不同于标准库其他class的“值语义(value semantics)”，<code>iostream</code>是“对象语义(object semantics)”
<ul><li>即iostream是<code>non-copyable</code></li> <li>iostream禁止拷贝，利用对象的生命期来明确管理资源（如文件）</li></ul></li> <li><code>iostream</code>在<strong>线程安全</strong>方面没有保证！</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>术语
    内存泄漏
c++编程风格惯用法
    1.类初始化列表
    2.枚举类替换命名空间
    3.RAII(资源获取即初始化)
    4.copy and swap
    5.pImpl(指针指向具体实现)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_1-c-惯用法"><a href="#_1-c-惯用法" class="header-anchor">#</a> 1.C++惯用法</h2> <h3 id="_1-1-raii-资源获取即初始化"><a href="#_1-1-raii-资源获取即初始化" class="header-anchor">#</a> 1.1.RAII(资源获取即初始化)</h3> <blockquote><p>RAII（资源获取即初始化）『<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization』</p></blockquote> <ul><li><a href="https://zh.wikipedia.org/wiki/RAII" target="_blank" rel="noopener noreferrer">维基百科<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：RAII</li> <li>为解决资源管理时的<font style="background:yellow;">异常安全性</font></li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>它是在一些面向对象语言中的一种惯用法。

RAII源于C++
在Java，C#，D，Ada，Vala和Rust中也有应用
1984-1989年期间，比雅尼·斯特劳斯特鲁普和安德鲁·柯尼希在设计C++异常时，为解决资源管理时的异常安全性而使用了该用法[1]，后来比雅尼·斯特劳斯特鲁普将其称为RAII[2]。

RAII要求，资源的有效期与持有资源的对象的生命期严格绑定，即由对象的构造函数完成资源的分配（获取），同时由析构函数完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现资源泄露问题。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_1-2-pimpl"><a href="#_1-2-pimpl" class="header-anchor">#</a> 1.2.pImpl</h3> <blockquote><p>pImpl（指向实现的指针）『<strong>P</strong>ointer to <strong>Impl</strong>ementation』，Implementation，实现，实施</p></blockquote> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>是一种 C++ 编程技巧
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>它将类的<strong>实现细节</strong>从对象表示中移除，放到一个『<strong>分离的类</strong>』中，并以一个『<strong>不透明的指针</strong>』进行访问。</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>优点：
    1、减少依赖项（降低耦合性）：其一减少原类不必要的头文件的依赖，加速编译；其二对Impl类进行修改，无需重新编译原类。
    2、接口和实现的分离（隐藏了类的实现）：私有成员完全可以隐藏在共有接口之外，给用户一个间接明了的使用接口，尤其适合闭源API设计。
    3、可使用惰性分配技术：类的某部分实现可以写成按需分配或者实际使用时再分配，从而节省资源。

缺点：
    1、每个类需要占用小小额外的指针内存。

    2、每个类每次访问具体实现时都要多一个间接指针操作的开销，并且在使用、阅读和调试上都可能有所不便
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>参考自：<a href="https://www.cnblogs.com/KillerAery/p/9539705.html" target="_blank" rel="noopener noreferrer">博客园<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="_1-3-copy-and-swap"><a href="#_1-3-copy-and-swap" class="header-anchor">#</a> 1.3.copy and swap</h3> <h2 id="_2-value-semantics和object-semantics"><a href="#_2-value-semantics和object-semantics" class="header-anchor">#</a> 2.<code>value semantics</code>和<code>object semantics</code></h2> <ul><li>参考自：《Linux多线程服务器编程》，使用muduoC++网络库</li></ul> <p><font style="background:yellow;">仔细理解：书上P482-484</font></p> <h3 id="_2-1-值语义-value-semantics"><a href="#_2-1-值语义-value-semantics" class="header-anchor">#</a> 2.1.值语义（value semantics）</h3> <ul><li>所谓值语义是指目标对象由源对象拷贝生成，且生成后与源对象完全无关，彼此独立存在，改变互不影响。就像 int 类型变量相互拷贝一样。</li> <li>value semantics：指的是对象的拷贝与原对象无关</li></ul> <blockquote><p>举例：</p></blockquote> <ul><li><font style="background:yellow;">C++</font>的内置类型（<code>bool/int/double/char</code>）都是值语义，标准库里的 <code>complex&lt;&gt;</code>、<code>pair&lt;&gt;</code>、<code>vector&lt;&gt;</code>、<code>map&lt;&gt;</code>、<code>string</code> 等等类型也都是值语义。</li> <li><font style="background:yellow;">Java</font>语言中的<code>primitive types（基础类型）比如：int 、short、long</code>也是值语义</li></ul> <p><strong>拷贝之后就与源对象完全脱离关系</strong></p> <h3 id="_2-2-对象语义-object-semantics"><a href="#_2-2-对象语义-object-semantics" class="header-anchor">#</a> 2.2.对象语义（object semantics）</h3> <ul><li><font style="background:yellow;">别名：</font>对象语义也叫<strong>指针语义</strong>，**引用语义（reference semantics）**等</li> <li>通常是指一个目标对象由源对象拷贝生成，但生成后与源对象之间依然共享底层资源，对任何一个的改变都将随之改变另一个。就像包含有指针成员变量的自定义类在默认拷贝构造函数下对其对象之间进行的拷贝。拷贝后目标对象和源对象的指针成员变量仍指向同一块内存数据。如果当其中一个被析构掉后，另一个对象的指针成员就会沦为名副其实的悬垂指针！</li></ul> <p>核心理解：”对象语义“这个词中“对象”指的是<font style="background:yellow;">『<strong>面向对象</strong>』</font>意义下的对象，并不是我们<font style="background:yellow;">『<strong>语法意义上class生成的</strong>』</font>对象，我们的结论是：『面向对象意义下的对象，对象拷贝是禁止的』</p> <ul><li>例子：</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>薪资管理系统中，一个对象叫：员工张三
我们拷贝“员工张三”这个对象是没有意义的！！
因为员工张三这个对象代表的是一个活生生的人，我们拷贝它是被禁止的。

服务器开发中，也有类似的情况
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>结论：<font style="background:yellow;">『面向对象』意义下的&quot;对象&quot;是<code>non-copyable</code>（不能够拷贝的）</font></li></ul> <blockquote><p>举例：</p></blockquote> <ul><li><p><font style="background:yellow;">Java</font>语言中class对象<font style="background:yellow;">都是</font>“对象语义”</p> <ul><li><font style="background:yellow;">Java</font>语言没有办法实现『真正的』“值语义”class，只好用<code>immutable object</code>来模拟</li> <li><font style="background:yellow;">Java</font>语言中有<code>value object</code>一说，按照定义，它实际上是<code>immutable object（不可改变的对象）</code>，比如<code>Interger，String，BigInterger</code></li></ul></li> <li><p><font style="background:yellow;">C++</font>语言中class本质上是<font style="background:yellow;">值语义</font>，值语义对象，比如<code>pair&lt;&gt;，vector&lt;&gt;，string&lt;&gt;</code>等，都是可修改的（mutable）</p></li></ul> <h3 id="_2-3-优点缺点对比"><a href="#_2-3-优点缺点对比" class="header-anchor">#</a> 2.3.优点缺点对比</h3> <p>值语义（value semantics）</p> <ul><li>优点：生命期管理很简单，比如 C++中<code>int</code>类型一样—你不需要操心 int 对象 的生命期。
<ul><li>因为：值语义的对象要么是<code>stack object</code>，要么是<code>作为其他object的成员</code></li></ul></li></ul> <p>对象语义（object semantics）</p> <ul><li><p>缺点：对象语义的object由于不能拷贝，因此我们只能在<font style="background:yellow;">C++的实现</font>是通过’指针“或”引用“来使用它</p></li> <li><p><code>immutable</code>不可修改的</p></li> <li><p><code>mutable</code>可修改的</p></li></ul> <h2 id="_3-c-惯用法和value-semantics组合拳"><a href="#_3-c-惯用法和value-semantics组合拳" class="header-anchor">#</a> 3.C++惯用法和<code>value semantics</code>组合拳</h2> <ul><li>值语义，对象语义</li> <li>RAII</li> <li>智能指针</li></ul> <h3 id="_3-1-c-的值语义是『双刃剑』"><a href="#_3-1-c-的值语义是『双刃剑』" class="header-anchor">#</a> 3.1.C++的值语义是『双刃剑』</h3> <ul><li>由于C++中class本质上是<font style="background:yellow;">值语义</font>，这
<ul><li>才会出现<code>object slicing</code>这种语言独有的问题！！</li> <li>才会需要程序员注意：<code>pass-by-value</code>和<code>pass-by-const-reference</code>的取舍</li></ul></li> <li>在其他『面向对象语言』，比如Java中，这都不需要费脑筋。。</li></ul> <p>书上P488</p> <ul><li>值语义是<strong>C++语言3大约束之一</strong>，C++的设计初衷是让用户定义的类型（class）能像内置类型（int）一样工作，具有<strong>同等</strong>的地位。</li></ul> <h3 id="_3-3-问题-智能指针"><a href="#_3-3-问题-智能指针" class="header-anchor">#</a> 3.3.问题：智能指针？</h3> <ul><li><font style="background:yellow;">智能指针既不是『值语义』也不是『对象语义』</font></li> <li>由于『值语义和对象语义的原因』
<ul><li><font style="background:yellow;">如果不使用智能指针，用C++做面向对象编程将会困难重重</font></li></ul></li></ul> <h2 id="_4-c-语言层面高度探讨"><a href="#_4-c-语言层面高度探讨" class="header-anchor">#</a> 4.C++语言层面高度探讨</h2> <p>C++复杂的根源在于三大约束：</p> <ul><li>与C的完全兼容</li> <li>静态类型检查</li> <li>最高性能</li></ul> <p><strong>在三大约束下，C++未能完善对于面向对象思想的支持，未能建立强大的动态能力，从而使得C++在OO这个单项上存在本质缺陷</strong>。</p> <ul><li>事实上，C++的过程、OB模型相当成熟和稳定</li> <li>而泛型模型，就单项来说，除了语法丑陋之外也没有大的问题。</li> <li>缺陷集中体现在OO模型的实现，并因此干扰了其他几个范式的完整程度。
<ul><li>然而，OO的缺陷绝非设计者的偏执，其原因在于三大约束。如果坚持三大约束，则即使再重新设计一次，结果也与今日相差不远。Stroustrup在多种场合表示，对C++的设计没有大的后悔之处，意思就是这个。</li> <li>侯捷先生早在2001年初即对我说，C++在OO上不及Java，当时体会不深，认为没有大一统的单根类库会使设计更加灵活，后来又认为凭借GP可以抵消OO的不足甚至超越之，现在看来即使不是不可能，这条道路也必然是艰辛异常，成败难以预料。</li></ul></li></ul> <blockquote><p>参考自：<a href="https://blog.csdn.net/myan/article/details/148900" target="_blank" rel="noopener noreferrer">CSDN的myan（孟岩）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="_5-c-的编程范式"><a href="#_5-c-的编程范式" class="header-anchor">#</a> 5.C++的编程范式</h2> <p>5.1.过程式编程</p> <p>5.2.基于对象编程</p> <p>5.3.面向对象编程</p> <p>5.4.泛型编程</p> <p>5.5.函数式编程</p> <h2 id="_6-c-11、c-14、c-17以及c-20有什么区别呢"><a href="#_6-c-11、c-14、c-17以及c-20有什么区别呢" class="header-anchor">#</a> 6.c++11、c++14、C++17以及C++20有什么区别呢?</h2> <ul><li>字节跳动，一面</li> <li>参考：https://github.com/AnthonyCalandra/modern-cpp-features</li></ul> <blockquote><p>C++11</p></blockquote> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>C++11 includes the following new language features:

move semantics
variadic templates
rvalue references
forwarding references
initializer lists
static assertions
auto
lambda expressions
decltype
<span class="token builtin class-name">type</span> aliases
nullptr
strongly-typed enums
attributes
constexpr
delegating constructors
user-defined literals
explicit virtual overrides
final specifier
default functions
deleted functions
range-based <span class="token keyword">for</span> loops
special member functions <span class="token keyword">for</span> move semantics
converting constructors
explicit conversion functions
inline-namespaces
non-static data member initializers
right angle brackets
ref-qualified member functions
trailing <span class="token builtin class-name">return</span> types
noexcept specifier
char32_t and char16_t
raw string literals


C++11 includes the following new library features:

std::move
std::forward
std::thread
std::to_string
<span class="token builtin class-name">type</span> traits
smart pointers
std::chrono
tuples
std::tie
std::array
unordered containers
std::make_shared
std::ref
memory model
std::async
std::begin/end
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><blockquote><p>C++14</p></blockquote> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>C++14 includes the following new language features:

binary literals
generic lambda expressions
lambda capture initializers
<span class="token builtin class-name">return</span> <span class="token builtin class-name">type</span> deduction
decltype<span class="token punctuation">(</span>auto<span class="token punctuation">)</span>
relaxing constraints on constexpr functions
variable templates
<span class="token punctuation">[</span><span class="token punctuation">[</span>deprecated<span class="token punctuation">]</span><span class="token punctuation">]</span> attribute
C++14 includes the following new library features:

user-defined literals <span class="token keyword">for</span> standard library types
compile-time integer sequences
std::make_unique
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><blockquote><p>C++17</p></blockquote> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>C++17 includes the following new language features:

template argument deduction <span class="token keyword">for</span> class templates
declaring non-type template parameters with auto
folding expressions
new rules <span class="token keyword">for</span> auto deduction from braced-init-list
constexpr lambda
lambda capture this by value
inline variables
nested namespaces
structured bindings
selection statements with initializer
constexpr <span class="token keyword">if</span>
utf-8 character literals
direct-list-initialization of enums
fallthrough, nodiscard, maybe_unused attributes
C++17 includes the following new library features:

std::variant
std::optional
std::any
std::string_view
std::invoke
std::apply
std::filesystem
std::byte
splicing <span class="token keyword">for</span> maps and sets
parallel algorithms
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><blockquote><p>C++20</p></blockquote> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>C++20 includes the following new language features:

coroutines
concepts
designated initializers
template syntax <span class="token keyword">for</span> lambdas
range-based <span class="token keyword">for</span> loop with initializer
likely and unlikely attributes
deprecate implicit capture of this
class types <span class="token keyword">in</span> non-type template parameters
constexpr virtual functions
explicit<span class="token punctuation">(</span>bool<span class="token punctuation">)</span>
immediate functions
using enum
lambda capture of parameter pack
char8_t
C++20 includes the following new library features:

concepts library
synchronized buffered outputstream
std::span
bit operations
math constants
std::is_constant_evaluated
std::make_shared supports arrays
starts_with and ends_with on strings
check <span class="token keyword">if</span> associative container has element
std::bit_cast
std::midpoint
std::to_array
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h2 id="_7-c和c-在编译时-函数名会怎么变化-那如果是匿名空间呢"><a href="#_7-c和c-在编译时-函数名会怎么变化-那如果是匿名空间呢" class="header-anchor">#</a> 7.C和C++在编译时,函数名会怎么变化,那如果是匿名空间呢?</h2> <p>​	在匿名命名空间中声明的名称也将被编译器转换，与编译器为这个匿名命名空间生成的唯一内部名称(即这里的<code>__UNIQUE_NAME_)</code>绑定在一起</p> <h2 id="_8-萃取-traits-技巧「模版的应用」"><a href="#_8-萃取-traits-技巧「模版的应用」" class="header-anchor">#</a> 8.萃取 traits 技巧「模版的应用」</h2> <p>​	 面试时候，大概回答：traits，一种模板偏特化的应用。《STL源码剖析》一书中提到<strong>Traits编程技法</strong>，它的作用是获取型别(associated type)的特性。</p> <ul><li>参考资料：https://mp.weixin.qq.com/s/rPh9PfTjPCROj1EmWHA6nw</li></ul> <p>在 STL 编程中，容器和算法是独立设计的，即数据结构和算法是独立设计的，连接容器和算法的桥梁就是迭代器了，迭代器使其独立设计成为可能</p> <p>​	这样讲比较抽象，到底什么是相应型别</p> <p>​	或者到底什么时候需要用到Traits编程技法呢？</p> <p>​	traits 是模板元编程中的一个非常重要的概念，它可以<strong>萃取</strong>类型中的许多重要信息，利于 我们在<strong>编译期</strong>提早做出决断。</p> <p>​	<strong>traits，又被叫做特性萃取技术</strong>，说得简单点就是提取“被传进的对象”对应的返回类型，让同一个接口实现对应的功能。因为STL的算法和容器是分离的，两者通过迭代器链接。算法的实现并不知道自己被传进来什么。萃取器相当于在接口和实现之间加一层封装，来隐藏一些细节并协助调用合适的方法，这需要一些技巧（例如，偏特化）。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">TraitsHelper</span> <span class="token punctuation">{</span>
     <span class="token keyword">typedef</span> T ret_type<span class="token punctuation">;</span> <span class="token comment">//返回值</span>
     <span class="token keyword">typedef</span> T par_type<span class="token punctuation">;</span> <span class="token comment">//对应的值</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">TraitsHelper</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token comment">//模版偏特化</span>
     <span class="token keyword">typedef</span> <span class="token keyword">int</span> ret_type<span class="token punctuation">;</span>
     <span class="token keyword">typedef</span> <span class="token keyword">int</span> par_type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">TraitsHelper</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
     <span class="token keyword">typedef</span> <span class="token keyword">float</span> ret_type<span class="token punctuation">;</span>
     <span class="token keyword">typedef</span> <span class="token keyword">int</span> par_type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
     TraitsHelper<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>ret_type  <span class="token comment">//借助传入的T，走一遍偏特化的路径，完美就能获得一个返回值类型</span>
       	<span class="token function">Compute</span><span class="token punctuation">(</span> TraitsHelper<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>par_type d <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这样完美的Compute函数，就能根据不能类型的类型，进行不同的处理！</span>
<span class="token keyword">private</span><span class="token operator">:</span>
     T mData<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><ul><li>【C++模版之旅】<a href="https://blog.csdn.net/my_business/article/details/7891687" target="_blank" rel="noopener noreferrer">神奇的Traits<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>「解释得最简单」</li> <li>参考资料：https://yosef-gao.github.io/2016/10/05/cpp-traits/「举例」</li> <li>第 3 章 类型特征萃取，C++11/14高级编程，Boost程序库探秘，http://www.tup.tsinghua.edu.cn/upload/books/yz/069426-01.pdf</li></ul> <h2 id="_9-菱形继承「虚基础」"><a href="#_9-菱形继承「虚基础」" class="header-anchor">#</a> 9.菱形继承「虚基础」</h2> <ul><li>CSDN<a href="https://blog.csdn.net/jackystudio/article/details/17877219" target="_blank" rel="noopener noreferrer">解释得不错<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>​	菱形继承是多重继承中跑不掉的，Java拿掉了多重继承，辅之以接口。C++中虽然没有明确说明接口这种东西，但是只有纯虚函数的类可以看作Java中的接口。</p> <p>​	如下是菱形继承的代码。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">printA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span>  <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span> <span class="token punctuation">,</span>  <span class="token keyword">public</span> <span class="token class-name">C</span></span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    D d<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h2 id="c-核心详解"><a href="#c-核心详解" class="header-anchor">#</a> C++核心详解</h2> <p>学C++的利器：</p> <ul><li>this指针不是object的一部分</li> <li>虚函数表属于class
<ul><li>每个object有属于各自的<strong>虚函数表指针</strong></li></ul></li></ul> <h2 id="✅『oob』基于对象的程序设计"><a href="#✅『oob』基于对象的程序设计" class="header-anchor">#</a> ✅『OOB』基于对象的程序设计</h2> <h2 id="_1-对比class-struct-union和enum"><a href="#_1-对比class-struct-union和enum" class="header-anchor">#</a> 1.对比<code>class/struct/union</code>和<code>enum</code></h2> <ul><li>class</li> <li>struct</li> <li>union</li> <li>enum『枚举类型<strong>是1种基本类型</strong>，不是1种构造类型，因为它不能再分解为任何其他基本类型，比如，<code>class</code>，<code>struct</code>，<code>union</code>』</li></ul> <h3 id="_1-1-class"><a href="#_1-1-class" class="header-anchor">#</a> 1.1.<code>class</code></h3> <p>1、继承：默认是『private继承』
2、内部可以放成员变量，成员函数，默认成员变量访问控制是：『private』
3、成员函数分类：
有』构造函数
有』析构函数
有』虚函数</p> <h3 id="_1-2-struct『c-中』"><a href="#_1-2-struct『c-中』" class="header-anchor">#</a> 1.2.<code>struct</code>『C++中』</h3> <blockquote><p>本质：<strong>是一种class</strong></p></blockquote> <p>1、继承：默认是『public继承』
2、内部可以放成员变量，成员函数，默认成员变量访问控制是：『public』
3、成员函数分类：
有』构造函数
有』析构函数
有』虚函数</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

		<span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;a=&quot;</span><span class="token operator">&lt;&lt;</span><span class="token keyword">this</span><span class="token operator">-&gt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;die AAA&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">myPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;*AAA******&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">//struct B : private A</span>
<span class="token comment">//下面的写法，等价于，struct B : public A</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span>  <span class="token base-clause"><span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> b<span class="token punctuation">;</span>
	<span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">888</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;b=&quot;</span><span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;die BBB&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">myPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;*BBBB******&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>

	<span class="token comment">//因为加上了system(&quot;pause&quot;);所以需要下面这样挂掉B，才能知道B的析构函数被调用</span>

	<span class="token punctuation">{</span>
		A one<span class="token punctuation">;</span>
		one<span class="token punctuation">.</span><span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		B two<span class="token punctuation">;</span>
		two<span class="token punctuation">.</span><span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

		A <span class="token operator">*</span> pointer<span class="token operator">=</span><span class="token keyword">new</span> B<span class="token punctuation">;</span>
		pointer<span class="token operator">-&gt;</span><span class="token function">myPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br></div></div><h3 id="_1-3-union『c-中』"><a href="#_1-3-union『c-中』" class="header-anchor">#</a> 1.3.<code>union</code>『C++中』</h3> <blockquote><p>本质：它是一种<strong>特殊的类</strong></p></blockquote> <ul><li>参考《后台开发》</li></ul> <p>1、继承：『不可以继承』继承自别人/能给别人继承都不可以
2、内部可以放成员变量，成员函数，默认成员变量访问控制是：『public』
3、成员函数分类：
有』构造函数
有』析构函数
<strong>不可以有』虚函数</strong></p> <h3 id="_1-4-enum『只有它不是特殊的类』"><a href="#_1-4-enum『只有它不是特殊的类』" class="header-anchor">#</a> 1.4.<code>enum</code>『只有它不是特殊的类』</h3> <p>1、枚举类型<strong>是1种基本类型</strong>，不是1种构造类型</p> <p>2、因为它不能再分解为任何其他基本类型『比如，<code>class</code>，<code>struct</code>，<code>union</code>』</p> <h2 id="_2-类的『成员变量』和『非成员变量』⭐️"><a href="#_2-类的『成员变量』和『非成员变量』⭐️" class="header-anchor">#</a> 2.类的『成员变量』和『非成员变量』⭐️</h2> <img src="/assets/img/成员变量和非成员变量.abeeccdf.png"> <h3 id="_2-1-成员变量"><a href="#_2-1-成员变量" class="header-anchor">#</a> 2.1.成员变量</h3> <p><strong>书中记载</strong>：</p> <ul><li>nonstatic member 非静态成员
<ul><li>普通数据成员</li> <li>const数据成员</li></ul></li> <li>static member 静态成员</li></ul> <p><strong>static成员变量</strong></p> <ul><li>c++的一个类中『<strong>声明</strong>』一个static成员变量，static是加了访问控制的全局变量，不被继承</li> <li>类和子类对象，static变量占有一份内存</li></ul> <blockquote><p>重点理解：<strong>静态成员变量的初始化一定要在『类外』</strong></p></blockquote> <p>原因： 因为静态成员变量本身在main函数未开始时已经存在。不要让成员变量的初始化依赖于对象。不用对象，难到就不能用这一变量了吗？如果将初始化放在类内。那么<strong>当不声明对象时</strong>，无法使用这一静态变量。编译器报错为‘undeclared identifier’</p> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>类中的声明和定义辨析：（重点、难点）
笔者的看法是：
1、逻辑上说明是一起，只能表示可以『声明』在一起。（声明的门槛很低）
2、具体内存在哪分配，这个决定『能不能在类内』进行『定义』

比如：
1、友元函数在『类内』声明，不能在『类内』定义，能在『类外』定义
2、static成员变量在『类内』声明，不能在『类内』定义，能在『类外』定义
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>参考自：<a href="https://www.huaweicloud.com/articles/4637f3d11eb3fd9a38e017041e23e50a.html" target="_blank" rel="noopener noreferrer">华为云<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p><strong>static和非static特点</strong></p> <ul><li>静态成员存在于<strong>内存</strong>，非静态成员需要实例化才会分配内存（注意，也就是在虚拟内存空间中，表示的是.bss和.data段中）</li> <li>非静态成员的生存期决定于该类的生存期，而静态成员生存期则与程序生命期相同</li></ul> <h3 id="_2-2-非成员变量"><a href="#_2-2-非成员变量" class="header-anchor">#</a> 2.2.非成员变量</h3> <h2 id="_3-类的『成员函数』和『非成员函数』⭐️"><a href="#_3-类的『成员函数』和『非成员函数』⭐️" class="header-anchor">#</a> 3.类的『成员函数』和『非成员函数』⭐️</h2> <img src="/assets/img/成员函数和非成员函数.18eaed6b.png"> <blockquote><p>我的<a href="http://naotu.baidu.com/file/02d2413a51829d0c29226a23718613ad?token=d83f2eb1c2d887a6" target="_blank" rel="noopener noreferrer">百度脑图<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>说明：成员函数的分类，需要考虑排序组合，<strong>是很多，很复杂</strong>的，不然就只能一个一个维度去分类。</p></blockquote> <h3 id="_3-1-成员函数"><a href="#_3-1-成员函数" class="header-anchor">#</a> 3.1.成员函数</h3> <ul><li>到底什么是成员函数？</li> <li>类的成员函数：是定义为<strong>类的一部分</strong>的函数，有时也被称为方法。（C++primer第5版，P20）</li> <li>各类函数中：构造函数、析构函数、拷贝初始化构造函数等是类的成员函数。</li> <li>成员函数分下面3类（应该说是2类，纯虚函数属于虚函数的子集的话）</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>1、非虚函数（non-virtual 函数）：
你『不希望』派生类（derived class）重新定义 (override, 复写) 它.



2、虚函数（virtual 函數）：
你希望 derived class 重新定义 (override, 复写) 它，且你对它已有『默认』定义。
3、纯虚函数（pure virtual 函數）：
你希望 derived class 『一定』要重新定义 (override 复写)
它，你对它沒有默认定义。

PS：我们把不是纯的虚函数的虚函数叫作（impure virtual函数）
PS：在语法上，我们只要在任何一个函数前面加上virtual这样一个关键字，它就成为一个虚函数。
数据可以被继承下来，就是占它用了内存。
函数的继承如何理解？但是不应该从内存角度理解，函数的继承，继承的是调用权利

PS：其实纯虚函数是可以有定义的！！
&gt; 出处：《C++Primer》中文版第五版541页第22行。
我们可以为纯虚函数提供定义，不过函数体『必须定义在类的外部』。若定义在类的内部，会出现错误：pure-specifier on function-definition。
》 虚函数是可以定义『在类的内部的』，外部也可以！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><blockquote><p>参考自：侯捷</p></blockquote> <ul><li><p><strong>override</strong>这个术语，在这个主题不能随便用！！</p></li> <li><p>这个术语，<strong>一定是用在『虚函数』被重新定义，才能够叫（override）</strong></p></li> <li><p>🐾<font style="background:yellow;">无法继承的『static成员函数』</font></p></li> <li><p><strong>纯虚函数</strong>：只提供一个<strong>接口</strong>，具体实现方法需要<strong>派生类</strong>自己去实现，纯虚函数本身不可以有实现</p></li> <li><p><strong>非虚函数</strong>：提供接口，并且强制<strong>实现</strong>方法</p></li></ul> <blockquote><p>根据《<strong>深度探索C++对象模型</strong>》一书所说：</p></blockquote> <p>原始的“C with Classes”只支持，<strong>（Nonstatic member function）非静态成员函数</strong></p> <p><strong>（Virtual function）虚函数</strong>，是在20世纪80年代中期加入进来的。</p> <p><strong>（Static member function）静态成员函数</strong>是最后被引入的一种函数类型!</p> <p>书中说道：<font style="background:pink;">C++支持3种类型的**（member function）成员函数**</font>『记住下面的』</p> <ul><li>1、static member function</li> <li>2、nonstatic member function
<ul><li>1、普通的成员函数</li> <li>2、const成员函数</li></ul></li> <li>3、virtual member function</li></ul> <p>成员函数中<strong>易错</strong>：</p> <ul><li>由于成员函数中的const成员函数，const<strong>实际</strong>上修饰的是<strong>this指针</strong>。</li> <li><font style="background:yellow;">所以<strong>在成员函数</strong>中，<strong>static</strong>和<strong>const不能同时</strong>修饰同一个成员函数</font>，因为==static成员函数<strong>没有this指针</strong>==。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">//这行没错</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">1000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
    	<span class="token comment">//修饰变量，这行却没错</span>
		<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>
  
    	<span class="token comment">//下面会出错，[Error] static member function 'static void A::demo()' cannot have cv-qualifier</span>
		<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> 
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="_3-2-非成员函数"><a href="#_3-2-非成员函数" class="header-anchor">#</a> 3.2.非成员函数</h3> <h4 id="_3-2-1-友元函数"><a href="#_3-2-1-友元函数" class="header-anchor">#</a> 3.2.1.友元函数</h4> <ul><li>注意：<font style="background:yellow;">友元函数不是类的成员函数！</font>（<strong>欢聚时代</strong>）</li></ul> <p>1、友元函数的『<strong>声明</strong>』可以放在类<strong>声明</strong>的任何地方，不受访问限定关键字private、protected、public的限制</p> <p>2、尽管友元函数的<strong>原型</strong>有在<strong>类的定义</strong>中出现过，但是<strong>友元函数并不是成员函数</strong>。</p> <p>3、友元是一种<strong>定义在类外部</strong>的普通函数（友元函数既可以在类的内部，也可以在类的外部定义《<strong>C++primer</strong>》中说了），但它需要在类体内进行<strong>说明『声明』</strong>，为了与该类的成员函数加以区别，在说明时前面加以关键字friend</p> <blockquote><p>参考自：菜鸟教程<a href="https://www.runoob.com/cplusplus/cpp-friend-functions.html" target="_blank" rel="noopener noreferrer">C++ 友元函数<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h4 id="_3-2-2-友元"><a href="#_3-2-2-友元" class="header-anchor">#</a> 3.2.2.友元</h4> <p>1、『<font style="background:yellow;">友元函数是不能被继承的</font>——解释，你父亲的朋友不能继承给你？』，<font style="background:yellow;">友元函数<strong>没有this指针</strong></font>。</p> <p>2、友元只是破坏了类的隐藏性和封装性，<font style="background:yellow;">可以直接调用，不需要通过对象或者指针</font></p> <h2 id="_4-big-three讲解"><a href="#_4-big-three讲解" class="header-anchor">#</a> 4.<code>Big Three</code>讲解</h2> <p>参考自：侯捷的说法，好像来自《C++ Primer》</p> <h3 id="_4-1-构造函数详解"><a href="#_4-1-构造函数详解" class="header-anchor">#</a> 4.1.构造函数详解</h3> <h4 id="_1-普通ctor-普通构造函数"><a href="#_1-普通ctor-普通构造函数" class="header-anchor">#</a> 1.普通ctor（普通构造函数）</h4> <ul><li>1、无参的普通构造函数</li> <li>2、<strong>有参</strong>的普通构造函数
<ul><li>（1）<strong>类型转换</strong>构造函数：只有<strong>1个参数</strong>的普通构造函数一般都可以称作『类型转换构造函数』</li> <li>（2）其他<strong>有参</strong>的普通构造函数</li></ul></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
    	
    	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//无参的『普通构造函数』</span>
  
  	
    	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token comment">//有参的『普通构造函数』，并且由于只有1个参数，也叫『类型转换构造函数』</span>
        <span class="token punctuation">{</span>
          	cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;Int Constructor calles&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
    	<span class="token function">A</span><span class="token punctuation">(</span>A <span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token comment">//拷贝构造函数，原因是参数是『本类类型的引用』</span>
        <span class="token punctuation">{</span>
            cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;Copy ctor&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
            
        <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h4 id="_2-copy-ctor"><a href="#_2-copy-ctor" class="header-anchor">#</a> 2.copy ctor</h4> <p>copy ctor又称：复制构造函数，拷贝构造函数，拷贝<strong>初始化</strong>构造函数</p> <p>分为：</p> <p>1、默认的『copy ctor』</p> <p>2、如果你自行编写了新的copy ctor，那么默认的copy ctor就不存在了</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Demo <span class="token function">c2</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//会调用copy ctor，初始化</span>

Demo c2<span class="token operator">=</span>c1<span class="token punctuation">;</span> <span class="token comment">//会调用copy ctor，注意是初始化，不是赋值！</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_4-2-析构函数详解"><a href="#_4-2-析构函数详解" class="header-anchor">#</a> 4.2.析构函数详解</h3> <h4 id="_4-2-1-有无virtual"><a href="#_4-2-1-有无virtual" class="header-anchor">#</a> 4.2.1.有无virtual</h4> <p>1、<strong>没有</strong>virtual的析构函数，又称：<strong>一般</strong>的析构函数</p> <p>2、<strong>有</strong>virtual的析构函数</p> <p>tips：析构时注意区别 <code>delete</code> 和 <code>delete[]</code></p> <h4 id="_4-2-2-是否私有"><a href="#_4-2-2-是否私有" class="header-anchor">#</a> 4.2.2.是否私有</h4> <p>在C++中，为了让某个类<strong>只能通过new来创建</strong>（即如果直接创建对象，编译器将报错）</p> <ul><li>应该将<strong>析构函数设为<font style="background:pink;">私有</font></strong></li></ul> <h2 id="_5-访问属性"><a href="#_5-访问属性" class="header-anchor">#</a> 5.访问属性</h2> <h3 id="_5-1-内部访问和对象访问"><a href="#_5-1-内部访问和对象访问" class="header-anchor">#</a> 5.1.内部访问和对象访问</h3> <div class="language- extra-class"><pre><code>类的成员有三种访问属性，分别是public、protected、private，[子类能够访问的成员](https://www.nowcoder.com/test/question/done?tid=44308742&amp;qid=1618#summary)是
</code></pre></div><blockquote><p>参考牛客的答案：</p></blockquote> <img src="/assets/img/访问权限.ce788b0d.png"> <h2 id="_6-namespace命名空间"><a href="#_6-namespace命名空间" class="header-anchor">#</a> 6.<code>namespace</code>命名空间</h2> <p>namespace，是指标识符的各种可见范围</p> <p>C++标准程序库中的所有标识符都被定义于一个名为<code>std</code>的namespace中。</p> <p>1、<code>&lt;iostream&gt;</code>和&lt;iostream.h&gt;格式不一样，前者没有后缀，实际上，在你的编译器include文件夹里面可以看到，二者是两个文件，打开文件就会发现，里面的代码是不一样的。</p> <p>2、后缀为.h的头文件c++标准已经明确提出不支持了，早些的实现将标准库功能定义在<strong>全局空间</strong>里，声明在带.h后缀的头文件里，c++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。</p> <p>3、因此。命名空间主要是将全局空间『<strong>划分</strong>为更加小块的全局空间』</p> <h2 id="_7-其余"><a href="#_7-其余" class="header-anchor">#</a> 7.其余</h2> <div class="language- extra-class"><pre><code>1、一个基类的声明中有纯虚函数，该基类派生类一定不再是抽象类（说法错误！）
</code></pre></div><p>原因：如果在派生类中<strong>没有</strong>对所有纯虚函数进行定义，则此派生类仍然是抽象类，不能用来定义对象。所以A错.</p> <div class="language- extra-class"><pre><code>2、构造函数**不能**被覆盖
</code></pre></div><h2 id="✅『oop』面向对象的程序设计"><a href="#✅『oop』面向对象的程序设计" class="header-anchor">#</a> ✅『OOP』面向对象的程序设计</h2> <p>1、面向对象的三大基本特征：封装、继承、多态</p> <p>2、面向对象的五大基本原则：</p> <p>单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则</p> <h3 id="_1-1-类型转换函数-类型转换函数-不等于-类型转换构造函数"><a href="#_1-1-类型转换函数-类型转换函数-不等于-类型转换构造函数" class="header-anchor">#</a> 1.1.类型转换函数(类型转换函数-不等于-类型转换构造函数)</h3> <p>1、带<strong>非默认参数</strong>的构造函数可以把<strong>基本类型数据</strong>转换成类类型对象。</p> <p>2、『类型转换函数』可以把类类型对象转换为其他指定类型对象。</p> <p>3、『类型转换函数』只能定义为一个类的成员函数，<strong>不能</strong>定义为类的<strong>友元函数。</strong></p> <h2 id="_1-辨析overload、override、overwrite⭐️『已解决』"><a href="#_1-辨析overload、override、overwrite⭐️『已解决』" class="header-anchor">#</a> 1.辨析Overload、Override、Overwrite⭐️『已解决』</h2> <h4 id="_1-1-函数名称相同和重载不是一回事-比如全局函数和class里面的函数-作用域都不一样了"><a href="#_1-1-函数名称相同和重载不是一回事-比如全局函数和class里面的函数-作用域都不一样了" class="header-anchor">#</a> 1.1.函数名称相同和重载不是一回事！比如全局函数和class里面的函数，作用域都不一样了</h4> <ul><li>函数名称相同，参赛列表相同，但是也可以不是重载、重写、重定义</li></ul> <p>如下，是2个不同的函数！他们的<strong>作用域都不一样</strong>！</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//a.cpp</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//b.cpp</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="_1-2-重载-overload"><a href="#_1-2-重载-overload" class="header-anchor">#</a> 1.2.<strong>重载(Overload)</strong>：</h4> <ul><li><p><strong>在同一作用域内</strong>，函数名相同，函数的参数个数、参数类型或参数顺序三者中必须至少有一种不同。函数返回值的类型可以相同，也可以不相同。比如：发生在一个类内部。</p> <p>郑莉：C++允许功能相近的函数在<strong>相同的作用域内</strong>以相同函数名声明。从而形成重载。方便使用记忆。</p> <p>《<strong>C++ Primer</strong>》P206，如果“<strong>同一作用域</strong>”内的几个函数名字相同但“形参列表”不同，我们称之为重载（<strong>overloaded</strong>）函数</p></li></ul> <h4 id="_1-3-重写-override-「我觉得翻译为覆盖更好-」"><a href="#_1-3-重写-override-「我觉得翻译为覆盖更好-」" class="header-anchor">#</a> 1.3.<strong>重写(Override)</strong>：「我觉得翻译为<strong>覆盖</strong>更好！」</h4> <div class="language- extra-class"><pre><code>也叫做**覆盖**，也叫**复写**，一般发生在子类和父类继承关系之间「发生在继承这种类型的不同作用域」。子类**重新定义**父类中有相同名称和参数的&lt;font style=&quot;background: yellow&quot;&gt;『**虚函数**』&lt;/font&gt;
</code></pre></div><h4 id="_1-4-隐藏-hide-好像还有人说overwrite是重定义"><a href="#_1-4-隐藏-hide-好像还有人说overwrite是重定义" class="header-anchor">#</a> 1.4.**隐藏（hide）**好像还有人说overwrite是重定义</h4> <div class="language- extra-class"><pre><code>子类**重新定义**父类中有相同名称的&lt;font style=&quot;background: yellow&quot;&gt;『**非虚函数**』 &lt;/font&gt;( 参数列表可以不同 ) ，指派生类的函数**屏蔽**了与其同名的基类函数。可以理解成发生在继承中的重载。
</code></pre></div><blockquote><p>参考：<a href="https://blog.csdn.net/u010275850/article/details/45583705" target="_blank" rel="noopener noreferrer">C++_重载、重写和重定义的区别<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>PS：但是，从很多英语教材上面，来说，重定义和重写都是单词（override），理解参考第4节</p> <ul><li>子类重新定义父类虚函数的方法叫做覆写</li> <li>多态是为了<strong>接口</strong>重用，封装和继承是为了代码重用</li></ul> <p>是的，override和overwrite是同一个概念。Override指的是在继承类中重写父类的方法，而overwrite指的是覆盖源文件中的内容。例如，在<strong>Java中</strong>，如果在子类中重写父类的方法，就可以使用<strong>override关键字</strong>，而如果要覆盖文件中的内容，就可以使用<strong>overwrite关键字</strong>。</p> <h3 id="✅区分overload、overwrite和override"><a href="#✅区分overload、overwrite和override" class="header-anchor">#</a> ✅区分Overload、Overwrite和Override</h3> <ul><li>注意，由于这3个词的翻译很尴尬，众说纷纭，我们直接考虑单词来</li> <li>『记忆版』</li></ul> <blockquote><p>参考：<a href="https://blog.csdn.net/jszhangyili/article/details/7570311" target="_blank" rel="noopener noreferrer">CSDN的jszhangyili博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <img src="/assets/img/class中函数3大概念.43294c4e.png"> <blockquote><p>都是在函数名相同的时候，都不考虑返回值的情况下，我们讨论下面3组</p></blockquote> <ul><li>Overload
<ul><li><strong>相同作用域</strong>『可以不是class中』
<ul><li>参数相同，如果在class中，这样写就很奇怪了，<font style="background:yellow;">报错</font></li> <li>参数不同，就是重载</li></ul></li></ul></li> <li>Override『显然是继承才有这个概念！whoway』覆写
<ul><li>==继承==体系，不同作用域</li> <li>基类该函数是虚函数</li> <li>参数相同</li></ul></li> <li>Overwrite
<ul><li>继承体系，不同作用域
<ul><li>情况1：参数不同，无论基类该函数是不是虚函数</li> <li>情况2：参数相同，基类如果是『非虚函数』，那么就意味着在派生类中<strong>重新定义</strong>一个函数，<font style="background:yellow;">也就是非多态</font></li></ul></li></ul></li></ul> <h3 id="同一个class里面的成员函数加-不加virtual算不算重载"><a href="#同一个class里面的成员函数加-不加virtual算不算重载" class="header-anchor">#</a> 同一个class里面的成员函数加/不加virtual算不算重载？</h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>

    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;non-virtual=%d\n&quot;</span><span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;virtual=%d\n&quot;</span><span class="token punctuation">,</span> val<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;BBB&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    A a<span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@CentosLinux apue<span class="token punctuation">]</span><span class="token comment"># g++ demo.cpp </span>
demo.cpp:15:18: error: ‘virtual void A::test<span class="token punctuation">(</span><span class="token punctuation">)</span>’ cannot be ⭐️overloaded「重载」⭐️
     virtual void test<span class="token punctuation">(</span><span class="token punctuation">)</span>
                  ^
demo.cpp:11:10: error: with ‘void A::test<span class="token punctuation">(</span><span class="token punctuation">)</span>’
     void test<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>如上，<code>virtual void A::test()</code>不能被<strong>重载！！</strong></li></ul> <h3 id="那下面这样的叫什么"><a href="#那下面这样的叫什么" class="header-anchor">#</a> 那下面这样的叫什么？</h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;global=%d\n&quot;</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>

    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;virtual=%d\n&quot;</span><span class="token punctuation">,</span> val<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    A a<span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>​</p> <div class="language- extra-class"><pre><code>在上面的代码中，全局的`test()`函数和类`A`中的`test()`函数**虽然具有相同的名称**，但它们**所在作用域不同**，**就像两个不同文件里面的作用域分别都叫test**，因此它们不是函数的重载（overloading）。实际上，全局的`test()`函数和类`A`中的`test()`函数属于**两个不同的函数**。

全局的`test()`函数和类`A`中的`test()`函数是两个不同的函数，它们没有重载的关系，也没有覆盖或重写的关系!

因为函数重载，强调了，要在同一作用域。
</code></pre></div><h4 id="chatgpt"><a href="#chatgpt" class="header-anchor">#</a> chatgpt</h4> <p>那给我区别一下C++里面的Overload、Override、Overwrite</p> <p>在C++中，<code>Overload</code>、<code>Override</code>和<code>Overwrite</code>都是与函数有关的概念，它们分别表示不同的含义：</p> <ol><li>Overload（重载）：是指在<strong>同一作用域</strong>内，定义多个函数名相同但参数列表不同的函数。C++允许在同一个作用域内定义多个同名函数，只要它们的参数列表不同，这就是函数重载。重载的目的是为了提高代码的复用性和可读性。</li> <li>Override（覆盖）：是指在==派生类==中重新定义（或覆盖）基类中的==虚函数==。当一个派生类重定义了一个虚函数时，它将覆盖基类中的函数，从而在运行时调用派生类的函数而不是基类的函数。这样做可以实现运行时多态性，从而允许以统一的方式操作不同类型的对象。</li> <li>Overwrite（覆盖）：是指在==派生类==中定义与基类中的==非虚函数同名==的函数。当派生类定义一个与基类中的非虚函数同名的函数时，该函数将覆盖基类中的函数，从而在运行时调用派生类的函数而不是基类的函数。由于C++不支持非虚函数的多态性，因此覆盖非虚函数往往不是一个好的编程实践，容易导致意外的行为。</li></ol> <p>我觉得回答还好！</p> <div class="language- extra-class"><pre><code>总的来说，我觉得这些区别，可能是这么比较，但是像**编译器**可能还是会将像：同一个class里面的成员函数加/不加virtual算重载，虽然是同一作用域，但是参数列表不是一样吗？「但是这样又破除了，咋们对这些的理解」
</code></pre></div><h2 id="_2-多态与虚函数"><a href="#_2-多态与虚函数" class="header-anchor">#</a> 2.多态与虚函数</h2> <h3 id="_2-1-static变量的说明"><a href="#_2-1-static变量的说明" class="header-anchor">#</a> 2.1.<code>static</code>变量的说明</h3> <p>c++的一个类中声明一个<strong>static成员变量</strong>，下面描述正确的是</p> <ul><li>static是加了<strong>访问控制</strong>的全局变量，『<strong>不被继承</strong>』，类和子类对象，static变量占有一份内存</li></ul> <h3 id="_2-2-虚函数相关"><a href="#_2-2-虚函数相关" class="header-anchor">#</a> 2.2.虚函数相关</h3> <ul><li>1、（static）静态函数不可以是虚函数『虚成员函数不可能是static 成员函数』</li> <li>2、（inline）虚函数可以声明为inline，但是编译器不会将其作为inline函数处理『有的选择题故意为难，但是其实<strong>虚函数是可以声明为inline的，但是分情况</strong>』』</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">a</span>
<span class="token punctuation">{</span>
    <span class="token keyword">inline</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language- extra-class"><pre><code>尽管以上写法是没有语法错误的，并且可以执行，但其实test函数已经不是内联函数了，因为inline只是对编译器的一个建议而已。搞清本质就好。
</code></pre></div><h3 id="_2-2-虚函数能不能inline"><a href="#_2-2-虚函数能不能inline" class="header-anchor">#</a> 2.2.虚函数能不能inline</h3> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>Q:虚函数不能内联，但是语法不出错？

A:不是的，虚函数在『『没有表现多态的时候』』是可以内联的，表现多态的时候不能

『没有表现多态的时候』:内联只是对编译器的一种请求，是否真正内联要看编译器的处理，虚函数是可以内联的，但是编译器不会响应内联请求，即他会忽略内联说明，将其当做普通虚函数处理。

有说法说：
虚函数不可以内联，因为虚函数是在运行期的时候确定具体调用的函数，内联是在编译期的时候进行代码展开，两者冲突，所以没有一起使用的做法。『『这是不严谨的』』
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_3-『多态神器』-多态3条件"><a href="#_3-『多态神器』-多态3条件" class="header-anchor">#</a> 3.『多态神器』-多态3条件</h2> <h3 id="_3-1-条件1和条件2❎『非多态』"><a href="#_3-1-条件1和条件2❎『非多态』" class="header-anchor">#</a> 3.1.条件1和条件2❎『非多态』</h3> <ul><li><p>例题1.</p></li> <li><p>牛客上配套习题：<a href="https://www.nowcoder.com/test/question/done?tid=44172669&amp;qid=15197#summary" target="_blank" rel="noopener noreferrer">传送门<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>题解：</p></li> <li><p>这一题中，最后一个c，是相当于强制类型转换，『或许叫：向下转型？？』，然后没有通过指针来调用</p></li> <li><p>用牛油的一个解释：动态绑定（多态）只有在指针和引用时才有效，其他情况下无效。</p></li></ul> <h3 id="_3-2-条件3❎『非多态』"><a href="#_3-2-条件3❎『非多态』" class="header-anchor">#</a> 3.2.条件3❎『非多态』</h3> <ul><li>例题2.</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">mytest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;AAA&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mytest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;BBB&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>	
<span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	
	A <span class="token operator">*</span> p<span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span>
	p<span class="token operator">-&gt;</span><span class="token function">mytest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//输出的是AAA</span>
    
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span> 

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><ul><li>本题不是动态绑定原因分析：</li> <li>1、通过指针来调用『注意，引用显然也是的，因为底层也是指针』
<ul><li>满足，用了<code>p-&gt;mytest();</code></li></ul></li> <li>2、这个指针是向上转型up cast了『比如，派生类赋值给基类指针，基类指针调用』
<ul><li>满足，A是B的基类</li></ul></li> <li>3、调用虚函数❎不满足
<ul><li>因为p指针是A类型的，但是在classA中该函数还不是『虚函数』，因此次数，不能走偏移vptr的路径，想走虚函数指针—虚函数表的路径走不通。只能老老实实转换为调用<code>A::test()</code>这个非虚函数</li></ul></li></ul> <h3 id="_3-3-虚析构函数"><a href="#_3-3-虚析构函数" class="header-anchor">#</a> 3.3.虚析构函数</h3> <ul><li><p>例题3</p></li> <li><p><font style="background:yellow;">虚析构函数：是为了解决基类的指针指向派生类对象，并且用『基类指针』删除派生类对象。</font></p></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">A</span><span class="token punctuation">(</span>A <span class="token operator">&amp;</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;3&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;4&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">B</span><span class="token punctuation">(</span>B <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;5&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;6&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    A <span class="token operator">*</span>pa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> pa<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//输出是：1 4 6 3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><ul><li><p>考察的是对继承体系中的构造和析构函数调用顺序的理解。</p></li> <li><p>在调用new B()的时候，因为B继承A，所以会首先调用其父类的构造函数，输出1</p></li> <li><p>然后调用自己的构造函数，输出4</p></li> <li><p>//析构的时候，是会调用的</p></li> <li><p>对比，下面，如果去除掉A的析构函数的，虚函数</p></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-txt line-numbers-mode"><pre class="language-txt"><code>输出为：1 4 3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>原因：
<ul><li><strong>静态绑定，this指针直接调用了A的析构</strong>，B的没有。</li> <li>很显然，有的时候，会出问题。</li></ul></li></ul> <h3 id="_3-4-『添加作用域的调用』"><a href="#_3-4-『添加作用域的调用』" class="header-anchor">#</a> 3.4.『添加作用域的调用』</h3> <ul><li><p>例题4</p></li> <li><p>多态情况下，不调用多态</p></li> <li><p>牛客网<a href="https://www.nowcoder.com/test/question/done?tid=44308742&amp;qid=180817#summary" target="_blank" rel="noopener noreferrer">题目<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：</p></li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>类B是类A的公有派生类，类A和类B中都定义了虚函数func(),p是一个指向类A对象的指针，则p-&gt;A::func()将（）？

正确答案: C   你的答案: C (正确)

A	调用类B中函数func()
B	即调用类A中函数，也调用类B中的函数
C	调用类A中函数func()
D	根据p所指的对象类型而确定调用类A中或类B中的函数func()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>不论指针p是属于类A还是类B，也不论指针p指向的对象属于类A还是类B(当然，不能用类B的指针指向类A的对象)，<strong>因为加了作用域说明符<code>A::</code>，因此都只会调用类A的函数</strong>。</li></ul> <h3 id="_3-5-静态绑定的核心理解『易错难点』⭐️"><a href="#_3-5-静态绑定的核心理解『易错难点』⭐️" class="header-anchor">#</a> 3.5.静态绑定的核心理解『易错难点』⭐️</h3> <ul><li>例题5</li> <li>易错的题目<a href="https://www.nowcoder.com/test/question/done?tid=44470246&amp;qid=44536#summary" target="_blank" rel="noopener noreferrer">传送门<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
		<span class="token punctuation">{</span> 
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;test A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	A <span class="token operator">*</span>pA <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//注意『这是个幌子』</span>
	pA<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ul><li>有4个选项</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-txt"><code>问你选什么？
A    编译出错
B    程序运行奔溃
C    输出&quot;test A&quot;
D    输出乱码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>答案选C：<strong>输出&quot;test A&quot;</strong></li></ul> <p><img src="https://cdn.jsdelivr.net/gh/whoway/picture/img/image-20210711202412877.png" alt="image-20210711202412877"></p> <ul><li>原因：
<ul><li>因为<strong>对于非虚成员函数，Ｃ++这门语言是静态绑定的</strong>。</li> <li><font style="background:yellow;">这也是Ｃ++语言和其它语言Java, Python的一个显著区别</font></li> <li><code>//pA-&gt;test();</code>这语句的意图是：调用对象 pA 的 test 成员函数。如果这句话在Java或Python等动态绑定的语言之中，编译器生成的代码大概是：
<ul><li>找到 pA 的 test 成员函数，调用它。（注意，这里的找到是程序运行的时候才找的，这也是所谓动态绑定的含义：运行时才绑定这个函数名与其对应的实际代码。有些地方也称这种机制为迟绑定，晚绑定。）</li></ul></li> <li>但是对于C++。为了保证程序的运行时效率，Ｃ++的设计者认为凡是编译时能确定的事情，就不要拖到运行时再查找了。所以C++的编译器看到这句话会这么干：
<ul><li>１：查找 pA 的类型，发现它有一个非虚的成员函数叫 test 。（编译器干的）</li> <li>２：找到了，在这里生成一个函数调用，直接调<code>A:: test ( pA )</code>。</li></ul></li> <li>所以到了运行时，由于 test ()函数里面并没有任何需要解引用 pA 指针的代码，所以真实情况下也不会引发<code>segment fault</code>。
<ul><li><font style="background:yellow;">这里对成员函数的解析，和查找其对应的代码的工作都是在编译阶段完成而非运行时完成的，这就是所谓的静态绑定，也叫早绑定。正确理解C++的静态绑定可以理解一些特殊情况下C++的行为。『贼容易错』</font></li></ul></li></ul></li></ul> <h3 id="✅上面是难点"><a href="#✅上面是难点" class="header-anchor">#</a> ✅上面是难点</h3> <ul><li>因为<strong>对于非虚成员函数，Ｃ++这门语言是静态绑定的</strong>。</li> <li><font style="background:yellow;">这也是Ｃ++语言和其它语言Java, Python的一个显著区别</font></li></ul> <h3 id="_3-6-const对象"><a href="#_3-6-const对象" class="header-anchor">#</a> 3.6.const对象</h3> <ul><li><p>例题6</p></li> <li><p>题目来源和<a href="https://www.nowcoder.com/test/question/done?tid=44470458&amp;qid=1318#summary" target="_blank" rel="noopener noreferrer">参考资料<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A::f() &quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A::f() const &quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B::f() &quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">//还是虚函数！，只是说，覆盖了，其实是vitual</span>
	<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B::f() const &quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">const</span> A <span class="token operator">*</span>a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	a<span class="token operator">-&gt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	A <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	p<span class="token operator">-&gt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//多态</span>
	<span class="token function">g</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//先转换为const指针，由于只能调用const函数，所以不是多态了「因为此时不需要借助vptr去偏移了」</span>
	<span class="token keyword">delete</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//输出</span>
<span class="token comment">//B::f() A::f() const</span>
<span class="token comment">//输出前面是因为多态</span>
<span class="token comment">//输出后面是因为不是多态！！！（注意）</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><ul><li>解释原因</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>由于<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>在基类中声明为虚的，则p<span class="token operator">-&gt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>根据『对象类型』<span class="token punctuation">(</span>B<span class="token punctuation">)</span>调用<span class="token class-name">B</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，
  此时编译器对虚方法使用动态联编，输出<span class="token class-name">B</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>。
    
由于<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>在基类中未声明为虚的，故p<span class="token operator">-&gt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> 『根据指针类型』<span class="token punctuation">(</span>A<span class="token punctuation">)</span>调用<span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>，此时编译器对非虚方法使用静态联编，输出<span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><p>C++ primer告诉我们，P537</p> <p>当我们在派生类中覆盖某个虚函数时，可以再次使用virtual关键字指出该函数的性质，然而<strong>这么做并非必须</strong>！因为，<strong>基类中的虚函数，在派生类中隐含的也是1个虚函数！</strong></p></li></ul> <h2 id="谈一谈null-0-nullptr"><a href="#谈一谈null-0-nullptr" class="header-anchor">#</a> 谈一谈NULL，0，nullptr</h2> <div class="language- extra-class"><pre><code> nullptr是**一个编译期常量，其类型为nullptr_t**。 它既不是整型类型，也不是指针类型； 在模板推导中，nullptr被推导为nullptr_t类型，仍**可隐式转为指针**
</code></pre></div><p>在C中NULL是什么，在C的头文件中，通常定义如下：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>但是在C++中，它是这样定义的：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>或者你可以在stddef.h看到完整的这段：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression"><span class="token constant">NULL</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>__cplusplus<span class="token punctuation">)</span>  </span><span class="token comment">//C++里面</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>   <span class="token comment">//大概是C里面</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>也就是说，在C++中，NULL不过也是0罢了，把它当成空指针只是一个无可奈何的选择罢了。</p> <p>那么为什么在C++和C中不一样呢？因为C++中不能将<code>void *</code>类型的指针<strong>隐式转换</strong>成其他指针类型，从下面的例子可以看出来：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//null.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;12345&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>编译：</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>$ g+ -o null null.cpp
null.cpp: In function 'int main()':
null.cpp:5:17: error: invalid conversion from 'void*' to 'int*' [-fpermissive]
  int *a = (void*)p;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>所以不能将NULL定义为(void*)0。</p> <p>nullptr并非整型类别，甚至也不是指针类型，但是能转换成任意指针类型。nullptr的实际类型是std:nullptr_t。</p> <p><strong>std::nullptr_t</strong> 是空指针字面量 <a href="https://www.apiref.com/cpp-zh/cpp/language/nullptr.html" target="_blank" rel="noopener noreferrer"><code>nullptr</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的类型。它是既非指针类型亦非指向成员指针类型的独立类型。</p> <p>参考资料：https://www.apiref.com/cpp-zh/cpp/types/nullptr_t.html</p> <p>这个新特性特别有助于避免将空指针解释为整数值发生的错误。</p> <p>nullptr是一个新的关键字。它会自动转换为一个指针类型，但<strong>不会转换为任何整数类型</strong>。它的类型是std::nullptr_t，所以你现在甚至可以重载传递空指针的操作。std::nullptr_t算作一个<strong>基本数据类型</strong></p> <h2 id="✅杂谈"><a href="#✅杂谈" class="header-anchor">#</a> ✅杂谈</h2> <h3 id="_1-常量表达式"><a href="#_1-常量表达式" class="header-anchor">#</a> 1.常量表达式</h3> <ul><li>《<a href="https://www.nowcoder.com/test/question/done?tid=43575799&amp;qid=67992" target="_blank" rel="noopener noreferrer">C++Primer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>》</li></ul> <h3 id="_2-c-98关键字"><a href="#_2-c-98关键字" class="header-anchor">#</a> 2.C++98关键字</h3> <ul><li><p>1、<code>static</code></p> <ul><li><p>修改变量或函数存储的形式，比如<code>.data</code>，<code>.bss</code></p></li> <li><p>作用是：穿透作用域、『C++ primer PXX好像是这么说的』</p></li> <li><p>参考：牛客网：<a href="https://www.nowcoder.com/test/question/done?tid=44308658&amp;qid=14302#summary" target="_blank" rel="noopener noreferrer">关于static用途说法正确的是<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>？</p></li></ul></li> <li><p>2、<code>const</code></p> <ul><li>修改变量or函数的只读方式</li></ul></li> <li><p>3、<code>inline</code></p></li> <li><p>建议在“编译期”，直接将整个函数的代码插入调用语句处</p></li> <li><p>4、<code>friend</code></p> <ul><li>声明友元，包括，友元函数，友元类</li></ul></li></ul> <h2 id="✅常识-非面试"><a href="#✅常识-非面试" class="header-anchor">#</a> ✅常识-非面试</h2> <h3 id="_1-区分c-和c"><a href="#_1-区分c-和c" class="header-anchor">#</a> 1.区分C++和C</h3> <div class="language- extra-class"><pre><code>C和C++从来就不是一个东西！C++部分兼容C
</code></pre></div><div class="language-c line-numbers-mode"><pre class="language-c"><code>C<span class="token operator">++</span><span class="token number">11</span>中没有的C99<span class="token operator">/</span>C11特性
    虽然在过去C或多或少可以看作是C<span class="token operator">++</span>的子集，但是C99标准增加了一些C<span class="token operator">++</span>没有的新特性
下面列出了一些只有C99<span class="token operator">/</span>C11中才有的特性<span class="token operator">:</span>	
	指定初始化器<span class="token punctuation">;</span>
	复合初始化器<span class="token punctuation">(</span>Compound initializer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	受限指针<span class="token punctuation">(</span> Restricted pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>即，restric指针<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  变长数组<span class="token punctuation">;</span>
	伸缩型数组成员<span class="token punctuation">;</span>
	带可变数量参数的宏。

注意
以上所列只是在特定时期内的情况，随着时间的推移和C、C<span class="token operator">++</span>的不断发展，列表中的项会有所增减。
    例如，C<span class="token operator">++</span><span class="token number">14</span>新增的一个特性就与『C99的变长数组』类似。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li>参考自：《C Primer Plus》P730</li></ul> <h2 id="静态函数可以加virtual吗"><a href="#静态函数可以加virtual吗" class="header-anchor">#</a> 静态函数可以加virtual吗？</h2> <p>不可以！virtual用在继承体系中。</p> <h2 id="new是线程安全的吗"><a href="#new是线程安全的吗" class="header-anchor">#</a> new是线程安全的吗？</h2> <p>赵4老师：new和delete线程安全不安全还决定于链接的是否支持多线程的库。</p> <p>libc中有非线程安全/线程安全两个版本malloc函数</p> <ul><li>参考资料：[About thread safety in malloc and free <a href="https://stackoverflow.com/questions/987444/about-thread-safety-in-malloc-and-free" target="_blank" rel="noopener noreferrer">duplicate]<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="gdb如何调试多线程"><a href="#gdb如何调试多线程" class="header-anchor">#</a> gdb如何调试多线程？</h2> <ul><li>安装pstack，使用<code>pstack pid</code></li> <li>pstree好像默认又</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>//查看当前运行的进程
<span class="token function">ps</span> aux<span class="token operator">|</span><span class="token function">grep</span> a.out
//查看当前运行的轻量级进程
<span class="token function">ps</span> -aL<span class="token operator">|</span><span class="token function">grep</span> a.out
//查看主线程和新线程的关系
pstree <span class="token parameter variable">-p</span> 主线程id
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>参考资料：<a href="https://blog.csdn.net/zhangye3017/article/details/80382496" target="_blank" rel="noopener noreferrer">线程的查看以及利用gdb调试多线程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="🔋-参考资料"><a href="#🔋-参考资料" class="header-anchor">#</a> 🔋 参考资料</h2> <ul><li>《Linux多线程服务端编程》，陈硕</li> <li>光城，<a href="https://light-city.club/sc/" target="_blank" rel="noopener noreferrer">C++那些事<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>重要网站：『<a href="https://www.stroustrup.com/bs_faq2.html#virtual-ctor" target="_blank" rel="noopener noreferrer">Bjarne Stroustrup's C++ Style and Technique FAQ<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>』
<ul><li><a href="https://www.stroustrup.com/bs_faq2.html#virtual-ctor" target="_blank" rel="noopener noreferrer">https://www.stroustrup.com/bs_faq2.html#virtual-ctor<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.096c6153.js" defer></script><script src="/assets/js/2.82e96f38.js" defer></script><script src="/assets/js/1.6e29662b.js" defer></script><script src="/assets/js/18.3c3b6709.js" defer></script>
  </body>
</html>
